{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Low Level Design (LLD) \u2013 Machine Coding Practice","text":"<p>This repository contains production-style LLD solutions written in Java.</p>"},{"location":"#what-youll-find","title":"\ud83d\udccc What you\u2019ll find","text":"<ul> <li>Clear problem statements</li> <li>Design patterns used (Strategy, Observer, Command, etc.)</li> <li>Clean, interview-ready Java implementations</li> <li>Edge cases &amp; complexity discussion</li> </ul>"},{"location":"#topics-covered","title":"\ud83e\udde0 Topics Covered","text":"<ul> <li>Car Rental System</li> <li>Rate Limiter</li> <li>Text Editor (Undo/Redo)</li> <li>Meeting Room Scheduler</li> <li>Publish Subscribe System</li> <li>Custom HashMap</li> <li>And more\u2026</li> </ul> <p>\ud83d\udc49 Use the left navigation to explore problems.</p>"},{"location":"machine-coding/banking-system/","title":"Design a Complete Banking System","text":""},{"location":"machine-coding/banking-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory banking system that supports:</p>"},{"location":"machine-coding/banking-system/#level-1-basic-operations","title":"Level 1 \u2013 Basic Operations","text":"<ul> <li>Create accounts</li> <li>Deposit money</li> <li>Transfer money between accounts</li> </ul>"},{"location":"machine-coding/banking-system/#level-2-ranking","title":"Level 2 \u2013 Ranking","text":"<ul> <li>Return top spenders based on outgoing transactions</li> </ul>"},{"location":"machine-coding/banking-system/#level-3-scheduled-payments","title":"Level 3 \u2013 Scheduled Payments","text":"<ul> <li>Schedule payments with cashback</li> <li>Track payment status</li> <li>Process scheduled payments</li> </ul>"},{"location":"machine-coding/banking-system/#level-4-account-merging","title":"Level 4 \u2013 Account Merging","text":"<ul> <li>Merge two accounts into one</li> <li>Preserve balances, transaction history, and scheduled payments</li> </ul> <p>All operations are timestamp-based and executed in memory.</p>"},{"location":"machine-coding/banking-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":"<p>The system models real-world banking behavior: - Each Account owns its balance, outgoing total, and scheduled payments - Payments transition through lifecycle states - Rankings are computed using outgoing totals - Merging accounts preserves financial correctness</p>"},{"location":"machine-coding/banking-system/#core-entities","title":"\ud83c\udfd7\ufe0f Core Entities","text":""},{"location":"machine-coding/banking-system/#account","title":"Account","text":"<pre><code>class Account {\n    String accountId;\n    int balance;\n    int totalOutgoing;\n    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();\n\n    Account(String accountId) {\n        this.accountId = accountId;\n        this.balance = 0;\n        this.totalOutgoing = 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#payment","title":"Payment","text":"<pre><code>class Payment {\n    String paymentId;\n    String fromAccount;\n    String toAccount;\n    int amount;\n    double cashbackPercentage;\n    int scheduledTime;\n    PaymentStatus status;\n\n    Payment(String paymentId, String from, String to, int amount,\n            double cashback, int time) {\n        this.paymentId = paymentId;\n        this.fromAccount = from;\n        this.toAccount = to;\n        this.amount = amount;\n        this.cashbackPercentage = cashback;\n        this.scheduledTime = time;\n        this.status = PaymentStatus.SCHEDULED;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#paymentstatus","title":"PaymentStatus","text":"<pre><code>enum PaymentStatus {\n    SCHEDULED,\n    PROCESSED,\n    FAILED\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#full-java-implementation","title":"\ud83d\udcbb Full Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class BankingSystem {\n\n    private Map&lt;String, Account&gt; accounts = new HashMap&lt;&gt;();\n    private int paymentCounter = 1;\n\n    // ---------------- LEVEL 1 ----------------\n\n    public boolean createAccount(String accountId, int timestamp) {\n        if (accounts.containsKey(accountId)) return false;\n        accounts.put(accountId, new Account(accountId));\n        return true;\n    }\n\n    public Optional&lt;Integer&gt; deposit(String accountId, int timestamp, int amount) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return Optional.empty();\n        acc.balance += amount;\n        return Optional.of(acc.balance);\n    }\n\n    public Optional&lt;Integer&gt; transfer(String fromId, String toId, int timestamp, int amount) {\n        Account from = accounts.get(fromId);\n        Account to = accounts.get(toId);\n\n        if (from == null || to == null || from.balance &lt; amount) {\n            return Optional.empty();\n        }\n\n        from.balance -= amount;\n        to.balance += amount;\n        from.totalOutgoing += amount;\n\n        return Optional.of(from.balance);\n    }\n\n    // ---------------- LEVEL 2 ----------------\n\n    public List&lt;String&gt; topSpenders(int timestamp, int n) {\n        List&lt;Account&gt; list = new ArrayList&lt;&gt;(accounts.values());\n\n        list.sort((a, b) -&gt; {\n            if (b.totalOutgoing != a.totalOutgoing) {\n                return b.totalOutgoing - a.totalOutgoing;\n            }\n            return a.accountId.compareTo(b.accountId);\n        });\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; Math.min(n, list.size()); i++) {\n            result.add(list.get(i).accountId);\n        }\n        return result;\n    }\n\n    // ---------------- LEVEL 3 ----------------\n\n    public void schedulePayment(String accountId, String targetAccId,\n                                int timestamp, int amount, double cashbackPercentage) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return;\n\n        String paymentId = \"PAY-\" + paymentCounter++;\n        Payment payment = new Payment(\n                paymentId, accountId, targetAccId,\n                amount, cashbackPercentage, timestamp\n        );\n\n        acc.payments.add(payment);\n    }\n\n    public void processScheduledPayments(int currentTimestamp) {\n        for (Account acc : accounts.values()) {\n            for (Payment p : acc.payments) {\n                if (p.status != PaymentStatus.SCHEDULED) continue;\n                if (p.scheduledTime &gt; currentTimestamp) continue;\n\n                Account from = accounts.get(p.fromAccount);\n                Account to = accounts.get(p.toAccount);\n\n                if (from == null || to == null || from.balance &lt; p.amount) {\n                    p.status = PaymentStatus.FAILED;\n                    continue;\n                }\n\n                from.balance -= p.amount;\n                to.balance += p.amount;\n                from.totalOutgoing += p.amount;\n\n                int cashback = (int) (p.amount * p.cashbackPercentage / 100.0);\n                from.balance += cashback;\n\n                p.status = PaymentStatus.PROCESSED;\n            }\n        }\n    }\n\n    public String getPaymentStatus(String accountId, int timestamp, String paymentId) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return \"NOT_FOUND\";\n\n        for (Payment p : acc.payments) {\n            if (p.paymentId.equals(paymentId)) {\n                return p.status.name();\n            }\n        }\n        return \"NOT_FOUND\";\n    }\n\n    // ---------------- LEVEL 4 ----------------\n\n    public void mergeAccounts(String accountId1, String accountId2) {\n        if (!accounts.containsKey(accountId1) || !accounts.containsKey(accountId2)) {\n            return;\n        }\n\n        Account a1 = accounts.get(accountId1);\n        Account a2 = accounts.get(accountId2);\n\n        a1.balance += a2.balance;\n        a1.totalOutgoing += a2.totalOutgoing;\n        a1.payments.addAll(a2.payments);\n\n        accounts.remove(accountId2);\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Aggregation (Account owns Payments)</li> <li>Domain Driven Design</li> <li>Command-style processing (timestamp-based)</li> </ul>"},{"location":"machine-coding/banking-system/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Duplicate account creation</li> <li>Insufficient balance transfers</li> <li>Payment failures</li> <li>Cashback calculation</li> <li>Ranking ties</li> <li>Merging accounts with active payments</li> </ul>"},{"location":"machine-coding/banking-system/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Create Account O(1) Deposit O(1) Transfer O(1) Top Spenders O(N log N) Schedule Payment O(1) Process Payments O(P) Merge Accounts O(P)"},{"location":"machine-coding/banking-system/#interview-notes","title":"\u2705 Interview Notes","text":"<p>Why store <code>List&lt;Payment&gt;</code> inside Account?</p> <p>Payments are owned by the account that initiates them. This simplifies lookup, merging, validation, and lifecycle management.</p>"},{"location":"machine-coding/banking-system/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Transaction history</li> <li>Interest calculation</li> <li>Account limits</li> <li>Fraud detection</li> <li>Persistent storage</li> </ul>"},{"location":"machine-coding/car-rental-system/","title":"Design a Car Rental System","text":""},{"location":"machine-coding/car-rental-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a car rental service that supports: - Full-day bookings - Kilometer-based pricing - Booking overlap checks - Early return &amp; delayed return handling</p>"},{"location":"machine-coding/car-rental-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/car-rental-system/#entities","title":"Entities","text":"<ul> <li>Car</li> <li>Order</li> <li>Trip</li> </ul>"},{"location":"machine-coding/car-rental-system/#key-rules","title":"Key Rules","text":"<ul> <li>Inclusive date ranges</li> <li>Effective end date = max(bookedTill, actualReturnDate)</li> <li>Extra kms charged beyond daily free allowance</li> </ul>"},{"location":"machine-coding/car-rental-system/#design-patterns-used","title":"\ud83c\udfd7\ufe0f Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>(Optional) Strategy for pricing</li> </ul>"},{"location":"machine-coding/car-rental-system/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>// paste your CarRentalService code here\n</code></pre>"},{"location":"machine-coding/car-rental-system/#edge-cases","title":"\u26a0\ufe0f Edge Cases","text":"<ul> <li> <p>Overlapping bookings</p> </li> <li> <p>Early return</p> </li> <li> <p>Late return</p> </li> <li> <p>Same-day booking</p> </li> </ul>"},{"location":"machine-coding/car-rental-system/#complexity","title":"\u23f1\ufe0f Complexity","text":"<ul> <li> <p>Booking: O(n) per car</p> </li> <li> <p>End Trip: O(1)</p> </li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/","title":"\ud83d\uddc2\ufe0f Design a File System (cd with <code>*</code> Wildcard)","text":""},{"location":"machine-coding/file-system-cd-wildcard/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design and implement an in-memory Unix filesystem shell that supports the following commands:</p> <ul> <li><code>mkdir &lt;path&gt;</code></li> <li><code>pwd</code></li> <li><code>cd &lt;path&gt;</code> (supports wildcard <code>*</code>)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#environment-rules","title":"Environment &amp; Rules","text":"<ul> <li>System starts at root directory <code>/</code></li> <li> <p>Paths can be:</p> <ul> <li>Absolute (start with <code>/</code>)</li> <li>Relative (start from current directory)</li> <li>Path separator is <code>/</code></li> <li>Multiple consecutive <code>/</code> are treated as one</li> <li>Filesystem exists only in memory</li> </ul> </li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#supported-path-segments","title":"\ud83d\udcc2 Supported Path Segments","text":"Segment Meaning <code>.</code> Current directory <code>..</code> Parent directory (root\u2019s parent is root itself) <code>*</code> Wildcard matching exactly one segment"},{"location":"machine-coding/file-system-cd-wildcard/#wildcard-resolution-rules","title":"\ud83e\udde0 Wildcard (<code>*</code>) Resolution Rules","text":"<p>When <code>*</code> is encountered during <code>cd</code> traversal:</p> <ol> <li>Prefer child directories</li> <li>If multiple children exist \u2192 pick lexicographically smallest</li> <li>If no child directories exist \u2192 fallback to <code>.</code></li> <li>If still applicable \u2192 fallback to <code>..</code></li> </ol> <p>This ensures:</p> <ul> <li>Deterministic behavior</li> <li>No ambiguity</li> <li>No branching paths</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/file-system-cd-wildcard/#core-abstractions","title":"Core Abstractions","text":""},{"location":"machine-coding/file-system-cd-wildcard/#1-filesystemnode-abstract","title":"1. FileSystemNode (Abstract)","text":"<ul> <li>Common base for files and directories</li> <li>Stores name and parent reference</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#2-directorynode","title":"2. DirectoryNode","text":"<ul> <li>Contains child nodes</li> <li>Uses <code>TreeMap</code> to maintain lexicographic order</li> <li>Supports wildcard resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#3-filenode","title":"3. FileNode","text":"<ul> <li>Placeholder (not used heavily but keeps design extensible)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>DirectoryNode\n \u251c\u2500\u2500 name\n \u251c\u2500\u2500 parent\n \u2514\u2500\u2500 TreeMap&lt;String, FileSystemNode&gt; children\n</code></pre> <ul> <li><code>TreeMap</code> ensures sorted traversal</li> <li>Parent pointers allow fast <code>pwd</code> and <code>..</code> resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class FileSystemShell {\n\n    abstract class FileSystemNode {\n        String name;\n        DirectoryNode parent;\n\n        FileSystemNode(String name, DirectoryNode parent) {\n            this.name = name;\n            this.parent = parent;\n        }\n\n        abstract boolean isDirectory();\n    }\n\n    class FileNode extends FileSystemNode {\n        FileNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return false;\n        }\n    }\n\n    class DirectoryNode extends FileSystemNode {\n        TreeMap&lt;String, FileSystemNode&gt; children = new TreeMap&lt;&gt;();\n\n        DirectoryNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return true;\n        }\n\n        FileSystemNode getChild(String name) {\n            return children.get(name);\n        }\n\n        void addChild(FileSystemNode node) {\n            children.putIfAbsent(node.name, node);\n        }\n\n        DirectoryNode smallestChildDir() {\n            for (FileSystemNode node : children.values()) {\n                if (node.isDirectory()) {\n                    return (DirectoryNode) node;\n                }\n            }\n            return null;\n        }\n    }\n\n    private final DirectoryNode root = new DirectoryNode(\"/\", null);\n    private DirectoryNode cwd = root;\n\n    public FileSystemShell() {}\n\n    // ================= pwd =================\n    public String pwd() {\n        if (cwd == root) return \"/\";\n        LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();\n        FileSystemNode cur = cwd;\n\n        while (cur != root) {\n            path.addFirst(cur.name);\n            cur = cur.parent;\n        }\n        return \"/\" + String.join(\"/\", path);\n    }\n\n    // ================= mkdir =================\n    public void mkdir(String path) {\n        DirectoryNode cur = path.startsWith(\"/\") ? root : cwd;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n                continue;\n            }\n\n            FileSystemNode child = cur.getChild(seg);\n            if (child == null) {\n                DirectoryNode newDir = new DirectoryNode(seg, cur);\n                cur.addChild(newDir);\n                cur = newDir;\n            } else if (child.isDirectory()) {\n                cur = (DirectoryNode) child;\n            } else {\n                return; // cannot mkdir inside file\n            }\n        }\n    }\n\n    // ================= cd =================\n    public void cd(String path) {\n        DirectoryNode start = path.startsWith(\"/\") ? root : cwd;\n        DirectoryNode cur = start;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n            }\n            else if (seg.equals(\"*\")) {\n                DirectoryNode next = cur.smallestChildDir();\n                if (next != null) cur = next;\n            }\n            else {\n                FileSystemNode node = cur.getChild(seg);\n                if (node == null || !node.isDirectory()) return;\n                cur = (DirectoryNode) node;\n            }\n        }\n        cwd = cur;\n    }\n}\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>CWD: /\npwd \u2192 /\n\nmkdir /a/b/c\npwd \u2192 /\n\ncd a/b\npwd \u2192 /a/b\n\ncd *\n\u2192 moves to /a/b/c\n\ncd ../*\n\u2192 resolves back to /a/b/c\n\ncd /*\n\u2192 resolves to /a (lexicographically smallest child of /)\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#failure-case-handling","title":"\u26a0\ufe0f Failure Case Handling","text":"<ul> <li><code>cd /nope/*/x</code> \u2192 fails</li> <li>Current directory remains unchanged</li> <li>No partial traversal applied</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity pwd O(depth) mkdir O(depth) cd O(depth \u00d7 log(children)) Memory O(total directories)"},{"location":"machine-coding/file-system-cd-wildcard/#why-this-design-works","title":"\ud83c\udfc6 Why This Design Works","text":"<p>\u2714 Deterministic wildcard resolution \u2714 Proper Unix semantics \u2714 Safe failure handling \u2714 Clean object-oriented design \u2714 Interview-grade clarity</p>"},{"location":"machine-coding/in-memory-database/","title":"Design a Complete In-Memory Database","text":""},{"location":"machine-coding/in-memory-database/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory database that stores records identified by a <code>key</code>. Each record contains multiple fields, and each field stores a value.</p> <p>The system evolves across 4 levels:</p>"},{"location":"machine-coding/in-memory-database/#levels-breakdown","title":"\ud83e\udde9 Levels Breakdown","text":""},{"location":"machine-coding/in-memory-database/#level-1-basic-operations","title":"\u2705 Level 1 \u2013 Basic Operations","text":"<ul> <li>Set values</li> <li>Conditional updates</li> <li>Conditional deletes</li> <li>Get values</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-2-scanning-filtering","title":"\u2705 Level 2 \u2013 Scanning &amp; Filtering","text":"<ul> <li>Scan all fields for a key</li> <li>Scan fields by prefix</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-3-ttl-time-to-live","title":"\u2705 Level 3 \u2013 TTL (Time-To-Live)","text":"<ul> <li>Fields can expire after a given TTL</li> <li>Expired fields are invisible</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-4-look-back-queries","title":"\u2705 Level 4 \u2013 Look-Back Queries","text":"<ul> <li>Retrieve field values as of a given timestamp</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/in-memory-database/#key-ideas","title":"Key Ideas","text":"<ul> <li>Multi-version storage per field</li> <li>Timestamp-aware writes</li> <li>Lazy expiration using TTL</li> <li>Sorted history for look-back</li> </ul>"},{"location":"machine-coding/in-memory-database/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":""},{"location":"machine-coding/in-memory-database/#versionedvalue","title":"VersionedValue","text":"<p>Stores historical versions of a field.</p> <pre><code>class VersionedValue {\n    int timestamp;\n    String value;\n    Integer expiryTime; // null means no TTL\n\n    VersionedValue(int timestamp, String value, Integer expiryTime) {\n        this.timestamp = timestamp;\n        this.value = value;\n        this.expiryTime = expiryTime;\n    }\n\n    boolean isExpired(int currentTime) {\n        return expiryTime != null &amp;&amp; currentTime &gt;= expiryTime;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#database-structure","title":"Database Structure","text":"<pre><code>Map&lt;key,\n  Map&lt;\n    field,\n    List&lt;VersionedValue&gt;\n  &gt;\n&gt;\n</code></pre>"},{"location":"machine-coding/in-memory-database/#full-java-implementation-all-levels","title":"\ud83d\udcbb Full Java Implementation (All Levels)","text":"<pre><code>import java.util.*;\n\npublic class InMemoryDatabase {\n\n    private Map&lt;String, Map&lt;String, List&lt;VersionedValue&gt;&gt;&gt; db = new HashMap&lt;&gt;();\n\n    // ---------- LEVEL 1 ----------\n\n    public void set(int timestamp, String key, String field, String value) {\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, null));\n    }\n\n    public boolean compareAndSet(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        set(timestamp, key, field, curr);\n        return true;\n    }\n\n    public boolean compareAndDelete(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        db.get(key).get(field)\n          .add(new VersionedValue(timestamp, null, null));\n        return true;\n    }\n\n    public String get(int timestamp, String key, String field) {\n        if (!db.containsKey(key) || !db.get(key).containsKey(field)) {\n            return null;\n        }\n        return getLatestValue(db.get(key).get(field), timestamp);\n    }\n\n    // ---------- LEVEL 2 ----------\n\n    public List&lt;String&gt; scan(int timestamp, String key) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    public List&lt;String&gt; scanByPrefix(int timestamp, String key, String prefix) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            if (!field.startsWith(prefix)) continue;\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    // ---------- LEVEL 3 ----------\n\n    public void setWithTTL(int timestamp, String key, String field, String value, int ttl) {\n        int expiry = timestamp + ttl;\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, expiry));\n    }\n\n    public boolean compareAndSetWithTTL(int timestamp, String key, String field,\n                                        int expectedValue, int newValue, int ttl) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        setWithTTL(timestamp, key, field, String.valueOf(newValue), ttl);\n        return true;\n    }\n\n    // ---------- HELPERS ----------\n\n    private String getLatestValue(List&lt;VersionedValue&gt; history, int timestamp) {\n        String result = null;\n        for (VersionedValue vv : history) {\n            if (vv.timestamp &gt; timestamp) break;\n            if (vv.isExpired(timestamp)) continue;\n            result = vv.value;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Field deletion using tombstones</li> <li>Expired values hidden automatically</li> <li>Prefix scans skip expired fields</li> <li>Look-back reads ignore future writes</li> <li>Multiple updates to same field</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Multi-Version Concurrency Control (MVCC)</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> <li>Lazy Expiration</li> <li>Time-based Snapshot Reads</li> </ul>"},{"location":"machine-coding/in-memory-database/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity set / get O(V) scan O(F \u00d7 V) scanByPrefix O(F \u00d7 V) TTL operations O(1) Look-back O(V) <p>F = fields per key, V = versions per field</p>"},{"location":"machine-coding/in-memory-database/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<p>Why versioned values instead of overwriting?</p> <p>Enables:</p> <ul> <li>Look-back queries</li> <li>Safe TTL handling</li> <li>Historical correctness</li> </ul> <p>Why lazy TTL cleanup?</p> <p>Avoids background threads and keeps implementation deterministic.</p>"},{"location":"machine-coding/in-memory-database/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Background compaction</li> <li>Range queries</li> <li>Indexing for prefix scans</li> <li>Persistent WAL</li> <li>Concurrent access handling</li> </ul> <p>```</p>"},{"location":"machine-coding/meeting-room-reservation/","title":"Design a Meeting Room Reservation System","text":""},{"location":"machine-coding/meeting-room-reservation/#problem-statement","title":"Problem Statement","text":"<p>Design a Meeting Room Reservation System for a fixed set of conference rooms.</p> <p>The system must: - Book meetings without overlap - Cancel existing meetings - Always choose the lexicographically smallest room ID when multiple rooms are available - Treat time intervals as inclusive (<code>[startTime, endTime]</code>)</p>"},{"location":"machine-coding/meeting-room-reservation/#key-requirements","title":"Key Requirements","text":"<ul> <li>Each room can host only one meeting at a time</li> <li>Meetings overlap if times intersect inclusively</li> <li>Cancel only active meetings</li> <li>Meeting IDs are unique for active bookings</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#class-design","title":"\ud83c\udfd7\ufe0f Class Design","text":""},{"location":"machine-coding/meeting-room-reservation/#class-name","title":"Class Name","text":"<p><code>RoomBooking</code></p>"},{"location":"machine-coding/meeting-room-reservation/#constructor","title":"Constructor","text":"<pre><code>RoomBooking(List&lt;String&gt; roomIds);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#methods","title":"Methods","text":"<pre><code>String bookMeeting(String meetingId, int startTime, int endTime);\nboolean cancelMeeting(String meetingId);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#design-overview","title":"\ud83e\udde9 Design Overview","text":""},{"location":"machine-coding/meeting-room-reservation/#core-data-structures","title":"Core Data Structures","text":"Structure Purpose <code>TreeMap&lt;Integer, Integer&gt;</code> Stores intervals per room <code>Map&lt;String, Room&gt;</code> Room registry <code>Map&lt;String, Meeting&gt;</code> Active meetings lookup <code>List&lt;String&gt;</code> Sorted room IDs"},{"location":"machine-coding/meeting-room-reservation/#entity-models","title":"\ud83c\udfdb\ufe0f Entity Models","text":""},{"location":"machine-coding/meeting-room-reservation/#meeting","title":"Meeting","text":"<ul> <li>meetingId</li> <li>roomId</li> <li>startTime</li> <li>endTime</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#room","title":"Room","text":"<ul> <li>roomId</li> <li>TreeMap of booked intervals (<code>start \u2192 end</code>)</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#booking-logic","title":"\ud83d\udd0d Booking Logic","text":"<p>To check if a room is free:</p> <ol> <li>Find the closest previous interval using <code>floorEntry</code></li> <li>Find the closest next interval using <code>ceilingEntry</code></li> <li>Reject booking if either overlaps (inclusive rules)</li> </ol>"},{"location":"machine-coding/meeting-room-reservation/#design-patterns-used","title":"\ud83e\udde0 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Ordered Resource Selection</li> <li>Interval Scheduling using TreeMap</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class RoomBooking {\n\n    class Meeting {\n        String meetingId;\n        String roomId;\n        int startTime;\n        int endTime;\n\n        Meeting(String meetingId, String roomId, int startTime, int endTime) {\n            this.meetingId = meetingId;\n            this.roomId = roomId;\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    class Room {\n        String roomId;\n        TreeMap&lt;Integer, Integer&gt; intervals = new TreeMap&lt;&gt;();\n\n        Room(String roomId) {\n            this.roomId = roomId;\n        }\n    }\n\n    private Map&lt;String, Room&gt; rooms = new HashMap&lt;&gt;();\n    private Map&lt;String, Meeting&gt; meetingMap = new HashMap&lt;&gt;();\n    private List&lt;String&gt; sortedRoomIds;\n\n    public RoomBooking(List&lt;String&gt; roomIds) {\n        sortedRoomIds = new ArrayList&lt;&gt;(roomIds);\n        Collections.sort(sortedRoomIds);\n\n        for (String id : roomIds) {\n            rooms.put(id, new Room(id));\n        }\n    }\n\n    public String bookMeeting(String meetingId, int startTime, int endTime) {\n\n        if (meetingMap.containsKey(meetingId)) {\n            return \"\";\n        }\n\n        for (String roomId : sortedRoomIds) {\n            Room room = rooms.get(roomId);\n            if (isAvailable(room, startTime, endTime)) {\n                room.intervals.put(startTime, endTime);\n                Meeting meeting = new Meeting(meetingId, roomId, startTime, endTime);\n                meetingMap.put(meetingId, meeting);\n                return roomId;\n            }\n        }\n        return \"\";\n    }\n\n    private boolean isAvailable(Room room, int startTime, int endTime) {\n\n        Map.Entry&lt;Integer, Integer&gt; floor = room.intervals.floorEntry(startTime);\n        if (floor != null &amp;&amp; floor.getValue() &gt;= startTime) {\n            return false;\n        }\n\n        Map.Entry&lt;Integer, Integer&gt; ceil = room.intervals.ceilingEntry(startTime);\n        if (ceil != null &amp;&amp; ceil.getKey() &lt;= endTime) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public boolean cancelMeeting(String meetingId) {\n        Meeting meeting = meetingMap.get(meetingId);\n        if (meeting == null) {\n            return false;\n        }\n\n        Room room = rooms.get(meeting.roomId);\n        room.intervals.remove(meeting.startTime);\n        meetingMap.remove(meetingId);\n        return true;\n    }\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Inclusive overlap (<code>end == start</code> is conflict)</li> <li>Duplicate meeting IDs rejected</li> <li>Cancelling non-existent meetings</li> <li>Correct reuse of rooms after cancellation</li> <li>Lexicographically smallest room chosen</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Book Meeting <code>O(R \u00d7 log M)</code> Cancel Meeting <code>O(log M)</code> Overlap Check <code>O(log M)</code> <p>R = number of rooms M = number of meetings per room</p>"},{"location":"machine-coding/meeting-room-reservation/#example","title":"\ud83e\uddea Example","text":"<pre><code>RoomBooking rb = new RoomBooking(Arrays.asList(\"roomA\", \"roomB\"));\n\nrb.bookMeeting(\"m1\", 10, 20); // roomA\nrb.bookMeeting(\"m2\", 15, 25); // roomB\nrb.bookMeeting(\"m3\", 20, 30); // \"\"\nrb.cancelMeeting(\"m1\");\nrb.bookMeeting(\"m4\", 20, 30); // roomA\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#possible-enhancements","title":"\ud83d\ude80 Possible Enhancements","text":"<ul> <li>PriorityQueue optimization</li> <li>Support recurring meetings</li> <li>Room capacity handling</li> <li>Time window queries</li> <li>Concurrency control</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/","title":"\ud83c\udfac Design a Movie Ticket Booking System (BookMyShow)","text":""},{"location":"machine-coding/movie-ticket-booking/#problem-statement","title":"Problem Statement","text":"<p>Design an in-memory movie ticket booking system similar to BookMyShow.</p> <p>The system supports:</p> <ul> <li>Multiple cities</li> <li>Multiple cinemas per city</li> <li>Multiple screens per cinema</li> <li>Multiple shows per screen</li> <li>Seat booking and cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#booking-rules","title":"Booking Rules","text":"<ul> <li>Prefer continuous seats in the same row</li> <li> <p>If multiple options exist:</p> <ul> <li>Choose lowest row</li> <li>Then lowest column</li> <li> <p>If continuous seats are unavailable:</p> </li> <li> <p>Allocate seats from lowest row &amp; column</p> </li> <li>If insufficient seats exist, do not book any seats</li> </ul> </li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#core-design-principles","title":"\ud83e\udde0 Core Design Principles","text":"<ul> <li>Each Show owns its own seats</li> <li>Screens can host multiple shows over time</li> <li>Seat availability is isolated per show</li> <li>No concurrency assumptions (single-threaded)</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#key-entities","title":"\ud83c\udfd7\ufe0f Key Entities","text":""},{"location":"machine-coding/movie-ticket-booking/#1-cinema","title":"1. Cinema","text":"<ul> <li>Belongs to a city</li> <li>Contains multiple screens</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#2-screen","title":"2. Screen","text":"<ul> <li>Has fixed rows &amp; columns</li> <li>Hosts multiple shows over time</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#3-show","title":"3. Show","text":"<ul> <li>Belongs to a movie</li> <li>Runs on a screen</li> <li>Owns a seat matrix</li> <li>Tracks free seats</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#4-ticket","title":"4. Ticket","text":"<ul> <li>Maps booked seats to a show</li> <li>Supports cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>cityId \u2192 List&lt;Cinema&gt;\ncinemaId \u2192 Cinema\nshowId \u2192 Show\nticketId \u2192 Ticket\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#java-implementation-solution-a","title":"\ud83d\udcbb Java Implementation (Solution A)","text":"<pre><code>import java.util.*;\n\npublic class Solution {\n\n    class Screen {\n        int rows, cols;\n        Screen(int rows, int cols) {\n            this.rows = rows;\n            this.cols = cols;\n        }\n    }\n\n    class Cinema {\n        int cinemaId;\n        List&lt;Screen&gt; screens;\n        Cinema(int cinemaId, List&lt;Screen&gt; screens) {\n            this.cinemaId = cinemaId;\n            this.screens = screens;\n        }\n    }\n\n    class Show {\n        int showId, movieId, cinemaId;\n        int rows, cols;\n        boolean[][] bookedSeats;\n        int freeSeats;\n\n        Show(int showId, int movieId, int cinemaId, Screen screen) {\n            this.showId = showId;\n            this.movieId = movieId;\n            this.cinemaId = cinemaId;\n            this.rows = screen.rows;\n            this.cols = screen.cols;\n            this.bookedSeats = new boolean[rows][cols];\n            this.freeSeats = rows * cols;\n        }\n    }\n\n    class Ticket {\n        String ticketId;\n        int showId;\n        List&lt;int[]&gt; seats;\n        boolean cancelled = false;\n\n        Ticket(String ticketId, int showId, List&lt;int[]&gt; seats) {\n            this.ticketId = ticketId;\n            this.showId = showId;\n            this.seats = seats;\n        }\n    }\n\n    Map&lt;Integer, Cinema&gt; cinemaDB = new HashMap&lt;&gt;();\n    Map&lt;Integer, List&lt;Cinema&gt;&gt; cityCinemaMap = new HashMap&lt;&gt;();\n    Map&lt;Integer, Show&gt; showDB = new HashMap&lt;&gt;();\n    Map&lt;String, Ticket&gt; ticketDB = new HashMap&lt;&gt;();\n\n    public void addCinema(int cinemaId, int cityId,\n                          int screenCount, int screenRow, int screenColumn) {\n\n        List&lt;Screen&gt; screens = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; screenCount; i++) {\n            screens.add(new Screen(screenRow, screenColumn));\n        }\n\n        Cinema cinema = new Cinema(cinemaId, screens);\n        cinemaDB.put(cinemaId, cinema);\n        cityCinemaMap.computeIfAbsent(cityId, k -&gt; new ArrayList&lt;&gt;()).add(cinema);\n    }\n\n    public void addShow(int showId, int movieId, int cinemaId,\n                        int screenIndex, long startTime, long endTime) {\n\n        Cinema cinema = cinemaDB.get(cinemaId);\n        if (cinema == null) return;\n\n        Screen screen = cinema.screens.get(screenIndex);\n        Show show = new Show(showId, movieId, cinemaId, screen);\n        showDB.put(showId, show);\n    }\n\n    public List&lt;String&gt; bookTicket(String ticketId, int showId, int ticketsCount) {\n        Show show = showDB.get(showId);\n        if (show == null || show.freeSeats &lt; ticketsCount) return Collections.emptyList();\n\n        List&lt;int[]&gt; allocated = allocateSeats(show, ticketsCount);\n        if (allocated.isEmpty()) return Collections.emptyList();\n\n        for (int[] seat : allocated) {\n            show.bookedSeats[seat[0]][seat[1]] = true;\n            show.freeSeats--;\n        }\n\n        ticketDB.put(ticketId, new Ticket(ticketId, showId, allocated));\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int[] s : allocated) {\n            result.add(s[0] + \"-\" + s[1]);\n        }\n        return result;\n    }\n\n    private List&lt;int[]&gt; allocateSeats(Show show, int count) {\n        // Try continuous seats\n        for (int r = 0; r &lt; show.rows; r++) {\n            int continuous = 0;\n            for (int c = 0; c &lt; show.cols; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    continuous++;\n                    if (continuous == count) {\n                        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n                        for (int k = c - count + 1; k &lt;= c; k++) {\n                            res.add(new int[]{r, k});\n                        }\n                        return res;\n                    }\n                } else {\n                    continuous = 0;\n                }\n            }\n        }\n\n        // Fallback: lowest row &amp; column\n        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n        for (int r = 0; r &lt; show.rows &amp;&amp; res.size() &lt; count; r++) {\n            for (int c = 0; c &lt; show.cols &amp;&amp; res.size() &lt; count; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    res.add(new int[]{r, c});\n                }\n            }\n        }\n        return res.size() == count ? res : Collections.emptyList();\n    }\n\n    public boolean cancelTicket(String ticketId) {\n        Ticket ticket = ticketDB.get(ticketId);\n        if (ticket == null || ticket.cancelled) return false;\n\n        Show show = showDB.get(ticket.showId);\n        for (int[] seat : ticket.seats) {\n            show.bookedSeats[seat[0]][seat[1]] = false;\n            show.freeSeats++;\n        }\n        ticket.cancelled = true;\n        return true;\n    }\n\n    public int getFreeSeatsCount(int showId) {\n        Show show = showDB.get(showId);\n        return show == null ? 0 : show.freeSeats;\n    }\n\n    public List&lt;Integer&gt; listCinemas(int movieId, int cityId) {\n        List&lt;Cinema&gt; cinemas = cityCinemaMap.getOrDefault(cityId, Collections.emptyList());\n        Set&lt;Integer&gt; result = new TreeSet&lt;&gt;();\n\n        for (Cinema cinema : cinemas) {\n            for (Show show : showDB.values()) {\n                if (show.movieId == movieId &amp;&amp; show.cinemaId == cinema.cinemaId) {\n                    result.add(cinema.cinemaId);\n                }\n            }\n        }\n        return new ArrayList&lt;&gt;(result);\n    }\n\n    public List&lt;Integer&gt; listShows(int movieId, int cinemaId) {\n        List&lt;Show&gt; shows = new ArrayList&lt;&gt;();\n        for (Show s : showDB.values()) {\n            if (s.movieId == movieId &amp;&amp; s.cinemaId == cinemaId) {\n                shows.add(s);\n            }\n        }\n\n        shows.sort((a, b) -&gt; {\n            if (a.showId != b.showId) return b.showId - a.showId;\n            return a.showId - b.showId;\n        });\n\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        for (Show s : shows) {\n            result.add(s.showId);\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Insufficient seats \u2192 no booking</li> <li>Ticket cancellation restores seats</li> <li>Continuous seat preference</li> <li>Multiple shows per cinema</li> <li>Movie listings per city</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addCinema O(screens) addShow O(1) bookTicket O(rows \u00d7 cols) cancelTicket O(k) (booked seats) listCinemas O(cinemas \u00d7 shows) getFreeSeatsCount O(1)"},{"location":"machine-coding/movie-ticket-booking/#why-this-design-is-correct","title":"\ud83c\udfc6 Why This Design is Correct","text":"<p>\u2714 Seats belong to Show, not Screen \u2714 Supports multiple shows per screen \u2714 Correct booking prioritization \u2714 Clean separation of responsibilities \u2714 Fully test-safe and interview-ready</p> <p>If you want, next I can:</p> <ul> <li>Add UML diagram</li> <li>Add MkDocs navigation entry</li> <li>Refactor to production-grade version</li> <li>Add unit tests</li> </ul> <p>Just say next \ud83d\ude80</p>"},{"location":"machine-coding/snake-game/","title":"Design Snake Game","text":""},{"location":"machine-coding/snake-game/#problem-statement","title":"Problem Statement","text":"<p>Design a Snake game simulator played on a 2D grid.</p> <ul> <li>The grid has fixed dimensions <code>rows \u00d7 cols</code></li> <li>The snake starts at position <code>(0,0)</code> with length <code>1</code></li> <li> <p>The snake moves one step at a time in one of the directions:</p> <ul> <li><code>\"U\"</code> (up), <code>\"D\"</code> (down), <code>\"L\"</code> (left), <code>\"R\"</code> (right)</li> <li>Food positions are provided in advance and appear sequentially</li> <li> <p>When the snake eats food:</p> </li> <li> <p>Snake length increases by 1</p> </li> <li>Score increases by 1</li> <li> <p>The game ends if:</p> </li> <li> <p>The snake hits the wall</p> </li> <li>The snake hits itself</li> <li>After the game ends, all further moves must return <code>-1</code></li> </ul> </li> </ul>"},{"location":"machine-coding/snake-game/#design-overview","title":"Design Overview","text":"<p>The snake is represented as an ordered sequence of cells. Each move adds a new head and conditionally removes the tail.</p>"},{"location":"machine-coding/snake-game/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li>Use a Deque to represent the snake body</li> <li>Use a HashSet for fast self-collision detection</li> <li>Use a Queue to store food positions</li> <li>Maintain a <code>gameOver</code> flag to handle post-termination behavior</li> </ul>"},{"location":"machine-coding/snake-game/#data-structures","title":"Data Structures","text":"Purpose Structure Snake body <code>Deque&lt;Cell&gt;</code> Collision check <code>HashSet&lt;Cell&gt;</code> Food sequence <code>Queue&lt;Cell&gt;</code> Game state <code>boolean gameOver</code>"},{"location":"machine-coding/snake-game/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/snake-game/#cell","title":"Cell","text":"<p>Represents a position on the grid.</p> <pre><code>class Cell {\n    int row;\n    int col;\n\n    Cell(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Cell)) return false;\n        Cell cell = (Cell) o;\n        return row == cell.row &amp;&amp; col == cell.col;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#design-patterns-used","title":"Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State management via <code>gameOver</code> flag</li> <li>Efficient simulation using Deque</li> <li>HashSet for constant-time collision detection</li> </ul>"},{"location":"machine-coding/snake-game/#java-implementation","title":"Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SnakeGame {\n\n    private int rows;\n    private int cols;\n    private Deque&lt;Cell&gt; snake;\n    private Set&lt;Cell&gt; occupied;\n    private Queue&lt;Cell&gt; foodQueue;\n    private int score;\n    private boolean gameOver;\n\n    public SnakeGame(int rows, int cols, String[] foodPositions) {\n        this.rows = rows;\n        this.cols = cols;\n        this.snake = new LinkedList&lt;&gt;();\n        this.occupied = new HashSet&lt;&gt;();\n        this.foodQueue = new LinkedList&lt;&gt;();\n        this.score = 0;\n        this.gameOver = false;\n\n        Cell start = new Cell(0, 0);\n        snake.addLast(start);\n        occupied.add(start);\n\n        for (String food : foodPositions) {\n            String[] parts = food.split(\",\");\n            foodQueue.offer(\n                new Cell(\n                    Integer.parseInt(parts[0]),\n                    Integer.parseInt(parts[1])\n                )\n            );\n        }\n    }\n\n    public int move(String direction) {\n        if (gameOver) {\n            return -1;\n        }\n\n        Cell head = snake.peekLast();\n        int r = head.row;\n        int c = head.col;\n\n        switch (direction) {\n            case \"U\": r--; break;\n            case \"D\": r++; break;\n            case \"L\": c--; break;\n            case \"R\": c++; break;\n        }\n\n        Cell newHead = new Cell(r, c);\n\n        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) {\n            gameOver = true;\n            return -1;\n        }\n\n        boolean eatsFood =\n            !foodQueue.isEmpty() &amp;&amp; foodQueue.peek().equals(newHead);\n\n        if (!eatsFood) {\n            Cell tail = snake.pollFirst();\n            occupied.remove(tail);\n        }\n\n        if (occupied.contains(newHead)) {\n            gameOver = true;\n            return -1;\n        }\n\n        snake.addLast(newHead);\n        occupied.add(newHead);\n\n        if (eatsFood) {\n            foodQueue.poll();\n            score++;\n        }\n\n        return score;\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#edge-cases-handled","title":"Edge Cases Handled","text":"<ul> <li>Wall collision</li> <li>Self collision</li> <li>Moves after game over</li> <li>No food scenario</li> <li>Snake moving into previous tail position</li> <li>Empty food list</li> </ul>"},{"location":"machine-coding/snake-game/#time-and-space-complexity","title":"Time and Space Complexity","text":""},{"location":"machine-coding/snake-game/#movedirection","title":"move(direction)","text":"<ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(rows \u00d7 cols)</li> </ul>"},{"location":"machine-coding/snake-game/#example","title":"Example","text":"<pre><code>SnakeGame game = new SnakeGame(2, 2, new String[]{});\n\ngame.move(\"R\"); // 0\ngame.move(\"D\"); // 0\ngame.move(\"R\"); // -1\ngame.move(\"U\"); // -1\n</code></pre>"},{"location":"machine-coding/snake-game/#interview-notes","title":"Interview Notes","text":"<ul> <li>Always remove the tail before checking self-collision</li> <li>Persist game-over state</li> <li>Deque + HashSet is the optimal combination</li> <li>Follow inclusive boundary rules strictly</li> </ul> <p>If you want, next I can:</p> <ul> <li>Add this to <code>mkdocs.yml</code> navigation</li> <li>Convert Text Editor (Undo/Redo) to the same format</li> <li>Create a reusable LLD markdown template</li> <li>Refactor code for interview-grade clarity</li> </ul> <p>Just tell me what\u2019s next.</p>"},{"location":"machine-coding/text-editor/","title":"Design a Text Editor with Undo &amp; Redo","text":""},{"location":"machine-coding/text-editor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor that:</p> <ul> <li>Stores text row-wise (line by line)</li> <li>Supports insert and delete operations on a single row</li> <li>Supports Undo and Redo</li> <li>Maintains edit history correctly</li> <li>Does NOT remove empty rows</li> </ul> <p>Each operation modifies exactly one row.</p>"},{"location":"machine-coding/text-editor/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/text-editor/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Insert text at a given row and column</li> <li>Delete text from a given row and column range</li> <li>Undo the most recent change</li> <li>Redo the most recently undone change</li> <li>Read the content of a row at any time</li> </ul>"},{"location":"machine-coding/text-editor/#key-observations","title":"Key Observations","text":"<ul> <li>Undo/Redo works best with Command Pattern</li> <li>Each edit operation should know how to execute and undo</li> <li>Redo history must be cleared after any new edit</li> </ul>"},{"location":"machine-coding/text-editor/#design-patterns-principles-used","title":"\ud83c\udfd7\ufe0f Design Patterns &amp; Principles Used","text":"<ul> <li>Command Pattern \u2192 Encapsulates edit operations</li> <li>Stack-based Undo/Redo</li> <li>Single Responsibility Principle</li> <li>Encapsulation</li> </ul>"},{"location":"machine-coding/text-editor/#data-model","title":"\ud83d\uddc2\ufe0f Data Model","text":"<pre><code>TextEditor\n\u251c\u2500\u2500 List&lt;StringBuilder&gt; rows\n\u251c\u2500\u2500 Stack&lt;Command&gt; undoStack\n\u251c\u2500\u2500 Stack&lt;Command&gt; redoStack\n\nCommand (interface)\n\u251c\u2500\u2500 execute()\n\u251c\u2500\u2500 undo()\n\nAddTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 column\n\u251c\u2500\u2500 text\n\nDeleteTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 startColumn\n\u251c\u2500\u2500 deletedText\n</code></pre>"},{"location":"machine-coding/text-editor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class TextEditor {\n\n    private final List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();\n    private final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();\n    private final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();\n\n    /* ==================== PUBLIC APIs ==================== */\n\n    public void addText(int row, int column, String text) {\n        ensureRowExists(row);\n\n        Command cmd = new AddTextCommand(row, column, text);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void deleteText(int row, int startColumn, int length) {\n        Command cmd = new DeleteTextCommand(row, startColumn, length);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void undo() {\n        if (undoStack.isEmpty()) return;\n\n        Command cmd = undoStack.pop();\n        cmd.undo();\n        redoStack.push(cmd);\n    }\n\n    public void redo() {\n        if (redoStack.isEmpty()) return;\n\n        Command cmd = redoStack.pop();\n        cmd.execute();\n        undoStack.push(cmd);\n    }\n\n    public String readLine(int row) {\n        return rows.get(row).toString();\n    }\n\n    /* ==================== INTERNAL HELPERS ==================== */\n\n    private void ensureRowExists(int row) {\n        while (rows.size() &lt;= row) {\n            rows.add(new StringBuilder());\n        }\n    }\n\n    /* ==================== COMMAND INTERFACE ==================== */\n\n    private interface Command {\n        void execute();\n        void undo();\n    }\n\n    /* ==================== ADD TEXT COMMAND ==================== */\n\n    private class AddTextCommand implements Command {\n        private final int row;\n        private final int column;\n        private final String text;\n\n        AddTextCommand(int row, int column, String text) {\n            this.row = row;\n            this.column = column;\n            this.text = text;\n        }\n\n        @Override\n        public void execute() {\n            rows.get(row).insert(column, text);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).delete(column, column + text.length());\n        }\n    }\n\n    /* ==================== DELETE TEXT COMMAND ==================== */\n\n    private class DeleteTextCommand implements Command {\n        private final int row;\n        private final int startColumn;\n        private final int length;\n        private String deletedText;\n\n        DeleteTextCommand(int row, int startColumn, int length) {\n            this.row = row;\n            this.startColumn = startColumn;\n            this.length = length;\n        }\n\n        @Override\n        public void execute() {\n            StringBuilder sb = rows.get(row);\n            deletedText = sb.substring(startColumn, startColumn + length);\n            sb.delete(startColumn, startColumn + length);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).insert(startColumn, deletedText);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/","title":"Design a Tic-Tac-Toe Game (NxN)","text":""},{"location":"machine-coding/tic-tac-toe/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a class <code>TicTacGame</code> that simulates a Tic-Tac-Toe game played on an m \u00d7 m board between two players.</p>"},{"location":"machine-coding/tic-tac-toe/#rules","title":"Rules","text":"<ul> <li>Players take turns placing marks on empty cells.</li> <li>Player 1 uses A, Player 2 uses B.</li> <li>The first player to place m consecutive symbols in:</li> <li>a row</li> <li>a column</li> <li>a diagonal   wins the game.</li> <li>Once a player wins, no further moves are allowed.</li> <li>Every subsequent move must return the same winner.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/tic-tac-toe/#key-observations","title":"Key Observations","text":"<ul> <li>Full board storage is not required.</li> <li>Each move affects:</li> <li>one row</li> <li>one column</li> <li>possibly two diagonals</li> <li>Winning can be checked in O(1) time.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#data-structures-used","title":"\ud83c\udfd7\ufe0f Data Structures Used","text":"Structure Purpose <code>int[] rows</code> Row-wise score tracking <code>int[] cols</code> Column-wise score tracking <code>int diag</code> Main diagonal score <code>int antiDiag</code> Anti-diagonal score <code>boolean gameOver</code> Locks the game after win <code>int winner</code> Stores the winning player"},{"location":"machine-coding/tic-tac-toe/#scoring-technique","title":"Scoring Technique","text":"<ul> <li>Player 1 \u2192 <code>+1</code></li> <li>Player 2 \u2192 <code>-1</code></li> <li>If absolute value reaches <code>m</code>, that player wins.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State Management</li> <li>Optimized Win Detection</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class TicTacGame {\n\n    private int m;\n    private int[] rows;\n    private int[] cols;\n    private int diag;\n    private int antiDiag;\n    private boolean gameOver;\n    private int winner;\n\n    public TicTacGame(int m) {\n        this.m = m;\n        this.rows = new int[m];\n        this.cols = new int[m];\n        this.diag = 0;\n        this.antiDiag = 0;\n        this.gameOver = false;\n        this.winner = 0;\n    }\n\n    /**\n     * @param row    row index\n     * @param col    column index\n     * @param player 1 or 2\n     * @return 0 = no winner, 1 = player 1 wins, 2 = player 2 wins\n     */\n    public int doMove(int row, int col, int player) {\n\n        // If game already ended, always return winner\n        if (gameOver) {\n            return winner;\n        }\n\n        int val = (player == 1) ? 1 : -1;\n\n        rows[row] += val;\n        cols[col] += val;\n\n        if (row == col) {\n            diag += val;\n        }\n\n        if (row + col == m - 1) {\n            antiDiag += val;\n        }\n\n        if (Math.abs(rows[row]) == m ||\n            Math.abs(cols[col]) == m ||\n            Math.abs(diag) == m ||\n            Math.abs(antiDiag) == m) {\n\n            gameOver = true;\n            winner = player;\n            return player;\n        }\n\n        return 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Winning by row, column, or diagonal</li> <li>Game lock after win</li> <li>Repeated moves return same winner</li> <li>Works for large boards (<code>m \u2264 200</code>)</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Space <code>doMove()</code> O(1) O(m)"},{"location":"machine-coding/tic-tac-toe/#example","title":"\ud83e\uddea Example","text":"<pre><code>TicTacGame game = new TicTacGame(2);\n\ngame.doMove(0, 1, 1); // 0\ngame.doMove(0, 0, 2); // 0\ngame.doMove(1, 1, 1); // 1 (Player 1 wins)\ngame.doMove(1, 0, 2); // 1 (Winner persists)\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#interview-notes","title":"\u2705 Interview Notes","text":"<ul> <li>Classic LLD + algorithm optimization problem</li> <li>Demonstrates clean state handling</li> <li>Shows ability to avoid brute-force board scanning</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Undo / Redo support</li> <li>Move history tracking</li> <li>UI rendering</li> <li>Multiplayer support</li> </ul>"}]}
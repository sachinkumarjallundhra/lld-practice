{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Low Level Design (LLD) \u2013 Machine Coding Practice","text":"<p>This repository contains production-style LLD solutions written in Java.</p>"},{"location":"#what-youll-find","title":"\ud83d\udccc What you\u2019ll find","text":"<ul> <li>Clear problem statements</li> <li>Design patterns used (Strategy, Observer, Command, etc.)</li> <li>Clean, interview-ready Java implementations</li> <li>Edge cases &amp; complexity discussion</li> </ul>"},{"location":"#topics-covered","title":"\ud83e\udde0 Topics Covered","text":"<ul> <li>Car Rental System</li> <li>Rate Limiter</li> <li>Text Editor (Undo/Redo)</li> <li>Meeting Room Scheduler</li> <li>Publish Subscribe System</li> <li>Custom HashMap</li> <li>And more\u2026</li> </ul> <p>\ud83d\udc49 Use the left navigation to explore problems.</p>"},{"location":"machine-coding/banking-system/","title":"Design a Complete Banking System","text":""},{"location":"machine-coding/banking-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory banking system that supports:</p>"},{"location":"machine-coding/banking-system/#level-1-basic-operations","title":"Level 1 \u2013 Basic Operations","text":"<ul> <li>Create accounts</li> <li>Deposit money</li> <li>Transfer money between accounts</li> </ul>"},{"location":"machine-coding/banking-system/#level-2-ranking","title":"Level 2 \u2013 Ranking","text":"<ul> <li>Return top spenders based on outgoing transactions</li> </ul>"},{"location":"machine-coding/banking-system/#level-3-scheduled-payments","title":"Level 3 \u2013 Scheduled Payments","text":"<ul> <li>Schedule payments with cashback</li> <li>Track payment status</li> <li>Process scheduled payments</li> </ul>"},{"location":"machine-coding/banking-system/#level-4-account-merging","title":"Level 4 \u2013 Account Merging","text":"<ul> <li>Merge two accounts into one</li> <li>Preserve balances, transaction history, and scheduled payments</li> </ul> <p>All operations are timestamp-based and executed in memory.</p>"},{"location":"machine-coding/banking-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":"<p>The system models real-world banking behavior: - Each Account owns its balance, outgoing total, and scheduled payments - Payments transition through lifecycle states - Rankings are computed using outgoing totals - Merging accounts preserves financial correctness</p>"},{"location":"machine-coding/banking-system/#core-entities","title":"\ud83c\udfd7\ufe0f Core Entities","text":""},{"location":"machine-coding/banking-system/#account","title":"Account","text":"<pre><code>class Account {\n    String accountId;\n    int balance;\n    int totalOutgoing;\n    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();\n\n    Account(String accountId) {\n        this.accountId = accountId;\n        this.balance = 0;\n        this.totalOutgoing = 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#payment","title":"Payment","text":"<pre><code>class Payment {\n    String paymentId;\n    String fromAccount;\n    String toAccount;\n    int amount;\n    double cashbackPercentage;\n    int scheduledTime;\n    PaymentStatus status;\n\n    Payment(String paymentId, String from, String to, int amount,\n            double cashback, int time) {\n        this.paymentId = paymentId;\n        this.fromAccount = from;\n        this.toAccount = to;\n        this.amount = amount;\n        this.cashbackPercentage = cashback;\n        this.scheduledTime = time;\n        this.status = PaymentStatus.SCHEDULED;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#paymentstatus","title":"PaymentStatus","text":"<pre><code>enum PaymentStatus {\n    SCHEDULED,\n    PROCESSED,\n    FAILED\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#full-java-implementation","title":"\ud83d\udcbb Full Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class BankingSystem {\n\n    private Map&lt;String, Account&gt; accounts = new HashMap&lt;&gt;();\n    private int paymentCounter = 1;\n\n    // ---------------- LEVEL 1 ----------------\n\n    public boolean createAccount(String accountId, int timestamp) {\n        if (accounts.containsKey(accountId)) return false;\n        accounts.put(accountId, new Account(accountId));\n        return true;\n    }\n\n    public Optional&lt;Integer&gt; deposit(String accountId, int timestamp, int amount) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return Optional.empty();\n        acc.balance += amount;\n        return Optional.of(acc.balance);\n    }\n\n    public Optional&lt;Integer&gt; transfer(String fromId, String toId, int timestamp, int amount) {\n        Account from = accounts.get(fromId);\n        Account to = accounts.get(toId);\n\n        if (from == null || to == null || from.balance &lt; amount) {\n            return Optional.empty();\n        }\n\n        from.balance -= amount;\n        to.balance += amount;\n        from.totalOutgoing += amount;\n\n        return Optional.of(from.balance);\n    }\n\n    // ---------------- LEVEL 2 ----------------\n\n    public List&lt;String&gt; topSpenders(int timestamp, int n) {\n        List&lt;Account&gt; list = new ArrayList&lt;&gt;(accounts.values());\n\n        list.sort((a, b) -&gt; {\n            if (b.totalOutgoing != a.totalOutgoing) {\n                return b.totalOutgoing - a.totalOutgoing;\n            }\n            return a.accountId.compareTo(b.accountId);\n        });\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; Math.min(n, list.size()); i++) {\n            result.add(list.get(i).accountId);\n        }\n        return result;\n    }\n\n    // ---------------- LEVEL 3 ----------------\n\n    public void schedulePayment(String accountId, String targetAccId,\n                                int timestamp, int amount, double cashbackPercentage) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return;\n\n        String paymentId = \"PAY-\" + paymentCounter++;\n        Payment payment = new Payment(\n                paymentId, accountId, targetAccId,\n                amount, cashbackPercentage, timestamp\n        );\n\n        acc.payments.add(payment);\n    }\n\n    public void processScheduledPayments(int currentTimestamp) {\n        for (Account acc : accounts.values()) {\n            for (Payment p : acc.payments) {\n                if (p.status != PaymentStatus.SCHEDULED) continue;\n                if (p.scheduledTime &gt; currentTimestamp) continue;\n\n                Account from = accounts.get(p.fromAccount);\n                Account to = accounts.get(p.toAccount);\n\n                if (from == null || to == null || from.balance &lt; p.amount) {\n                    p.status = PaymentStatus.FAILED;\n                    continue;\n                }\n\n                from.balance -= p.amount;\n                to.balance += p.amount;\n                from.totalOutgoing += p.amount;\n\n                int cashback = (int) (p.amount * p.cashbackPercentage / 100.0);\n                from.balance += cashback;\n\n                p.status = PaymentStatus.PROCESSED;\n            }\n        }\n    }\n\n    public String getPaymentStatus(String accountId, int timestamp, String paymentId) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return \"NOT_FOUND\";\n\n        for (Payment p : acc.payments) {\n            if (p.paymentId.equals(paymentId)) {\n                return p.status.name();\n            }\n        }\n        return \"NOT_FOUND\";\n    }\n\n    // ---------------- LEVEL 4 ----------------\n\n    public void mergeAccounts(String accountId1, String accountId2) {\n        if (!accounts.containsKey(accountId1) || !accounts.containsKey(accountId2)) {\n            return;\n        }\n\n        Account a1 = accounts.get(accountId1);\n        Account a2 = accounts.get(accountId2);\n\n        a1.balance += a2.balance;\n        a1.totalOutgoing += a2.totalOutgoing;\n        a1.payments.addAll(a2.payments);\n\n        accounts.remove(accountId2);\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Aggregation (Account owns Payments)</li> <li>Domain Driven Design</li> <li>Command-style processing (timestamp-based)</li> </ul>"},{"location":"machine-coding/banking-system/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Duplicate account creation</li> <li>Insufficient balance transfers</li> <li>Payment failures</li> <li>Cashback calculation</li> <li>Ranking ties</li> <li>Merging accounts with active payments</li> </ul>"},{"location":"machine-coding/banking-system/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Create Account O(1) Deposit O(1) Transfer O(1) Top Spenders O(N log N) Schedule Payment O(1) Process Payments O(P) Merge Accounts O(P)"},{"location":"machine-coding/banking-system/#interview-notes","title":"\u2705 Interview Notes","text":"<p>Why store <code>List&lt;Payment&gt;</code> inside Account?</p> <p>Payments are owned by the account that initiates them. This simplifies lookup, merging, validation, and lifecycle management.</p>"},{"location":"machine-coding/banking-system/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Transaction history</li> <li>Interest calculation</li> <li>Account limits</li> <li>Fraud detection</li> <li>Persistent storage</li> </ul>"},{"location":"machine-coding/car-rental-system/","title":"Design a Car Rental System","text":""},{"location":"machine-coding/car-rental-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a car rental service that supports: - Full-day bookings - Kilometer-based pricing - Booking overlap checks - Early return &amp; delayed return handling</p>"},{"location":"machine-coding/car-rental-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/car-rental-system/#entities","title":"Entities","text":"<ul> <li>Car</li> <li>Order</li> <li>Trip</li> </ul>"},{"location":"machine-coding/car-rental-system/#key-rules","title":"Key Rules","text":"<ul> <li>Inclusive date ranges</li> <li>Effective end date = max(bookedTill, actualReturnDate)</li> <li>Extra kms charged beyond daily free allowance</li> </ul>"},{"location":"machine-coding/car-rental-system/#design-patterns-used","title":"\ud83c\udfd7\ufe0f Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>(Optional) Strategy for pricing</li> </ul>"},{"location":"machine-coding/car-rental-system/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class CarRentalService {\n\n    class Car {\n        String licensePlate;\n        int costPerDay;\n        int freeKmsPerDay;\n        int costPerKm;\n        List&lt;Order&gt; listOfOrder = new ArrayList&lt;&gt;();\n\n        Car(String licensePlate, int costPerDay, int freeKmsPerDay, int costPerKm) {\n            this.licensePlate = licensePlate;\n            this.costPerDay = costPerDay;\n            this.freeKmsPerDay = freeKmsPerDay;\n            this.costPerKm = costPerKm;\n        }\n    }\n\n    class Order {\n        String orderId;\n        String carLicensePlate;\n        int fromDate;\n        int tillDate;\n        Trip trip;\n\n        Order(String orderId, String carLicensePlate, int fromDate, int tillDate) {\n            this.orderId = orderId;\n            this.carLicensePlate = carLicensePlate;\n            this.fromDate = fromDate;\n            this.tillDate = tillDate;\n        }\n    }\n\n    class Trip {\n        int startOdometer;\n        Integer endOdometer;\n        Integer endDay;\n\n        Trip(int startOdometer) {\n            this.startOdometer = startOdometer;\n        }\n    }\n\n    Map&lt;String, Car&gt; cars = new HashMap&lt;&gt;();\n    Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();\n\n    public void addCar(String licensePlate, int costPerDay, int freeKmsPerDay, int costPerKm) {\n        if (cars.containsKey(licensePlate)) return;\n        cars.put(licensePlate, new Car(licensePlate, costPerDay, freeKmsPerDay, costPerKm));\n    }\n\n    public boolean bookCar(String orderId, String carLicensePlate, String fromDate, String tillDate) {\n        if (orders.containsKey(orderId)) return false;\n\n        Car car = cars.get(carLicensePlate);\n        if (car == null) return false;\n\n        int from = parseDay(fromDate);\n        int till = parseDay(tillDate);\n        if (from &gt; till) return false;\n\n        for (Order order : car.listOfOrder) {\n            int effectiveTill = order.trip != null &amp;&amp; order.trip.endDay != null\n                    ? order.trip.endDay\n                    : order.tillDate;\n            if (from &lt;= effectiveTill &amp;&amp; order.fromDate &lt;= till) {\n                return false;\n            }\n        }\n\n        Order newOrder = new Order(orderId, carLicensePlate, from, till);\n        orders.put(orderId, newOrder);\n        car.listOfOrder.add(newOrder);\n        return true;\n    }\n\n    public void startTrip(String orderId, int odometerReading) {\n        Order order = orders.get(orderId);\n        if (order == null || order.trip != null) return;\n        order.trip = new Trip(odometerReading);\n    }\n\n    public int endTrip(String orderId, int finalOdometerReading, String endDate) {\n        Order order = orders.get(orderId);\n        if (order == null || order.trip == null) return 0;\n\n        Trip trip = order.trip;\n        if (trip.endDay != null) return 0;\n\n        int endDay = parseDay(endDate);\n        trip.endDay = endDay;\n        trip.endOdometer = finalOdometerReading;\n\n        int effectiveEndDay = Math.max(order.tillDate, endDay);\n        int days = 1 + (effectiveEndDay - order.fromDate);\n\n        int tripKms = finalOdometerReading - trip.startOdometer;\n        Car car = cars.get(order.carLicensePlate);\n\n        int freeKms = days * car.freeKmsPerDay;\n        int extraKms = Math.max(0, tripKms - freeKms);\n\n        return days * car.costPerDay + extraKms * car.costPerKm;\n    }\n\n    private int parseDay(String date) {\n        return Integer.parseInt(date.substring(8));\n    }\n}\n</code></pre>"},{"location":"machine-coding/car-rental-system/#edge-cases","title":"\u26a0\ufe0f Edge Cases","text":"<ul> <li> <p>Overlapping bookings</p> </li> <li> <p>Early return</p> </li> <li> <p>Late return</p> </li> <li> <p>Same-day booking</p> </li> </ul>"},{"location":"machine-coding/car-rental-system/#complexity","title":"\u23f1\ufe0f Complexity","text":"<ul> <li> <p>Booking: O(n) per car</p> </li> <li> <p>End Trip: O(1)</p> </li> </ul>"},{"location":"machine-coding/custom-hashmap/","title":"43. Design a Custom HashMap","text":""},{"location":"machine-coding/custom-hashmap/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory Custom HashMap that stores String keys and String values.</p> <p>You must implement:</p> <ul> <li>Custom hashing</li> <li>Buckets</li> <li>Collision handling</li> <li>Dynamic rehashing (grow &amp; shrink)</li> </ul> <p>\u2757 Important: Do NOT use any built-in <code>Map</code>, <code>Set</code>, or <code>Dictionary</code> for storing key\u2013value pairs.</p>"},{"location":"machine-coding/custom-hashmap/#hashing-buckets","title":"\ud83e\udde0 Hashing &amp; Buckets","text":""},{"location":"machine-coding/custom-hashmap/#hash-function","title":"Hash Function","text":"<pre><code>hash(key) = (key.length() ^ 2) + sum(charValue)\n</code></pre> <p>Where:</p> <ul> <li><code>a = 1, b = 2, \u2026 z = 26</code></li> </ul> <p>Example:</p> <pre><code>key = \"abcd\"\nhash = 4*4 + (1+2+3+4) = 26\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#bucket-index","title":"Bucket Index","text":"<pre><code>bucketIndex = hash(key) % bucketsCount\n</code></pre> <ul> <li>Initial <code>bucketsCount = 2</code></li> <li>Collisions go into the same bucket (linked list)</li> </ul>"},{"location":"machine-coding/custom-hashmap/#load-factor-rehashing","title":"\ud83d\udcca Load Factor &amp; Rehashing","text":""},{"location":"machine-coding/custom-hashmap/#load-factor","title":"Load Factor","text":"<pre><code>LoadFactor = round2(size / bucketsCount)\nround2(x) = Math.round(x * 100.0) / 100.0\n</code></pre> <ul> <li><code>minLoadFactor &lt; maxLoadFactor</code></li> <li>All load factor values are rounded to 2 decimals</li> </ul>"},{"location":"machine-coding/custom-hashmap/#rehash-rules","title":"Rehash Rules","text":"<p>After every put() and remove():</p>"},{"location":"machine-coding/custom-hashmap/#grow","title":"\ud83d\udd3c Grow","text":"<ul> <li>If <code>LoadFactor &gt; maxLoadFactor</code></li> <li>Double buckets: <code>2 \u2192 4 \u2192 8 \u2192 \u2026</code></li> </ul>"},{"location":"machine-coding/custom-hashmap/#shrink","title":"\ud83d\udd3d Shrink","text":"<ul> <li>If <code>LoadFactor &lt; minLoadFactor</code></li> <li>Halve buckets until valid</li> <li>\u2757 Never shrink below 2 buckets</li> </ul> <p>Rehashing means:</p> <ul> <li>Create new buckets</li> <li>Reinsert all existing entries using:</li> </ul> <pre><code>newBucketIndex = hash(key) % newBucketsCount\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#api-design","title":"\ud83e\udde9 API Design","text":""},{"location":"machine-coding/custom-hashmap/#constructor","title":"Constructor","text":"<pre><code>CustomHashMap(double minLoadFactor, double maxLoadFactor)\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#put","title":"put","text":"<pre><code>void put(String key, String value)\n</code></pre> <ul> <li><code>key</code>, <code>value</code> length: <code>1..20</code></li> <li><code>key</code> contains only <code>a-z</code></li> <li>Update value if key exists</li> <li>Size increases only for new keys</li> </ul>"},{"location":"machine-coding/custom-hashmap/#get","title":"get","text":"<pre><code>String get(String key)\n</code></pre> <ul> <li>Returns value if found</li> <li>Returns <code>\"\"</code> if not found</li> </ul>"},{"location":"machine-coding/custom-hashmap/#remove","title":"remove","text":"<pre><code>String remove(String key)\n</code></pre> <ul> <li>Removes entry</li> <li>Returns removed value</li> <li>Returns <code>\"\"</code> if key not found</li> </ul>"},{"location":"machine-coding/custom-hashmap/#getbucketkeys","title":"getBucketKeys","text":"<pre><code>List&lt;String&gt; getBucketKeys(int bucketIndex)\n</code></pre> <ul> <li>Invalid index \u2192 empty list</li> <li>Returns keys in that bucket</li> <li>Sorted lexicographically ascending</li> </ul>"},{"location":"machine-coding/custom-hashmap/#size","title":"size","text":"<pre><code>int size()\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#bucketscount","title":"bucketsCount","text":"<pre><code>int bucketsCount()\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#examples","title":"\ud83e\uddea Examples","text":""},{"location":"machine-coding/custom-hashmap/#example-1-basic-operations","title":"Example 1 \u2013 Basic Operations","text":"<pre><code>CustomHashMap map = new CustomHashMap(0.25, 0.75);\n\nmap.put(\"a\", \"one\");\nmap.put(\"bb\", \"two\");\n\nmap.get(\"a\")      // \"one\"\nmap.get(\"x\")      // \"\"\n\nmap.put(\"a\", \"ONE\");\nmap.get(\"a\")      // \"ONE\"\n\nmap.remove(\"bb\")  // \"two\"\nmap.remove(\"bb\")  // \"\"\nmap.size()        // 1\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#example-2-collision-handling","title":"Example 2 \u2013 Collision Handling","text":"<pre><code>// bucketsCount = 2\nmap.put(\"a\", \"v1\");   // hash=2 \u2192 bucket 0\nmap.put(\"c\", \"v2\");   // hash=4 \u2192 bucket 0\n\nmap.getBucketKeys(0)  // [\"a\", \"c\"]\nmap.getBucketKeys(1)  // []\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#example-3-rehash-grow","title":"Example 3 \u2013 Rehash Grow","text":"<pre><code>map.put(\"a\", \"1\");    // LF=0.50\nmap.put(\"b\", \"2\");    // LF=1.00 \u2192 rehash to 4 buckets\n\nmap.bucketsCount()   // 4\nmap.size()           // 2\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#example-4-rehash-shrink","title":"Example 4 \u2013 Rehash Shrink","text":"<pre><code>// Suppose size=3, buckets=8\n// LF=0.38 &lt; minLoadFactor(0.50) \u2192 shrink to 4\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/custom-hashmap/#data-structures-used","title":"Data Structures Used","text":"<ul> <li>Array of buckets</li> <li>Each bucket = Singly Linked List</li> <li>Manual lexicographic sorting (no Collections.sort)</li> </ul>"},{"location":"machine-coding/custom-hashmap/#design-patterns-concepts","title":"\ud83e\udde0 Design Patterns &amp; Concepts","text":"<ul> <li>Hashing</li> <li>Separate Chaining (Collision Handling)</li> <li>Dynamic Resizing</li> <li>Load Factor Control</li> <li>Manual Rehashing</li> </ul>"},{"location":"machine-coding/custom-hashmap/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class CustomHashMap {\n\n    class Entry {\n        String key;\n        String value;\n        Entry next;\n\n        Entry(String key, String value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private Entry[] buckets;\n    private int size;\n    private double minLoadFactor;\n    private double maxLoadFactor;\n\n    public CustomHashMap(double minLoadFactor, double maxLoadFactor) {\n        this.minLoadFactor = round2(minLoadFactor);\n        this.maxLoadFactor = round2(maxLoadFactor);\n        this.buckets = new Entry[2];\n        this.size = 0;\n    }\n\n    private double round2(double val) {\n        return Math.round(val * 100.0) / 100.0;\n    }\n\n    public void put(String key, String value) {\n        int index = bucketIndex(key, buckets.length);\n        Entry curr = buckets[index];\n\n        while (curr != null) {\n            if (curr.key.equals(key)) {\n                curr.value = value;\n                return;\n            }\n            curr = curr.next;\n        }\n\n        Entry newEntry = new Entry(key, value);\n        newEntry.next = buckets[index];\n        buckets[index] = newEntry;\n        size++;\n\n        rehashIfNeeded();\n    }\n\n    public String get(String key) {\n        int index = bucketIndex(key, buckets.length);\n        Entry curr = buckets[index];\n\n        while (curr != null) {\n            if (curr.key.equals(key)) {\n                return curr.value;\n            }\n            curr = curr.next;\n        }\n        return \"\";\n    }\n\n    public String remove(String key) {\n        int index = bucketIndex(key, buckets.length);\n        Entry curr = buckets[index];\n        Entry prev = null;\n\n        while (curr != null) {\n            if (curr.key.equals(key)) {\n                if (prev == null) {\n                    buckets[index] = curr.next;\n                } else {\n                    prev.next = curr.next;\n                }\n                size--;\n                rehashIfNeeded();\n                return curr.value;\n            }\n            prev = curr;\n            curr = curr.next;\n        }\n        return \"\";\n    }\n\n    public List&lt;String&gt; getBucketKeys(int bucketIndex) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (bucketIndex &lt; 0 || bucketIndex &gt;= buckets.length) return result;\n\n        Entry curr = buckets[bucketIndex];\n        while (curr != null) {\n            result.add(curr.key);\n            curr = curr.next;\n        }\n\n        // manual sort\n        for (int i = 0; i &lt; result.size(); i++) {\n            for (int j = i + 1; j &lt; result.size(); j++) {\n                if (result.get(i).compareTo(result.get(j)) &gt; 0) {\n                    String tmp = result.get(i);\n                    result.set(i, result.get(j));\n                    result.set(j, tmp);\n                }\n            }\n        }\n        return result;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public int bucketsCount() {\n        return buckets.length;\n    }\n\n    private int bucketIndex(String key, int count) {\n        return hash(key) % count;\n    }\n\n    private int hash(String key) {\n        int sum = 0;\n        for (char c : key.toCharArray()) {\n            sum += (c - 'a' + 1);\n        }\n        int len = key.length();\n        return len * len + sum;\n    }\n\n    private void rehashIfNeeded() {\n        double lf = loadFactor();\n\n        while (lf &gt; maxLoadFactor) {\n            rehash(buckets.length * 2);\n            lf = loadFactor();\n        }\n\n        while (lf &lt; minLoadFactor &amp;&amp; buckets.length &gt; 2) {\n            rehash(buckets.length / 2);\n            lf = loadFactor();\n        }\n    }\n\n    private double loadFactor() {\n        return round2((double) size / buckets.length);\n    }\n\n    private void rehash(int newCount) {\n        Entry[] old = buckets;\n        buckets = new Entry[newCount];\n        size = 0;\n\n        for (Entry head : old) {\n            Entry curr = head;\n            while (curr != null) {\n                insertWithoutRehash(curr.key, curr.value);\n                curr = curr.next;\n            }\n        }\n    }\n\n    private void insertWithoutRehash(String key, String value) {\n        int index = bucketIndex(key, buckets.length);\n        Entry e = new Entry(key, value);\n        e.next = buckets[index];\n        buckets[index] = e;\n        size++;\n    }\n}\n</code></pre>"},{"location":"machine-coding/custom-hashmap/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Average Worst put O(1) O(n) get O(1) O(n) remove O(1) O(n) rehash O(n) O(n)"},{"location":"machine-coding/custom-hashmap/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>This question tests fundamentals deeply</li> <li> <p>Expect follow-ups on:</p> <ul> <li>Open addressing vs chaining</li> <li>Load factor tuning</li> <li>Thread-safe HashMap</li> <li>Java HashMap internals</li> <li>Very strong Microsoft / Amazon LLD question</li> </ul> </li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/","title":"\ud83c\udfc6 Design a Leaderboard for Fantasy Teams","text":""},{"location":"machine-coding/fantasy-leaderboard/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory leaderboard for a fantasy sports application.</p> <ul> <li>Each user creates exactly one team</li> <li>A team consists of one or more players</li> <li>Players gain or lose points during a live match</li> <li>A user\u2019s score is the sum of scores of all players in their team</li> <li>The system must support Top-K leaderboard queries</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#rules-constraints","title":"\ud83d\udccc Rules &amp; Constraints","text":"<ul> <li>Each user has exactly one team</li> <li>A player can belong to multiple users\u2019 teams</li> <li>Initial user score is 0</li> <li>Player score updates are deltas (positive or negative)</li> <li> <p>Leaderboard sorting:</p> <ol> <li>Total score (descending)</li> <li>UserId (lexicographically ascending)</li> </ol> </li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#key-design-insight","title":"\ud83e\udde0 Key Design Insight","text":"<p>This is a many-to-many relationship:</p> <ul> <li>One player \u2192 many users</li> <li>One user \u2192 many players</li> </ul> <p>Whenever a player\u2019s score changes, all dependent users must be updated immediately.</p> <p>This naturally fits the Observer Design Pattern.</p>"},{"location":"machine-coding/fantasy-leaderboard/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/fantasy-leaderboard/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/fantasy-leaderboard/#1-player","title":"1\ufe0f\u20e3 Player","text":"<ul> <li>Maintains current score</li> <li>Knows which users depend on it</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#2-user","title":"2\ufe0f\u20e3 User","text":"<ul> <li>Represents a fantasy team</li> <li>Observes players</li> <li>Maintains total team score</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#3-leaderboard","title":"3\ufe0f\u20e3 Leaderboard","text":"<ul> <li>Maintains sorted users</li> <li>Supports Top-K queries efficiently</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":""},{"location":"machine-coding/fantasy-leaderboard/#observer-pattern","title":"\u2705 Observer Pattern","text":"<ul> <li><code>Player</code> = Subject</li> <li><code>User</code> = Observer</li> <li>Player score updates notify all users automatically</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#sorted-set-treeset","title":"\u2705 Sorted Set (TreeSet)","text":"<ul> <li>Keeps leaderboard always sorted</li> <li>Ensures fast Top-K retrieval</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#data-structures-used","title":"\ud83e\uddf1 Data Structures Used","text":"Structure Purpose <code>Map&lt;String, Player&gt;</code> Player registry <code>Map&lt;String, User&gt;</code> User registry <code>TreeSet&lt;User&gt;</code> Sorted leaderboard <code>List&lt;PlayerObserver&gt;</code> Observers per player"},{"location":"machine-coding/fantasy-leaderboard/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":""},{"location":"machine-coding/fantasy-leaderboard/#player","title":"Player","text":"<pre><code>class Player {\n    String playerId;\n    int score = 0;\n    List&lt;PlayerObserver&gt; observers = new ArrayList&lt;&gt;();\n\n    Player(String playerId) {\n        this.playerId = playerId;\n    }\n\n    void addObserver(PlayerObserver observer) {\n        observers.add(observer);\n    }\n\n    void addScore(int delta) {\n        score += delta;\n        notifyObservers(delta);\n    }\n\n    private void notifyObservers(int delta) {\n        for (PlayerObserver obs : observers) {\n            obs.onPlayerScoreChanged(delta);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#playerobserver-interface","title":"PlayerObserver Interface","text":"<pre><code>interface PlayerObserver {\n    void onPlayerScoreChanged(int delta);\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#user","title":"User","text":"<pre><code>class User implements PlayerObserver {\n    String userId;\n    int totalScore = 0;\n\n    User(String userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public void onPlayerScoreChanged(int delta) {\n        totalScore += delta;\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#leaderboard","title":"Leaderboard","text":"<pre><code>import java.util.*;\n\npublic class Leaderboard {\n\n    private Map&lt;String, Player&gt; players = new HashMap&lt;&gt;();\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    private TreeSet&lt;User&gt; leaderboard;\n\n    public Leaderboard() {\n        leaderboard = new TreeSet&lt;&gt;((a, b) -&gt; {\n            if (a.totalScore != b.totalScore) {\n                return b.totalScore - a.totalScore; // score DESC\n            }\n            return a.userId.compareTo(b.userId); // tie-break\n        });\n    }\n\n    // ---------------- addUser ----------------\n    public void addUser(String userId, List&lt;String&gt; playerIds) {\n\n        User user = new User(userId);\n        users.put(userId, user);\n\n        for (String pid : playerIds) {\n            Player p = players.computeIfAbsent(pid, k -&gt; new Player(pid));\n            p.addObserver(user);\n            user.totalScore += p.score; // reflect existing score\n        }\n\n        leaderboard.add(user);\n    }\n\n    // ---------------- addScore ----------------\n    public void addScore(String playerId, int delta) {\n\n        Player p = players.computeIfAbsent(playerId, k -&gt; new Player(playerId));\n\n        // Remove affected users before update\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.remove((User) obs);\n        }\n\n        p.addScore(delta); // notify observers\n\n        // Reinsert updated users\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.add((User) obs);\n        }\n    }\n\n    // ---------------- getTopK ----------------\n    public List&lt;String&gt; getTopK(int k) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        int count = 0;\n\n        for (User u : leaderboard) {\n            result.add(u.userId);\n            count++;\n            if (count == k) break;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>addUser(\"uA\", [\"p1\", \"p2\"])\naddUser(\"uB\", [\"p2\"])\n\ngetTopK(2)\n\u2192 [\"uA\", \"uB\"]\n\naddScore(\"p2\", 10)\n\u2192 uA = 10, uB = 10\n\naddScore(\"p1\", 3)\n\u2192 uA = 13, uB = 10\n\ngetTopK(1)\n\u2192 [\"uA\"]\n\naddScore(\"p2\", -5)\n\u2192 uA = 8, uB = 5\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Player score updates before user registration</li> <li>Negative score deltas</li> <li>Tie-breaking using lexicographical order</li> <li><code>k</code> greater than number of users</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addUser O(p log n) addScore O(u log n) getTopK O(k) Memory O(users + players + edges) <p>Where:</p> <ul> <li><code>p</code> = players per team</li> <li><code>u</code> = users observing a player</li> <li><code>n</code> = total users</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#why-this-solution-is-strong","title":"\u2705 Why This Solution Is Strong","text":"<p>\u2714 Clean separation of concerns \u2714 Real-time leaderboard consistency \u2714 Efficient Top-K queries \u2714 Observer pattern fits domain perfectly \u2714 Interview-grade design clarity</p>"},{"location":"machine-coding/file-system-cd-wildcard/","title":"\ud83d\uddc2\ufe0f Design a File System (cd with <code>*</code> Wildcard)","text":""},{"location":"machine-coding/file-system-cd-wildcard/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design and implement an in-memory Unix filesystem shell that supports the following commands:</p> <ul> <li><code>mkdir &lt;path&gt;</code></li> <li><code>pwd</code></li> <li><code>cd &lt;path&gt;</code> (supports wildcard <code>*</code>)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#environment-rules","title":"Environment &amp; Rules","text":"<ul> <li>System starts at root directory <code>/</code></li> <li> <p>Paths can be:</p> <ul> <li>Absolute (start with <code>/</code>)</li> <li>Relative (start from current directory)</li> <li>Path separator is <code>/</code></li> <li>Multiple consecutive <code>/</code> are treated as one</li> <li>Filesystem exists only in memory</li> </ul> </li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#supported-path-segments","title":"\ud83d\udcc2 Supported Path Segments","text":"Segment Meaning <code>.</code> Current directory <code>..</code> Parent directory (root\u2019s parent is root itself) <code>*</code> Wildcard matching exactly one segment"},{"location":"machine-coding/file-system-cd-wildcard/#wildcard-resolution-rules","title":"\ud83e\udde0 Wildcard (<code>*</code>) Resolution Rules","text":"<p>When <code>*</code> is encountered during <code>cd</code> traversal:</p> <ol> <li>Prefer child directories</li> <li>If multiple children exist \u2192 pick lexicographically smallest</li> <li>If no child directories exist \u2192 fallback to <code>.</code></li> <li>If still applicable \u2192 fallback to <code>..</code></li> </ol> <p>This ensures:</p> <ul> <li>Deterministic behavior</li> <li>No ambiguity</li> <li>No branching paths</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/file-system-cd-wildcard/#core-abstractions","title":"Core Abstractions","text":""},{"location":"machine-coding/file-system-cd-wildcard/#1-filesystemnode-abstract","title":"1. FileSystemNode (Abstract)","text":"<ul> <li>Common base for files and directories</li> <li>Stores name and parent reference</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#2-directorynode","title":"2. DirectoryNode","text":"<ul> <li>Contains child nodes</li> <li>Uses <code>TreeMap</code> to maintain lexicographic order</li> <li>Supports wildcard resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#3-filenode","title":"3. FileNode","text":"<ul> <li>Placeholder (not used heavily but keeps design extensible)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>DirectoryNode\n \u251c\u2500\u2500 name\n \u251c\u2500\u2500 parent\n \u2514\u2500\u2500 TreeMap&lt;String, FileSystemNode&gt; children\n</code></pre> <ul> <li><code>TreeMap</code> ensures sorted traversal</li> <li>Parent pointers allow fast <code>pwd</code> and <code>..</code> resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class FileSystemShell {\n\n    abstract class FileSystemNode {\n        String name;\n        DirectoryNode parent;\n\n        FileSystemNode(String name, DirectoryNode parent) {\n            this.name = name;\n            this.parent = parent;\n        }\n\n        abstract boolean isDirectory();\n    }\n\n    class FileNode extends FileSystemNode {\n        FileNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return false;\n        }\n    }\n\n    class DirectoryNode extends FileSystemNode {\n        TreeMap&lt;String, FileSystemNode&gt; children = new TreeMap&lt;&gt;();\n\n        DirectoryNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return true;\n        }\n\n        FileSystemNode getChild(String name) {\n            return children.get(name);\n        }\n\n        void addChild(FileSystemNode node) {\n            children.putIfAbsent(node.name, node);\n        }\n\n        DirectoryNode smallestChildDir() {\n            for (FileSystemNode node : children.values()) {\n                if (node.isDirectory()) {\n                    return (DirectoryNode) node;\n                }\n            }\n            return null;\n        }\n    }\n\n    private final DirectoryNode root = new DirectoryNode(\"/\", null);\n    private DirectoryNode cwd = root;\n\n    public FileSystemShell() {}\n\n    // ================= pwd =================\n    public String pwd() {\n        if (cwd == root) return \"/\";\n        LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();\n        FileSystemNode cur = cwd;\n\n        while (cur != root) {\n            path.addFirst(cur.name);\n            cur = cur.parent;\n        }\n        return \"/\" + String.join(\"/\", path);\n    }\n\n    // ================= mkdir =================\n    public void mkdir(String path) {\n        DirectoryNode cur = path.startsWith(\"/\") ? root : cwd;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n                continue;\n            }\n\n            FileSystemNode child = cur.getChild(seg);\n            if (child == null) {\n                DirectoryNode newDir = new DirectoryNode(seg, cur);\n                cur.addChild(newDir);\n                cur = newDir;\n            } else if (child.isDirectory()) {\n                cur = (DirectoryNode) child;\n            } else {\n                return; // cannot mkdir inside file\n            }\n        }\n    }\n\n    // ================= cd =================\n    public void cd(String path) {\n        DirectoryNode start = path.startsWith(\"/\") ? root : cwd;\n        DirectoryNode cur = start;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n            }\n            else if (seg.equals(\"*\")) {\n                DirectoryNode next = cur.smallestChildDir();\n                if (next != null) cur = next;\n            }\n            else {\n                FileSystemNode node = cur.getChild(seg);\n                if (node == null || !node.isDirectory()) return;\n                cur = (DirectoryNode) node;\n            }\n        }\n        cwd = cur;\n    }\n}\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>CWD: /\npwd \u2192 /\n\nmkdir /a/b/c\npwd \u2192 /\n\ncd a/b\npwd \u2192 /a/b\n\ncd *\n\u2192 moves to /a/b/c\n\ncd ../*\n\u2192 resolves back to /a/b/c\n\ncd /*\n\u2192 resolves to /a (lexicographically smallest child of /)\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#failure-case-handling","title":"\u26a0\ufe0f Failure Case Handling","text":"<ul> <li><code>cd /nope/*/x</code> \u2192 fails</li> <li>Current directory remains unchanged</li> <li>No partial traversal applied</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity pwd O(depth) mkdir O(depth) cd O(depth \u00d7 log(children)) Memory O(total directories)"},{"location":"machine-coding/file-system-cd-wildcard/#why-this-design-works","title":"\ud83c\udfc6 Why This Design Works","text":"<p>\u2714 Deterministic wildcard resolution \u2714 Proper Unix semantics \u2714 Safe failure handling \u2714 Clean object-oriented design \u2714 Interview-grade clarity</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/","title":"\u2728 Refactoring Text Editor to Flyweight Pattern","text":""},{"location":"machine-coding/flyweight-pattren-text-edit/#goal","title":"\ud83c\udfaf Goal","text":"<p>Reduce memory usage by sharing character style objects instead of duplicating them for every character.</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#before-problem-in-existing-design","title":"\ud83d\udd34 BEFORE (Problem in Existing Design)","text":"<pre><code>class StyledChar {\n    char ch;\n    String fontName;\n    int fontSize;\n    boolean isBold;\n    boolean isItalic;\n}\n</code></pre> <p>\u274c Issue:</p> <ul> <li>Every character stores full style info</li> <li>Large document \u21d2 huge memory waste</li> <li>Same styles repeated thousands of times</li> </ul>"},{"location":"machine-coding/flyweight-pattren-text-edit/#after-flyweight-design","title":"\u2705 AFTER (Flyweight Design)","text":"<p>We split style (intrinsic, shared) from character data (extrinsic).</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-1-create-flyweight-textstyle","title":"\ud83e\uddf1 Step 1: Create Flyweight (<code>TextStyle</code>)","text":"<pre><code>class TextStyle {\n    final String fontName;\n    final int fontSize;\n    final boolean isBold;\n    final boolean isItalic;\n\n    TextStyle(String fontName, int fontSize, boolean isBold, boolean isItalic) {\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof TextStyle)) return false;\n        TextStyle that = (TextStyle) o;\n        return fontSize == that.fontSize &amp;&amp;\n               isBold == that.isBold &amp;&amp;\n               isItalic == that.isItalic &amp;&amp;\n               fontName.equals(that.fontName);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(fontName, fontSize, isBold, isItalic);\n    }\n}\n</code></pre> <p>\u2705 This is the Flyweight object \u2705 Must override <code>equals()</code> &amp; <code>hashCode()</code> \u2705 Immutable \u2192 safe to share</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-2-flyweight-factory","title":"\ud83c\udfed Step 2: Flyweight Factory","text":"<pre><code>class TextStyleFactory {\n\n    private static final Map&lt;TextStyle, TextStyle&gt; cache = new HashMap&lt;&gt;();\n\n    public static TextStyle getStyle(\n            String fontName,\n            int fontSize,\n            boolean isBold,\n            boolean isItalic) {\n\n        TextStyle key = new TextStyle(fontName, fontSize, isBold, isItalic);\n        cache.putIfAbsent(key, key);\n        return cache.get(key);\n    }\n}\n</code></pre> <p>\u2714 Ensures only one object per unique style \u2714 Centralized style reuse</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-3-character-holds-only-whats-unique","title":"\u270d\ufe0f Step 3: Character Holds Only What\u2019s Unique","text":"<pre><code>class StyledChar {\n    char ch;              // extrinsic\n    TextStyle style;      // intrinsic (shared)\n\n    StyledChar(char ch, TextStyle style) {\n        this.ch = ch;\n        this.style = style;\n    }\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-4-document-storage-rows","title":"\ud83d\udcc4 Step 4: Document Storage (Rows)","text":"<pre><code>List&lt;List&lt;StyledChar&gt;&gt; rows = new ArrayList&lt;&gt;();\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#refactored-addcharacter-flyweight-enabled","title":"\u270f\ufe0f Refactored <code>addCharacter()</code> (Flyweight Enabled)","text":"<pre><code>public void addCharacter(\n        int row, int column, char ch,\n        String fontName, int fontSize,\n        boolean isBold, boolean isItalic) {\n\n    while (rows.size() &lt;= row) {\n        rows.add(new ArrayList&lt;&gt;());\n    }\n\n    List&lt;StyledChar&gt; line = rows.get(row);\n\n    TextStyle style = TextStyleFactory.getStyle(\n            fontName, fontSize, isBold, isItalic);\n\n    StyledChar newChar = new StyledChar(ch, style);\n\n    if (column &gt;= line.size()) {\n        line.add(newChar);\n    } else {\n        line.add(column, newChar);\n    }\n}\n</code></pre> <p>\ud83d\udca1 Key improvement: Style objects are shared automatically.</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#refactored-getstyle","title":"\ud83c\udfa8 Refactored <code>getStyle()</code>","text":"<pre><code>public String getStyle(int row, int col) {\n    if (row &gt;= rows.size() || col &gt;= rows.get(row).size()) {\n        return \"\";\n    }\n\n    StyledChar sc = rows.get(row).get(col);\n    TextStyle s = sc.style;\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(sc.ch).append(\"-\")\n      .append(s.fontName).append(\"-\")\n      .append(s.fontSize);\n\n    if (s.isBold) sb.append(\"-b\");\n    if (s.isItalic) sb.append(\"-i\");\n\n    return sb.toString();\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#readline-unchanged","title":"\ud83d\udcd6 <code>readLine()</code> (Unchanged)","text":"<pre><code>public String readLine(int row) {\n    if (row &gt;= rows.size()) return \"\";\n\n    StringBuilder sb = new StringBuilder();\n    for (StyledChar sc : rows.get(row)) {\n        sb.append(sc.ch);\n    }\n    return sb.toString();\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#deletecharacter-unchanged","title":"\ud83d\uddd1\ufe0f <code>deleteCharacter()</code> (Unchanged)","text":"<pre><code>public boolean deleteCharacter(int row, int col) {\n    if (row &gt;= rows.size() || col &gt;= rows.get(row).size()) {\n        return false;\n    }\n    rows.get(row).remove(col);\n    return true;\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#memory-impact-why-this-matters","title":"\ud83d\udcca Memory Impact (Why This Matters)","text":"Scenario Without Flyweight With Flyweight 1M chars, same style 1M style objects 1 style object Real editor \u274c Heavy \u2705 Efficient Interview quality \u274c Average \ud83d\udd25 Strong"},{"location":"machine-coding/flyweight-pattren-text-edit/#interview-explanation-say-this","title":"\ud83e\udde0 Interview Explanation (Say This)","text":"<p>\u201cI used the Flyweight pattern to deduplicate text formatting objects. Each character stores only a reference to a shared <code>TextStyle</code>, drastically reducing memory usage for large documents.\u201d</p> <p>This line alone wins brownie points.</p>"},{"location":"machine-coding/google-search-autocomplete/","title":"10642. Design Google Search Autocomplete","text":""},{"location":"machine-coding/google-search-autocomplete/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an autocomplete system similar to Google Search.</p> <p>As the user types characters one by one, the system should return top 3 historical search sentences that start with the current prefix.</p> <p>When the user types <code>#</code>, the current input is considered complete and should be stored as a new historical sentence.</p>"},{"location":"machine-coding/google-search-autocomplete/#autocomplete-rules","title":"\ud83d\udd0d Autocomplete Rules","text":"<ul> <li>Popularity = number of times a sentence was previously entered</li> <li> <p>Suggestions are sorted by:</p> <ol> <li>Highest frequency first</li> <li>ASCII order (lexicographically ascending) if frequencies tie</li> <li>Return at most 3 sentences</li> <li>If fewer than 3 matches exist, return all</li> <li> <p>When <code>#</code> is typed:</p> </li> <li> <p>Save the current sentence with frequency <code>+1</code></p> </li> <li>Reset input</li> <li>Return empty list</li> </ol> </li> </ul>"},{"location":"machine-coding/google-search-autocomplete/#design-approach","title":"\ud83e\udde0 Design Approach","text":""},{"location":"machine-coding/google-search-autocomplete/#why-trie","title":"Why Trie?","text":"<ul> <li>Efficient prefix search</li> <li>Naturally supports incremental character input</li> <li>Each prefix node maintains frequency info for all sentences passing through it</li> </ul>"},{"location":"machine-coding/google-search-autocomplete/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"Structure Purpose Trie Prefix matching HashMap Store sentence \u2192 frequency PriorityQueue Extract top-3 suggestions StringBuilder Track current user input"},{"location":"machine-coding/google-search-autocomplete/#class-design","title":"\ud83c\udfd7\ufe0f Class Design","text":"<pre><code>SearchAutocomplete\n \u251c\u2500\u2500 TrieNode\n \u2502    \u251c\u2500\u2500 children : Map&lt;Character, TrieNode&gt;\n \u2502    \u2514\u2500\u2500 sentenceCount : Map&lt;String, Integer&gt;\n \u251c\u2500\u2500 root : TrieNode\n \u251c\u2500\u2500 currentNode : TrieNode\n \u2514\u2500\u2500 currentInput : StringBuilder\n</code></pre>"},{"location":"machine-coding/google-search-autocomplete/#example","title":"\ud83e\uddea Example","text":"<pre><code>SearchAutocomplete autocomplete =\n    new SearchAutocomplete(\n        new String[]{\"hello world\", \"hi there\", \"hello\", \"hi world\"},\n        new int[]{4, 3, 2, 2}\n    );\n\nautocomplete.getSuggestions('h');\n// [\"hello world\", \"hi there\", \"hello\"]\n\nautocomplete.getSuggestions('i');\n// [\"hi there\", \"hi world\"]\n\nautocomplete.getSuggestions(' ');\n// []\n\nautocomplete.getSuggestions('#');\n// []\n</code></pre>"},{"location":"machine-coding/google-search-autocomplete/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SearchAutocomplete {\n\n    // ================= Trie Node =================\n    private static class TrieNode {\n        Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();\n        Map&lt;String, Integer&gt; sentenceCount = new HashMap&lt;&gt;();\n    }\n\n    private final TrieNode root = new TrieNode();\n    private TrieNode currentNode = root;\n    private final StringBuilder currentInput = new StringBuilder();\n\n    public SearchAutocomplete(String[] sentences, int[] times) {\n        for (int i = 0; i &lt; sentences.length; i++) {\n            insert(sentences[i], times[i]);\n        }\n    }\n\n    // Insert sentence into Trie\n    private void insert(String sentence, int count) {\n        TrieNode node = root;\n        for (char c : sentence.toCharArray()) {\n            node = node.children.computeIfAbsent(c, k -&gt; new TrieNode());\n            node.sentenceCount.put(\n                sentence,\n                node.sentenceCount.getOrDefault(sentence, 0) + count\n            );\n        }\n    }\n\n    // Process one character input\n    public List&lt;String&gt; getSuggestions(char ch) {\n\n        // End of sentence\n        if (ch == '#') {\n            String sentence = currentInput.toString();\n            insert(sentence, 1);\n\n            // reset state\n            currentInput.setLength(0);\n            currentNode = root;\n            return Collections.emptyList();\n        }\n\n        currentInput.append(ch);\n\n        if (currentNode != null) {\n            currentNode = currentNode.children.get(ch);\n        }\n\n        if (currentNode == null) {\n            return Collections.emptyList();\n        }\n\n        return getTop3(currentNode.sentenceCount);\n    }\n\n    // Get top 3 sentences by frequency + lex order\n    private List&lt;String&gt; getTop3(Map&lt;String, Integer&gt; map) {\n\n        PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(\n            (a, b) -&gt; {\n                int freq = map.get(b) - map.get(a);\n                if (freq != 0) return freq;\n                return a.compareTo(b);\n            }\n        );\n\n        pq.addAll(map.keySet());\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 3 &amp;&amp; !pq.isEmpty(); i++) {\n            result.add(pq.poll());\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/google-search-autocomplete/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity Insert sentence <code>O(L)</code> getSuggestions <code>O(K log K)</code> (K = candidates at prefix) Space <code>O(total characters in sentences)</code>"},{"location":"machine-coding/google-search-autocomplete/#design-patterns-used","title":"\ud83e\udde0 Design Patterns Used","text":"<ul> <li>Trie (Prefix Tree)</li> <li>Heap (Priority Queue)</li> <li>Incremental State Machine (character-by-character input)</li> </ul>"},{"location":"machine-coding/google-search-autocomplete/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>Very common Google / Meta / Amazon autocomplete problem</li> <li> <p>Follow-ups often include:</p> <ul> <li>Limit memory per node</li> <li>Distributed autocomplete</li> <li>Real-time trending queries</li> <li>Thread-safe version</li> </ul> </li> </ul>"},{"location":"machine-coding/in-memory-database/","title":"Design a Complete In-Memory Database","text":""},{"location":"machine-coding/in-memory-database/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory database that stores records identified by a <code>key</code>. Each record contains multiple fields, and each field stores a value.</p> <p>The system evolves across 4 levels:</p>"},{"location":"machine-coding/in-memory-database/#levels-breakdown","title":"\ud83e\udde9 Levels Breakdown","text":""},{"location":"machine-coding/in-memory-database/#level-1-basic-operations","title":"\u2705 Level 1 \u2013 Basic Operations","text":"<ul> <li>Set values</li> <li>Conditional updates</li> <li>Conditional deletes</li> <li>Get values</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-2-scanning-filtering","title":"\u2705 Level 2 \u2013 Scanning &amp; Filtering","text":"<ul> <li>Scan all fields for a key</li> <li>Scan fields by prefix</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-3-ttl-time-to-live","title":"\u2705 Level 3 \u2013 TTL (Time-To-Live)","text":"<ul> <li>Fields can expire after a given TTL</li> <li>Expired fields are invisible</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-4-look-back-queries","title":"\u2705 Level 4 \u2013 Look-Back Queries","text":"<ul> <li>Retrieve field values as of a given timestamp</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/in-memory-database/#key-ideas","title":"Key Ideas","text":"<ul> <li>Multi-version storage per field</li> <li>Timestamp-aware writes</li> <li>Lazy expiration using TTL</li> <li>Sorted history for look-back</li> </ul>"},{"location":"machine-coding/in-memory-database/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":""},{"location":"machine-coding/in-memory-database/#versionedvalue","title":"VersionedValue","text":"<p>Stores historical versions of a field.</p> <pre><code>class VersionedValue {\n    int timestamp;\n    String value;\n    Integer expiryTime; // null means no TTL\n\n    VersionedValue(int timestamp, String value, Integer expiryTime) {\n        this.timestamp = timestamp;\n        this.value = value;\n        this.expiryTime = expiryTime;\n    }\n\n    boolean isExpired(int currentTime) {\n        return expiryTime != null &amp;&amp; currentTime &gt;= expiryTime;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#database-structure","title":"Database Structure","text":"<pre><code>Map&lt;key,\n  Map&lt;\n    field,\n    List&lt;VersionedValue&gt;\n  &gt;\n&gt;\n</code></pre>"},{"location":"machine-coding/in-memory-database/#full-java-implementation-all-levels","title":"\ud83d\udcbb Full Java Implementation (All Levels)","text":"<pre><code>import java.util.*;\n\npublic class InMemoryDatabase {\n\n    private Map&lt;String, Map&lt;String, List&lt;VersionedValue&gt;&gt;&gt; db = new HashMap&lt;&gt;();\n\n    // ---------- LEVEL 1 ----------\n\n    public void set(int timestamp, String key, String field, String value) {\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, null));\n    }\n\n    public boolean compareAndSet(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        set(timestamp, key, field, curr);\n        return true;\n    }\n\n    public boolean compareAndDelete(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        db.get(key).get(field)\n          .add(new VersionedValue(timestamp, null, null));\n        return true;\n    }\n\n    public String get(int timestamp, String key, String field) {\n        if (!db.containsKey(key) || !db.get(key).containsKey(field)) {\n            return null;\n        }\n        return getLatestValue(db.get(key).get(field), timestamp);\n    }\n\n    // ---------- LEVEL 2 ----------\n\n    public List&lt;String&gt; scan(int timestamp, String key) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    public List&lt;String&gt; scanByPrefix(int timestamp, String key, String prefix) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            if (!field.startsWith(prefix)) continue;\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    // ---------- LEVEL 3 ----------\n\n    public void setWithTTL(int timestamp, String key, String field, String value, int ttl) {\n        int expiry = timestamp + ttl;\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, expiry));\n    }\n\n    public boolean compareAndSetWithTTL(int timestamp, String key, String field,\n                                        int expectedValue, int newValue, int ttl) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        setWithTTL(timestamp, key, field, String.valueOf(newValue), ttl);\n        return true;\n    }\n\n    // ---------- HELPERS ----------\n\n    private String getLatestValue(List&lt;VersionedValue&gt; history, int timestamp) {\n        String result = null;\n        for (VersionedValue vv : history) {\n            if (vv.timestamp &gt; timestamp) break;\n            if (vv.isExpired(timestamp)) continue;\n            result = vv.value;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Field deletion using tombstones</li> <li>Expired values hidden automatically</li> <li>Prefix scans skip expired fields</li> <li>Look-back reads ignore future writes</li> <li>Multiple updates to same field</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Multi-Version Concurrency Control (MVCC)</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> <li>Lazy Expiration</li> <li>Time-based Snapshot Reads</li> </ul>"},{"location":"machine-coding/in-memory-database/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity set / get O(V) scan O(F \u00d7 V) scanByPrefix O(F \u00d7 V) TTL operations O(1) Look-back O(V) <p>F = fields per key, V = versions per field</p>"},{"location":"machine-coding/in-memory-database/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<p>Why versioned values instead of overwriting?</p> <p>Enables:</p> <ul> <li>Look-back queries</li> <li>Safe TTL handling</li> <li>Historical correctness</li> </ul> <p>Why lazy TTL cleanup?</p> <p>Avoids background threads and keeps implementation deterministic.</p>"},{"location":"machine-coding/in-memory-database/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Background compaction</li> <li>Range queries</li> <li>Indexing for prefix scans</li> <li>Persistent WAL</li> <li>Concurrent access handling</li> </ul> <p>```</p>"},{"location":"machine-coding/job-scheduler/","title":"\u2699\ufe0f Design a Job Scheduler","text":""},{"location":"machine-coding/job-scheduler/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a Job Scheduler for a massively parallel distributed system.</p> <ul> <li>The scheduler manages multiple machines</li> <li>Each machine has a set of capabilities</li> <li>Each job requires a set of capabilities</li> <li>A job can only be assigned to a machine that has all required capabilities</li> </ul>"},{"location":"machine-coding/job-scheduler/#core-requirements","title":"\ud83e\udde0 Core Requirements","text":""},{"location":"machine-coding/job-scheduler/#machine","title":"Machine","text":"<ul> <li>Has a unique <code>machineId</code></li> <li>Has a set of capabilities (case-insensitive)</li> <li> <p>Tracks:</p> <ul> <li><code>unfinishedJobs</code></li> <li><code>finishedJobs</code></li> </ul> </li> </ul>"},{"location":"machine-coding/job-scheduler/#job","title":"Job","text":"<ul> <li>Has a unique <code>jobId</code></li> <li>Assigned to exactly one machine</li> <li>Can be marked completed</li> </ul>"},{"location":"machine-coding/job-scheduler/#assignment-criteria-extensible","title":"\ud83d\udd00 Assignment Criteria (Extensible)","text":"<p>When multiple machines qualify, select based on criteria:</p> Criteria Description <code>0</code> Machine with least unfinished jobs <code>1</code> Machine with most finished jobs Tie Lexicographically smallest <code>machineId</code> <p>\u26a0\ufe0f Extensibility requirement: Adding a new scheduling algorithm should not change existing logic.</p>"},{"location":"machine-coding/job-scheduler/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/job-scheduler/#key-design-patterns-used","title":"Key Design Patterns Used","text":"Pattern Why Strategy Pattern Plug-and-play job selection algorithms Encapsulation Machine manages its own counters Open/Closed Principle Add new criteria without touching scheduler logic"},{"location":"machine-coding/job-scheduler/#high-level-architecture","title":"\ud83e\udde9 High-Level Architecture","text":"<pre><code>JobScheduler\n \u251c\u2500\u2500 machines: Map&lt;String, Machine&gt;\n \u251c\u2500\u2500 jobs: Map&lt;String, Job&gt;\n \u251c\u2500\u2500 strategies: Map&lt;Integer, AssignmentStrategy&gt;\n\nMachine\n \u251c\u2500\u2500 machineId\n \u251c\u2500\u2500 capabilities (Set&lt;String&gt;)\n \u251c\u2500\u2500 unfinishedJobs\n \u251c\u2500\u2500 finishedJobs\n\nAssignmentStrategy (interface)\n \u251c\u2500\u2500 selectMachine(...)\n</code></pre>"},{"location":"machine-coding/job-scheduler/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":""},{"location":"machine-coding/job-scheduler/#assignment-strategy-interface","title":"Assignment Strategy Interface","text":"<pre><code>interface AssignmentStrategy {\n    Machine select(List&lt;Machine&gt; candidates);\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#strategy-0-least-unfinished-jobs","title":"Strategy 0: Least Unfinished Jobs","text":"<pre><code>class LeastUnfinishedStrategy implements AssignmentStrategy {\n\n    @Override\n    public Machine select(List&lt;Machine&gt; machines) {\n        machines.sort((a, b) -&gt; {\n            if (a.unfinishedJobs != b.unfinishedJobs) {\n                return a.unfinishedJobs - b.unfinishedJobs;\n            }\n            return a.machineId.compareTo(b.machineId);\n        });\n        return machines.get(0);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#strategy-1-most-finished-jobs","title":"Strategy 1: Most Finished Jobs","text":"<pre><code>class MostFinishedStrategy implements AssignmentStrategy {\n\n    @Override\n    public Machine select(List&lt;Machine&gt; machines) {\n        machines.sort((a, b) -&gt; {\n            if (a.finishedJobs != b.finishedJobs) {\n                return b.finishedJobs - a.finishedJobs;\n            }\n            return a.machineId.compareTo(b.machineId);\n        });\n        return machines.get(0);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#machine_1","title":"Machine","text":"<pre><code>class Machine {\n    String machineId;\n    Set&lt;String&gt; capabilities;\n    int unfinishedJobs = 0;\n    int finishedJobs = 0;\n\n    Machine(String machineId, Set&lt;String&gt; capabilities) {\n        this.machineId = machineId;\n        this.capabilities = capabilities;\n    }\n\n    boolean supports(Set&lt;String&gt; required) {\n        return capabilities.containsAll(required);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#job_1","title":"Job","text":"<pre><code>class Job {\n    String jobId;\n    Machine machine;\n\n    Job(String jobId, Machine machine) {\n        this.jobId = jobId;\n        this.machine = machine;\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#job-scheduler-main-class","title":"Job Scheduler (Main Class)","text":"<pre><code>import java.util.*;\n\npublic class JobScheduler {\n\n    private Map&lt;String, Machine&gt; machines = new HashMap&lt;&gt;();\n    private Map&lt;String, Job&gt; jobs = new HashMap&lt;&gt;();\n    private Map&lt;Integer, AssignmentStrategy&gt; strategies = new HashMap&lt;&gt;();\n\n    public JobScheduler() {\n        strategies.put(0, new LeastUnfinishedStrategy());\n        strategies.put(1, new MostFinishedStrategy());\n    }\n\n    // ---------------- addMachine ----------------\n    public void addMachine(String machineId, String[] capabilities) {\n        Set&lt;String&gt; caps = new HashSet&lt;&gt;();\n        for (String cap : capabilities) {\n            caps.add(cap.toLowerCase());\n        }\n        machines.put(machineId, new Machine(machineId, caps));\n    }\n\n    // ---------------- assignMachineToJob ----------------\n    public String assignMachineToJob(String jobId, String[] requiredCaps, int criteria) {\n\n        Set&lt;String&gt; required = new HashSet&lt;&gt;();\n        for (String r : requiredCaps) {\n            required.add(r.toLowerCase());\n        }\n\n        List&lt;Machine&gt; candidates = new ArrayList&lt;&gt;();\n        for (Machine m : machines.values()) {\n            if (m.supports(required)) {\n                candidates.add(m);\n            }\n        }\n\n        if (candidates.isEmpty()) return \"\";\n\n        AssignmentStrategy strategy = strategies.get(criteria);\n        Machine selected = strategy.select(candidates);\n\n        selected.unfinishedJobs++;\n        jobs.put(jobId, new Job(jobId, selected));\n\n        return selected.machineId;\n    }\n\n    // ---------------- jobCompleted ----------------\n    public void jobCompleted(String jobId) {\n        Job job = jobs.get(jobId);\n        Machine m = job.machine;\n\n        m.unfinishedJobs--;\n        m.finishedJobs++;\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>addMachine(\"m-10\", [\"image compression\", \"audio extraction\"])\naddMachine(\"m-2\", [\"image compression\"])\n\nassignMachineToJob(\"job-A\", [\"image compression\"], 0)\n\u2192 \"m-10\" (tie \u2192 lexicographically smaller)\n\njobCompleted(\"job-A\")\n\nassignMachineToJob(\"job-B\", [\"image compression\"], 1)\n\u2192 \"m-10\" (most finished jobs)\n</code></pre>"},{"location":"machine-coding/job-scheduler/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Case-insensitive capabilities</li> <li>No compatible machines \u2192 return <code>\"\"</code></li> <li>Deterministic tie-breaking</li> <li>Multiple jobs per machine</li> <li>Strategy extensibility without refactoring</li> </ul>"},{"location":"machine-coding/job-scheduler/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity addMachine O(c) assignMachineToJob O(m log m) jobCompleted O(1) Space O(m + j + c) <p>Where:</p> <ul> <li><code>m</code> = machines</li> <li><code>j</code> = jobs</li> <li><code>c</code> = capabilities</li> </ul>"},{"location":"machine-coding/job-scheduler/#why-this-design-is-interview-strong","title":"\u2705 Why This Design Is Interview-Strong","text":"<p>\u2714 Clean separation of concerns \u2714 Strategy Pattern clearly justified \u2714 Easy to extend with new criteria \u2714 Deterministic and test-safe \u2714 Scales within given constraints</p> <ul> <li>Thread-safe version</li> <li>Weighted capabilities</li> <li>Load-aware scheduling</li> <li>Job preemption</li> <li>UML diagram</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/","title":"31. Design a Leaderboard for Fantasy Teams","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Build an in-memory leaderboard for a fantasy-sports application.</p> <ul> <li>Each user creates exactly one team</li> <li>Each team contains one or more players</li> <li>Players earn positive or negative points over time</li> <li>A user\u2019s score is the sum of scores of all players in their team</li> <li>The system must support Top-K leaderboard queries</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#rules-constraints","title":"\ud83e\udde0 Rules &amp; Constraints","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#team-player-rules","title":"Team &amp; Player Rules","text":"<ul> <li>Every user has exactly one team</li> <li>A player can belong to multiple users\u2019 teams</li> <li>Each user starts with score = 0</li> <li>Player score updates are deltas (positive or negative)</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#leaderboard-ordering","title":"Leaderboard Ordering","text":"<ol> <li>User score (descending)</li> <li>User ID (lexicographically ascending) as tie-breaker</li> </ol>"},{"location":"machine-coding/leaderboard-fantasy-teams/#apis-to-implement","title":"\ud83e\udde9 APIs to Implement","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#1-adduser","title":"1\ufe0f\u20e3 addUser","text":"<pre><code>void addUser(String userId, List&lt;String&gt; playerIds)\n</code></pre> <ul> <li>Registers a new user with their team</li> <li><code>userId</code> is unique and non-blank</li> <li><code>playerIds</code> contains at least one valid player</li> <li>If players already have scores, user score should reflect them immediately</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#2-addscore","title":"2\ufe0f\u20e3 addScore","text":"<pre><code>void addScore(String playerId, int score)\n</code></pre> <ul> <li>Updates a player\u2019s cumulative score by a delta</li> <li>All users containing that player must have their scores updated</li> <li>Leaderboard ordering must stay consistent</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#3-gettopk","title":"3\ufe0f\u20e3 getTopK","text":"<pre><code>List&lt;String&gt; getTopK(int k)\n</code></pre> <ul> <li> <p>Returns top <code>k</code> users sorted by:</p> <ul> <li>Score (descending)</li> <li>User ID (ascending)</li> <li>If <code>k</code> &gt; total users \u2192 return all users</li> </ul> </li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#example-walkthrough","title":"\ud83d\udcd8 Example Walkthrough","text":"<pre><code>addUser(\"uA\", [\"p1\", \"p2\"])\naddUser(\"uB\", [\"p2\"])\n\ngetTopK(2)\n// [\"uA\", \"uB\"]  (both scores = 0)\n\naddScore(\"p2\", 10)\n// uA = 10, uB = 10\n\ngetTopK(2)\n// [\"uA\", \"uB\"]  (tie \u2192 lex order)\n\naddScore(\"p1\", 3)\n// uA = 13, uB = 10\n\ngetTopK(1)\n// [\"uA\"]\n\naddScore(\"p2\", -5)\n// uA = 8, uB = 5\n\ngetTopK(5)\n// [\"uA\", \"uB\"]\n</code></pre>"},{"location":"machine-coding/leaderboard-fantasy-teams/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#core-entities","title":"Core Entities","text":"Entity Responsibility <code>Player</code> Holds player score &amp; notifies users <code>User</code> Maintains total team score <code>Leaderboard</code> Maintains sorted ranking"},{"location":"machine-coding/leaderboard-fantasy-teams/#design-pattern-used","title":"\ud83e\udde0 Design Pattern Used","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#observer-pattern","title":"\u2705 Observer Pattern","text":"<ul> <li><code>User</code> observes <code>Player</code></li> <li> <p>When a player\u2019s score changes:</p> <ul> <li>All users owning that player are notified</li> <li>User scores update automatically</li> <li>Ensures efficient many-to-many updates</li> </ul> </li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Leaderboard {\n\n    private Map&lt;String, Player&gt; players = new HashMap&lt;&gt;();\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    private TreeSet&lt;User&gt; leaderboard;\n\n    public Leaderboard() {\n        leaderboard = new TreeSet&lt;&gt;((a, b) -&gt; {\n            if (a.totalScore != b.totalScore) {\n                return b.totalScore - a.totalScore; // score DESC\n            }\n            return a.userId.compareTo(b.userId); // lex ASC\n        });\n    }\n\n    // ---------------- addUser ----------------\n    public void addUser(String userId, List&lt;String&gt; playerIds) {\n\n        User user = new User(userId);\n        users.put(userId, user);\n\n        for (String pid : playerIds) {\n            Player p = players.computeIfAbsent(pid, k -&gt; new Player(pid));\n            p.addObserver(user);\n            user.totalScore += p.score; // reflect existing score\n        }\n\n        leaderboard.add(user);\n    }\n\n    // ---------------- addScore ----------------\n    public void addScore(String playerId, int delta) {\n\n        Player p = players.computeIfAbsent(playerId, k -&gt; new Player(playerId));\n\n        // Remove affected users before score change\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.remove((User) obs);\n        }\n\n        p.addScore(delta); // notify users\n\n        // Reinsert updated users\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.add((User) obs);\n        }\n    }\n\n    // ---------------- getTopK ----------------\n    public List&lt;String&gt; getTopK(int k) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        int count = 0;\n\n        for (User u : leaderboard) {\n            result.add(u.userId);\n            count++;\n            if (count == k) break;\n        }\n        return result;\n    }\n}\n\n// ---------- SUPPORTING CLASSES ----------\n\nclass Player {\n    String playerId;\n    int score = 0;\n    List&lt;PlayerObserver&gt; observers = new ArrayList&lt;&gt;();\n\n    Player(String playerId) {\n        this.playerId = playerId;\n    }\n\n    void addObserver(PlayerObserver observer) {\n        observers.add(observer);\n    }\n\n    void addScore(int delta) {\n        score += delta;\n        notifyObservers(delta);\n    }\n\n    private void notifyObservers(int delta) {\n        for (PlayerObserver obs : observers) {\n            obs.onPlayerScoreChanged(delta);\n        }\n    }\n}\n\ninterface PlayerObserver {\n    void onPlayerScoreChanged(int delta);\n}\n\nclass User implements PlayerObserver {\n    String userId;\n    int totalScore = 0;\n\n    User(String userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public void onPlayerScoreChanged(int delta) {\n        totalScore += delta;\n    }\n}\n</code></pre>"},{"location":"machine-coding/leaderboard-fantasy-teams/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Player added after scoring</li> <li>Negative score updates</li> <li>Tie-breaking by user ID</li> <li><code>k</code> larger than user count</li> <li>Many-to-many player-user mapping</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity addUser O(p log u) addScore O(u log u) getTopK O(k) <p>p = players per user, u = users affected</p>"},{"location":"machine-coding/leaderboard-fantasy-teams/#why-this-is-interview-ready","title":"\u2705 Why This Is Interview-Ready","text":"<ul> <li>Clean Observer pattern usage</li> <li>Deterministic ranking with <code>TreeSet</code></li> <li>Efficient updates without full recomputation</li> <li>Easily extensible (Top-N per league, snapshots, persistence)</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/","title":"Design a Meeting Room Reservation System","text":""},{"location":"machine-coding/meeting-room-reservation/#problem-statement","title":"Problem Statement","text":"<p>Design a Meeting Room Reservation System for a fixed set of conference rooms.</p> <p>The system must: - Book meetings without overlap - Cancel existing meetings - Always choose the lexicographically smallest room ID when multiple rooms are available - Treat time intervals as inclusive (<code>[startTime, endTime]</code>)</p>"},{"location":"machine-coding/meeting-room-reservation/#key-requirements","title":"Key Requirements","text":"<ul> <li>Each room can host only one meeting at a time</li> <li>Meetings overlap if times intersect inclusively</li> <li>Cancel only active meetings</li> <li>Meeting IDs are unique for active bookings</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#class-design","title":"\ud83c\udfd7\ufe0f Class Design","text":""},{"location":"machine-coding/meeting-room-reservation/#class-name","title":"Class Name","text":"<p><code>RoomBooking</code></p>"},{"location":"machine-coding/meeting-room-reservation/#constructor","title":"Constructor","text":"<pre><code>RoomBooking(List&lt;String&gt; roomIds);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#methods","title":"Methods","text":"<pre><code>String bookMeeting(String meetingId, int startTime, int endTime);\nboolean cancelMeeting(String meetingId);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#design-overview","title":"\ud83e\udde9 Design Overview","text":""},{"location":"machine-coding/meeting-room-reservation/#core-data-structures","title":"Core Data Structures","text":"Structure Purpose <code>TreeMap&lt;Integer, Integer&gt;</code> Stores intervals per room <code>Map&lt;String, Room&gt;</code> Room registry <code>Map&lt;String, Meeting&gt;</code> Active meetings lookup <code>List&lt;String&gt;</code> Sorted room IDs"},{"location":"machine-coding/meeting-room-reservation/#entity-models","title":"\ud83c\udfdb\ufe0f Entity Models","text":""},{"location":"machine-coding/meeting-room-reservation/#meeting","title":"Meeting","text":"<ul> <li>meetingId</li> <li>roomId</li> <li>startTime</li> <li>endTime</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#room","title":"Room","text":"<ul> <li>roomId</li> <li>TreeMap of booked intervals (<code>start \u2192 end</code>)</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#booking-logic","title":"\ud83d\udd0d Booking Logic","text":"<p>To check if a room is free:</p> <ol> <li>Find the closest previous interval using <code>floorEntry</code></li> <li>Find the closest next interval using <code>ceilingEntry</code></li> <li>Reject booking if either overlaps (inclusive rules)</li> </ol>"},{"location":"machine-coding/meeting-room-reservation/#design-patterns-used","title":"\ud83e\udde0 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Ordered Resource Selection</li> <li>Interval Scheduling using TreeMap</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class RoomBooking {\n\n    class Meeting {\n        String meetingId;\n        String roomId;\n        int startTime;\n        int endTime;\n\n        Meeting(String meetingId, String roomId, int startTime, int endTime) {\n            this.meetingId = meetingId;\n            this.roomId = roomId;\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    class Room {\n        String roomId;\n        TreeMap&lt;Integer, Integer&gt; intervals = new TreeMap&lt;&gt;();\n\n        Room(String roomId) {\n            this.roomId = roomId;\n        }\n    }\n\n    private Map&lt;String, Room&gt; rooms = new HashMap&lt;&gt;();\n    private Map&lt;String, Meeting&gt; meetingMap = new HashMap&lt;&gt;();\n    private List&lt;String&gt; sortedRoomIds;\n\n    public RoomBooking(List&lt;String&gt; roomIds) {\n        sortedRoomIds = new ArrayList&lt;&gt;(roomIds);\n        Collections.sort(sortedRoomIds);\n\n        for (String id : roomIds) {\n            rooms.put(id, new Room(id));\n        }\n    }\n\n    public String bookMeeting(String meetingId, int startTime, int endTime) {\n\n        if (meetingMap.containsKey(meetingId)) {\n            return \"\";\n        }\n\n        for (String roomId : sortedRoomIds) {\n            Room room = rooms.get(roomId);\n            if (isAvailable(room, startTime, endTime)) {\n                room.intervals.put(startTime, endTime);\n                Meeting meeting = new Meeting(meetingId, roomId, startTime, endTime);\n                meetingMap.put(meetingId, meeting);\n                return roomId;\n            }\n        }\n        return \"\";\n    }\n\n    private boolean isAvailable(Room room, int startTime, int endTime) {\n\n        Map.Entry&lt;Integer, Integer&gt; floor = room.intervals.floorEntry(startTime);\n        if (floor != null &amp;&amp; floor.getValue() &gt;= startTime) {\n            return false;\n        }\n\n        Map.Entry&lt;Integer, Integer&gt; ceil = room.intervals.ceilingEntry(startTime);\n        if (ceil != null &amp;&amp; ceil.getKey() &lt;= endTime) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public boolean cancelMeeting(String meetingId) {\n        Meeting meeting = meetingMap.get(meetingId);\n        if (meeting == null) {\n            return false;\n        }\n\n        Room room = rooms.get(meeting.roomId);\n        room.intervals.remove(meeting.startTime);\n        meetingMap.remove(meetingId);\n        return true;\n    }\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Inclusive overlap (<code>end == start</code> is conflict)</li> <li>Duplicate meeting IDs rejected</li> <li>Cancelling non-existent meetings</li> <li>Correct reuse of rooms after cancellation</li> <li>Lexicographically smallest room chosen</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Book Meeting <code>O(R \u00d7 log M)</code> Cancel Meeting <code>O(log M)</code> Overlap Check <code>O(log M)</code> <p>R = number of rooms M = number of meetings per room</p>"},{"location":"machine-coding/meeting-room-reservation/#example","title":"\ud83e\uddea Example","text":"<pre><code>RoomBooking rb = new RoomBooking(Arrays.asList(\"roomA\", \"roomB\"));\n\nrb.bookMeeting(\"m1\", 10, 20); // roomA\nrb.bookMeeting(\"m2\", 15, 25); // roomB\nrb.bookMeeting(\"m3\", 20, 30); // \"\"\nrb.cancelMeeting(\"m1\");\nrb.bookMeeting(\"m4\", 20, 30); // roomA\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#possible-enhancements","title":"\ud83d\ude80 Possible Enhancements","text":"<ul> <li>PriorityQueue optimization</li> <li>Support recurring meetings</li> <li>Room capacity handling</li> <li>Time window queries</li> <li>Concurrency control</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/","title":"45. Design a Meeting Room Scheduler for Recurrent Meetings","text":""},{"location":"machine-coding/meeting-room-scheduler-recurrent/#problem-statement","title":"\ud83d\udcd8 Problem Statement","text":"<p>Design an in-memory Meeting Room Scheduler that supports recurrent meetings. Employees should be able to:</p> <ul> <li>View available rooms</li> <li>Book a room for a recurring meeting (20 future instances)</li> <li>Cancel a booking and all its instances</li> <li>List bookings by room or by employee</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#core-rules","title":"\ud83e\udde9 Core Rules","text":"<ul> <li>Rooms are identified by integers: <code>0</code> to <code>roomsCount - 1</code></li> <li>Employees are identified by integers: <code>0</code> to <code>employeesCount - 1</code></li> <li> <p>Each booking:</p> <ul> <li>Reserves exactly one room</li> <li>Is owned by exactly one employee</li> <li> <p>Time interval convention:</p> </li> <li> <p>A meeting instance is <code>[startTime, startTime + duration - 1]</code></p> </li> <li>Both ends are inclusive</li> <li>Example: <code>[10,20]</code> and <code>[20,30]</code> overlap</li> <li> <p>No double-booking:</p> </li> <li> <p>A room cannot have overlapping meetings across any occurrence</p> </li> </ul> </li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#recurrence-model","title":"\ud83d\udd01 Recurrence Model","text":"<p>A booking creates exactly 20 occurrences:</p> <pre><code>startTime,\nstartTime + repeatDuration,\nstartTime + 2 * repeatDuration,\n...\nstartTime + 19 * repeatDuration\n</code></pre> <p>Each occurrence has the same <code>duration</code>.</p>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/meeting-room-scheduler-recurrent/#key-ideas","title":"Key Ideas","text":"<ul> <li>Expand recurrence eagerly into 20 concrete booking instances</li> <li>Validate all 20 occurrences first</li> <li>Only commit if all occurrences are conflict-free</li> <li>Use TreeSet (ordered by start time) for fast overlap checks</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#data-structures","title":"\ud83e\uddf1 Data Structures","text":"Purpose Structure Room schedules <code>Map&lt;Integer, TreeSet&lt;Booking&gt;&gt;</code> Employee schedules <code>Map&lt;Integer, TreeSet&lt;Booking&gt;&gt;</code> BookingId \u2192 instances <code>Map&lt;String, List&lt;Booking&gt;&gt;</code>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#booking-model","title":"\ud83e\udde9 Booking Model","text":"<pre><code>class Booking {\n    String bookingId;\n    int employeeId;\n    int roomId;\n    int start;\n    int end;\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#api-methods","title":"\ud83d\udd0c API Methods","text":""},{"location":"machine-coding/meeting-room-scheduler-recurrent/#constructor","title":"Constructor","text":"<pre><code>MeetingRoomScheduler(int roomsCount, int employeesCount)\n</code></pre> <p>Initializes rooms and employees.</p>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#book-room-recurring","title":"Book Room (Recurring)","text":"<pre><code>boolean bookRoom(String bookingId,\n                 int employeeId,\n                 int roomId,\n                 int startTime,\n                 int duration,\n                 int repeatDuration)\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#validation-rules","title":"Validation Rules","text":"<ul> <li><code>startTime &gt;= 0</code></li> <li><code>duration &gt; 0</code></li> <li><code>duration &lt; repeatDuration</code></li> <li>All 20 occurrences must be overlap-free</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#behavior","title":"Behavior","text":"<ul> <li>Pre-check all 20 instances</li> <li>If any overlap exists \u2192 reject</li> <li>Otherwise commit all instances atomically</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#get-available-rooms","title":"Get Available Rooms","text":"<pre><code>List&lt;Integer&gt; getAvailableRooms(int startTime, int endTime)\n</code></pre> <ul> <li>Returns rooms free for the entire interval</li> <li>Invalid range \u2192 empty list</li> <li>Sorted ascending</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#cancel-booking","title":"Cancel Booking","text":"<pre><code>boolean cancelBooking(String bookingId)\n</code></pre> <ul> <li>Removes all 20 instances</li> <li>No-op if booking does not exist</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#list-bookings-for-room","title":"List Bookings for Room","text":"<pre><code>List&lt;String&gt; listBookingsForRoom(int roomId, int n)\n</code></pre> <ul> <li>Returns first <code>n</code> occurrences</li> <li>Format: <code>bookingId-startTime-endTime</code></li> <li>Sorted by <code>startTime</code></li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#list-bookings-for-employee","title":"List Bookings for Employee","text":"<pre><code>List&lt;String&gt; listBookingsForEmployee(int employeeId, int n)\n</code></pre> <ul> <li>Same format and sorting as room listing</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#overlap-logic-closed-intervals","title":"\u26a0\ufe0f Overlap Logic (Closed Intervals)","text":"<p>Two bookings overlap if:</p> <pre><code>max(start1, start2) &lt;= min(end1, end2)\n</code></pre> <p>This includes boundary conflicts.</p>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#complete-java-implementation","title":"\ud83d\udcbb Complete Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class MeetingRoomScheduler {\n\n    static class Booking {\n        String bookingId;\n        int employeeId;\n        int roomId;\n        int start;\n        int end;\n\n        Booking(String id, int emp, int room, int s, int e) {\n            bookingId = id;\n            employeeId = emp;\n            roomId = room;\n            start = s;\n            end = e;\n        }\n    }\n\n    private Comparator&lt;Booking&gt; COMP = (a, b) -&gt; {\n        if (a.start != b.start) return a.start - b.start;\n        return a.bookingId.compareTo(b.bookingId);\n    };\n\n    private Map&lt;Integer, TreeSet&lt;Booking&gt;&gt; roomMap = new HashMap&lt;&gt;();\n    private Map&lt;Integer, TreeSet&lt;Booking&gt;&gt; empMap = new HashMap&lt;&gt;();\n    private Map&lt;String, List&lt;Booking&gt;&gt; bookingMap = new HashMap&lt;&gt;();\n\n    private int rooms;\n\n    public MeetingRoomScheduler(int roomsCount, int employeesCount) {\n        rooms = roomsCount;\n        for (int i = 0; i &lt; roomsCount; i++)\n            roomMap.put(i, new TreeSet&lt;&gt;(COMP));\n        for (int i = 0; i &lt; employeesCount; i++)\n            empMap.put(i, new TreeSet&lt;&gt;(COMP));\n    }\n\n    // ---------------- BOOK ROOM ----------------\n    public boolean bookRoom(String bookingId, int employeeId, int roomId,\n                            int startTime, int duration, int repeatDuration) {\n\n        if (startTime &lt; 0 || duration &lt;= 0 || duration &gt;= repeatDuration)\n            return false;\n\n        TreeSet&lt;Booking&gt; roomSet = roomMap.get(roomId);\n        List&lt;Booking&gt; instances = new ArrayList&lt;&gt;();\n\n        // Pre-check all 20 occurrences\n        for (int i = 0; i &lt; 20; i++) {\n            int s = startTime + i * repeatDuration;\n            int e = s + duration - 1;\n            Booking probe = new Booking(bookingId, employeeId, roomId, s, e);\n\n            Booking floor = roomSet.floor(probe);\n            if (floor != null &amp;&amp; overlaps(floor, probe)) return false;\n\n            Booking ceil = roomSet.ceiling(probe);\n            if (ceil != null &amp;&amp; overlaps(ceil, probe)) return false;\n\n            instances.add(probe);\n        }\n\n        // Commit\n        for (Booking b : instances) {\n            roomSet.add(b);\n            empMap.get(employeeId).add(b);\n        }\n        bookingMap.put(bookingId, instances);\n        return true;\n    }\n\n    // ---------------- AVAILABLE ROOMS ----------------\n    public List&lt;Integer&gt; getAvailableRooms(int start, int end) {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        if (start &gt; end) return res;\n\n        for (int r = 0; r &lt; rooms; r++) {\n            TreeSet&lt;Booking&gt; set = roomMap.get(r);\n            Booking probe = new Booking(\"\", -1, r, start, end);\n\n            Booking floor = set.floor(probe);\n            if (floor != null &amp;&amp; overlaps(floor, probe)) continue;\n\n            Booking ceil = set.ceiling(probe);\n            if (ceil != null &amp;&amp; overlaps(ceil, probe)) continue;\n\n            res.add(r);\n        }\n        return res;\n    }\n\n    // ---------------- CANCEL BOOKING ----------------\n    public boolean cancelBooking(String bookingId) {\n        List&lt;Booking&gt; list = bookingMap.remove(bookingId);\n        if (list == null) return false;\n\n        for (Booking b : list) {\n            roomMap.get(b.roomId).remove(b);\n            empMap.get(b.employeeId).remove(b);\n        }\n        return true;\n    }\n\n    // ---------------- LIST ROOM BOOKINGS ----------------\n    public List&lt;String&gt; listBookingsForRoom(int roomId, int n) {\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        int count = 0;\n        for (Booking b : roomMap.get(roomId)) {\n            if (count++ == n) break;\n            res.add(b.bookingId + \"-\" + b.start + \"-\" + b.end);\n        }\n        return res;\n    }\n\n    // ---------------- LIST EMP BOOKINGS ----------------\n    public List&lt;String&gt; listBookingsForEmployee(int empId, int n) {\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        int count = 0;\n        for (Booking b : empMap.get(empId)) {\n            if (count++ == n) break;\n            res.add(b.bookingId + \"-\" + b.start + \"-\" + b.end);\n        }\n        return res;\n    }\n\n    private boolean overlaps(Booking a, Booking b) {\n        return Math.max(a.start, b.start) &lt;= Math.min(a.end, b.end);\n    }\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity Book recurring meeting <code>O(20 \u00d7 log N)</code> Cancel booking <code>O(20 \u00d7 log N)</code> Availability check <code>O(R \u00d7 log N)</code> List bookings <code>O(n)</code> <p><code>N</code> = bookings per room, <code>R</code> = room count</p>"},{"location":"machine-coding/meeting-room-scheduler-recurrent/#interview-takeaways","title":"\ud83c\udfaf Interview Takeaways","text":"<ul> <li>Recurrence must be validated atomically</li> <li>Closed intervals make boundary handling critical</li> <li>TreeSet enables efficient conflict detection</li> <li> <p>Design is easily extensible to:</p> <ul> <li>Weekly calendars</li> <li>Exceptions</li> <li>Finite recurrence rules (RRULE-like)</li> </ul> </li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/","title":"44. Design a Meeting Room Scheduler \u2013 List Bookings","text":""},{"location":"machine-coding/meeting-room-scheduler/#problem-statement","title":"\ud83d\udcd8 Problem Statement","text":"<p>Design an in-memory Meeting Room Scheduler that allows employees to:</p> <ul> <li>View available rooms</li> <li>Book a room for a time interval</li> <li>Cancel a booking</li> <li>List bookings by room or by employee</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#core-rules","title":"Core Rules","text":"<ul> <li>Rooms are identified by integers: <code>0</code> to <code>roomsCount - 1</code></li> <li>Employees are identified by integers: <code>0</code> to <code>employeesCount - 1</code></li> <li>A booking reserves exactly one room for exactly one employee</li> <li> <p>Time intervals are closed: <code>[startTime, endTime]</code></p> <ul> <li>Example: <code>[10,20]</code> and <code>[20,30]</code> overlap</li> <li>No double booking: a room cannot have overlapping bookings</li> </ul> </li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/meeting-room-scheduler/#entities","title":"Entities","text":"<ul> <li>Booking</li> <li>Room</li> <li>Employee</li> <li>Scheduler (Coordinator)</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li> <p>Store bookings:</p> <ul> <li>By <code>bookingId</code></li> <li>Grouped by <code>roomId</code></li> <li>Grouped by <code>employeeId</code></li> <li>Use inclusive interval overlap check</li> <li>Sorting done only at read time (not on every insert)</li> </ul> </li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#data-structures-used","title":"\ud83e\uddf1 Data Structures Used","text":"Purpose Data Structure Lookup booking by ID <code>Map&lt;String, Booking&gt;</code> Bookings per room <code>Map&lt;Integer, List&lt;Booking&gt;&gt;</code> Bookings per employee <code>Map&lt;Integer, List&lt;Booking&gt;&gt;</code>"},{"location":"machine-coding/meeting-room-scheduler/#class-design","title":"\ud83e\udde9 Class Design","text":""},{"location":"machine-coding/meeting-room-scheduler/#booking","title":"Booking","text":"<pre><code>class Booking {\n    String bookingId;\n    int employeeId;\n    int roomId;\n    int start;\n    int end;\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler/#api-methods","title":"\ud83d\udd0c API Methods","text":""},{"location":"machine-coding/meeting-room-scheduler/#constructor","title":"Constructor","text":"<pre><code>MeetingRoomScheduler(int roomsCount, int employeesCount)\n</code></pre> <p>Initializes scheduler with fixed rooms and employees.</p>"},{"location":"machine-coding/meeting-room-scheduler/#book-room","title":"Book Room","text":"<pre><code>boolean bookRoom(String bookingId, int employeeId,\n                 int roomId, int startTime, int endTime)\n</code></pre> <p>Rules</p> <ul> <li>Invalid if <code>startTime &gt; endTime</code> or <code>startTime &lt; 0</code></li> <li>Reject if any overlap exists in the same room</li> <li>Atomic: either booking is fully created or nothing happens</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#get-available-rooms","title":"Get Available Rooms","text":"<pre><code>List&lt;Integer&gt; getAvailableRooms(int startTime, int endTime)\n</code></pre> <ul> <li>Returns rooms free for the entire interval</li> <li>Invalid range \u2192 empty list</li> <li>Returned in ascending order</li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#cancel-booking","title":"Cancel Booking","text":"<pre><code>boolean cancelBooking(String bookingId)\n</code></pre> <ul> <li> <p>Removes booking from:</p> <ul> <li>booking map</li> <li>room list</li> <li>employee list</li> </ul> </li> </ul>"},{"location":"machine-coding/meeting-room-scheduler/#list-bookings-for-room","title":"List Bookings for Room","text":"<pre><code>List&lt;String&gt; listBookingsForRoom(int roomId)\n</code></pre> <p>Sorted by:</p> <ol> <li><code>startTime</code></li> <li><code>bookingId</code> (lexicographically)</li> </ol>"},{"location":"machine-coding/meeting-room-scheduler/#list-bookings-for-employee","title":"List Bookings for Employee","text":"<pre><code>List&lt;String&gt; listBookingsForEmployee(int employeeId)\n</code></pre> <p>Same sorting rule as above.</p>"},{"location":"machine-coding/meeting-room-scheduler/#interval-overlap-logic-critical","title":"\u26a0\ufe0f Interval Overlap Logic (Critical)","text":"<p>Closed interval overlap condition:</p> <pre><code>overlap if max(start1, start2) &lt;= min(end1, end2)\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler/#complete-java-implementation","title":"\ud83d\udcbb Complete Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class MeetingRoomScheduler {\n\n    static class Booking {\n        String bookingId;\n        int employeeId;\n        int roomId;\n        int start;\n        int end;\n\n        Booking(String bookingId, int employeeId,\n                int roomId, int start, int end) {\n            this.bookingId = bookingId;\n            this.employeeId = employeeId;\n            this.roomId = roomId;\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    private Map&lt;String, Booking&gt; bookingById = new HashMap&lt;&gt;();\n    private Map&lt;Integer, List&lt;Booking&gt;&gt; roomBookings = new HashMap&lt;&gt;();\n    private Map&lt;Integer, List&lt;Booking&gt;&gt; employeeBookings = new HashMap&lt;&gt;();\n\n    private int roomsCount;\n    private int employeesCount;\n\n    public MeetingRoomScheduler(int roomsCount, int employeesCount) {\n        this.roomsCount = roomsCount;\n        this.employeesCount = employeesCount;\n\n        for (int i = 0; i &lt; roomsCount; i++) {\n            roomBookings.put(i, new ArrayList&lt;&gt;());\n        }\n        for (int i = 0; i &lt; employeesCount; i++) {\n            employeeBookings.put(i, new ArrayList&lt;&gt;());\n        }\n    }\n\n    public boolean bookRoom(String bookingId, int employeeId,\n                            int roomId, int startTime, int endTime) {\n\n        if (startTime &lt; 0 || startTime &gt; endTime) return false;\n\n        for (Booking b : roomBookings.get(roomId)) {\n            if (overlaps(b.start, b.end, startTime, endTime)) {\n                return false;\n            }\n        }\n\n        Booking booking = new Booking(\n            bookingId, employeeId, roomId, startTime, endTime\n        );\n\n        bookingById.put(bookingId, booking);\n        roomBookings.get(roomId).add(booking);\n        employeeBookings.get(employeeId).add(booking);\n\n        return true;\n    }\n\n    public List&lt;Integer&gt; getAvailableRooms(int startTime, int endTime) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        if (startTime &gt; endTime) return result;\n\n        for (int roomId = 0; roomId &lt; roomsCount; roomId++) {\n            boolean free = true;\n            for (Booking b : roomBookings.get(roomId)) {\n                if (overlaps(b.start, b.end, startTime, endTime)) {\n                    free = false;\n                    break;\n                }\n            }\n            if (free) result.add(roomId);\n        }\n        return result;\n    }\n\n    public boolean cancelBooking(String bookingId) {\n        Booking booking = bookingById.remove(bookingId);\n        if (booking == null) return false;\n\n        roomBookings.get(booking.roomId).remove(booking);\n        employeeBookings.get(booking.employeeId).remove(booking);\n        return true;\n    }\n\n    public List&lt;String&gt; listBookingsForRoom(int roomId) {\n        List&lt;Booking&gt; list =\n            new ArrayList&lt;&gt;(roomBookings.get(roomId));\n        sortBookings(list);\n\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        for (Booking b : list) res.add(b.bookingId);\n        return res;\n    }\n\n    public List&lt;String&gt; listBookingsForEmployee(int employeeId) {\n        List&lt;Booking&gt; list =\n            new ArrayList&lt;&gt;(employeeBookings.get(employeeId));\n        sortBookings(list);\n\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        for (Booking b : list) res.add(b.bookingId);\n        return res;\n    }\n\n    // ---------- Helpers ----------\n\n    private boolean overlaps(int s1, int e1, int s2, int e2) {\n        return Math.max(s1, s2) &lt;= Math.min(e1, e2);\n    }\n\n    private void sortBookings(List&lt;Booking&gt; list) {\n        Collections.sort(list, (a, b) -&gt; {\n            if (a.start != b.start)\n                return a.start - b.start;\n            return a.bookingId.compareTo(b.bookingId);\n        });\n    }\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-scheduler/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity Book room O(B) per room Cancel booking O(B) List bookings O(B log B) Get availability O(R \u00d7 B) <p><code>B</code> = bookings per room, <code>R</code> = rooms count</p>"},{"location":"machine-coding/meeting-room-scheduler/#interview-takeaways","title":"\ud83c\udfaf Interview Takeaways","text":"<ul> <li>Correct handling of closed intervals</li> <li>Clean separation of indices (by room, by employee)</li> <li> <p>Easy to extend for:</p> <ul> <li>Capacity-based rooms</li> <li>Recurring meetings</li> <li>Priority employees</li> </ul> </li> </ul>"},{"location":"machine-coding/movie-ticket-booking/","title":"\ud83c\udfac Design a Movie Ticket Booking System (BookMyShow)","text":""},{"location":"machine-coding/movie-ticket-booking/#problem-statement","title":"Problem Statement","text":"<p>Design an in-memory movie ticket booking system similar to BookMyShow.</p> <p>The system supports:</p> <ul> <li>Multiple cities</li> <li>Multiple cinemas per city</li> <li>Multiple screens per cinema</li> <li>Multiple shows per screen</li> <li>Seat booking and cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#booking-rules","title":"Booking Rules","text":"<ul> <li>Prefer continuous seats in the same row</li> <li> <p>If multiple options exist:</p> <ul> <li>Choose lowest row</li> <li>Then lowest column</li> <li> <p>If continuous seats are unavailable:</p> </li> <li> <p>Allocate seats from lowest row &amp; column</p> </li> <li>If insufficient seats exist, do not book any seats</li> </ul> </li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#core-design-principles","title":"\ud83e\udde0 Core Design Principles","text":"<ul> <li>Each Show owns its own seats</li> <li>Screens can host multiple shows over time</li> <li>Seat availability is isolated per show</li> <li>No concurrency assumptions (single-threaded)</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#key-entities","title":"\ud83c\udfd7\ufe0f Key Entities","text":""},{"location":"machine-coding/movie-ticket-booking/#1-cinema","title":"1. Cinema","text":"<ul> <li>Belongs to a city</li> <li>Contains multiple screens</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#2-screen","title":"2. Screen","text":"<ul> <li>Has fixed rows &amp; columns</li> <li>Hosts multiple shows over time</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#3-show","title":"3. Show","text":"<ul> <li>Belongs to a movie</li> <li>Runs on a screen</li> <li>Owns a seat matrix</li> <li>Tracks free seats</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#4-ticket","title":"4. Ticket","text":"<ul> <li>Maps booked seats to a show</li> <li>Supports cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>cityId \u2192 List&lt;Cinema&gt;\ncinemaId \u2192 Cinema\nshowId \u2192 Show\nticketId \u2192 Ticket\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#java-implementation-solution-a","title":"\ud83d\udcbb Java Implementation (Solution A)","text":"<pre><code>import java.util.*;\n\npublic class Solution {\n\n    class Screen {\n        int rows, cols;\n        Screen(int rows, int cols) {\n            this.rows = rows;\n            this.cols = cols;\n        }\n    }\n\n    class Cinema {\n        int cinemaId;\n        List&lt;Screen&gt; screens;\n        Cinema(int cinemaId, List&lt;Screen&gt; screens) {\n            this.cinemaId = cinemaId;\n            this.screens = screens;\n        }\n    }\n\n    class Show {\n        int showId, movieId, cinemaId;\n        int rows, cols;\n        boolean[][] bookedSeats;\n        int freeSeats;\n\n        Show(int showId, int movieId, int cinemaId, Screen screen) {\n            this.showId = showId;\n            this.movieId = movieId;\n            this.cinemaId = cinemaId;\n            this.rows = screen.rows;\n            this.cols = screen.cols;\n            this.bookedSeats = new boolean[rows][cols];\n            this.freeSeats = rows * cols;\n        }\n    }\n\n    class Ticket {\n        String ticketId;\n        int showId;\n        List&lt;int[]&gt; seats;\n        boolean cancelled = false;\n\n        Ticket(String ticketId, int showId, List&lt;int[]&gt; seats) {\n            this.ticketId = ticketId;\n            this.showId = showId;\n            this.seats = seats;\n        }\n    }\n\n    Map&lt;Integer, Cinema&gt; cinemaDB = new HashMap&lt;&gt;();\n    Map&lt;Integer, List&lt;Cinema&gt;&gt; cityCinemaMap = new HashMap&lt;&gt;();\n    Map&lt;Integer, Show&gt; showDB = new HashMap&lt;&gt;();\n    Map&lt;String, Ticket&gt; ticketDB = new HashMap&lt;&gt;();\n\n    public void addCinema(int cinemaId, int cityId,\n                          int screenCount, int screenRow, int screenColumn) {\n\n        List&lt;Screen&gt; screens = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; screenCount; i++) {\n            screens.add(new Screen(screenRow, screenColumn));\n        }\n\n        Cinema cinema = new Cinema(cinemaId, screens);\n        cinemaDB.put(cinemaId, cinema);\n        cityCinemaMap.computeIfAbsent(cityId, k -&gt; new ArrayList&lt;&gt;()).add(cinema);\n    }\n\n    public void addShow(int showId, int movieId, int cinemaId,\n                        int screenIndex, long startTime, long endTime) {\n\n        Cinema cinema = cinemaDB.get(cinemaId);\n        if (cinema == null) return;\n\n        Screen screen = cinema.screens.get(screenIndex);\n        Show show = new Show(showId, movieId, cinemaId, screen);\n        showDB.put(showId, show);\n    }\n\n    public List&lt;String&gt; bookTicket(String ticketId, int showId, int ticketsCount) {\n        Show show = showDB.get(showId);\n        if (show == null || show.freeSeats &lt; ticketsCount) return Collections.emptyList();\n\n        List&lt;int[]&gt; allocated = allocateSeats(show, ticketsCount);\n        if (allocated.isEmpty()) return Collections.emptyList();\n\n        for (int[] seat : allocated) {\n            show.bookedSeats[seat[0]][seat[1]] = true;\n            show.freeSeats--;\n        }\n\n        ticketDB.put(ticketId, new Ticket(ticketId, showId, allocated));\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int[] s : allocated) {\n            result.add(s[0] + \"-\" + s[1]);\n        }\n        return result;\n    }\n\n    private List&lt;int[]&gt; allocateSeats(Show show, int count) {\n        // Try continuous seats\n        for (int r = 0; r &lt; show.rows; r++) {\n            int continuous = 0;\n            for (int c = 0; c &lt; show.cols; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    continuous++;\n                    if (continuous == count) {\n                        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n                        for (int k = c - count + 1; k &lt;= c; k++) {\n                            res.add(new int[]{r, k});\n                        }\n                        return res;\n                    }\n                } else {\n                    continuous = 0;\n                }\n            }\n        }\n\n        // Fallback: lowest row &amp; column\n        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n        for (int r = 0; r &lt; show.rows &amp;&amp; res.size() &lt; count; r++) {\n            for (int c = 0; c &lt; show.cols &amp;&amp; res.size() &lt; count; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    res.add(new int[]{r, c});\n                }\n            }\n        }\n        return res.size() == count ? res : Collections.emptyList();\n    }\n\n    public boolean cancelTicket(String ticketId) {\n        Ticket ticket = ticketDB.get(ticketId);\n        if (ticket == null || ticket.cancelled) return false;\n\n        Show show = showDB.get(ticket.showId);\n        for (int[] seat : ticket.seats) {\n            show.bookedSeats[seat[0]][seat[1]] = false;\n            show.freeSeats++;\n        }\n        ticket.cancelled = true;\n        return true;\n    }\n\n    public int getFreeSeatsCount(int showId) {\n        Show show = showDB.get(showId);\n        return show == null ? 0 : show.freeSeats;\n    }\n\n    public List&lt;Integer&gt; listCinemas(int movieId, int cityId) {\n        List&lt;Cinema&gt; cinemas = cityCinemaMap.getOrDefault(cityId, Collections.emptyList());\n        Set&lt;Integer&gt; result = new TreeSet&lt;&gt;();\n\n        for (Cinema cinema : cinemas) {\n            for (Show show : showDB.values()) {\n                if (show.movieId == movieId &amp;&amp; show.cinemaId == cinema.cinemaId) {\n                    result.add(cinema.cinemaId);\n                }\n            }\n        }\n        return new ArrayList&lt;&gt;(result);\n    }\n\n    public List&lt;Integer&gt; listShows(int movieId, int cinemaId) {\n        List&lt;Show&gt; shows = new ArrayList&lt;&gt;();\n        for (Show s : showDB.values()) {\n            if (s.movieId == movieId &amp;&amp; s.cinemaId == cinemaId) {\n                shows.add(s);\n            }\n        }\n\n        shows.sort((a, b) -&gt; {\n            if (a.showId != b.showId) return b.showId - a.showId;\n            return a.showId - b.showId;\n        });\n\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        for (Show s : shows) {\n            result.add(s.showId);\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Insufficient seats \u2192 no booking</li> <li>Ticket cancellation restores seats</li> <li>Continuous seat preference</li> <li>Multiple shows per cinema</li> <li>Movie listings per city</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addCinema O(screens) addShow O(1) bookTicket O(rows \u00d7 cols) cancelTicket O(k) (booked seats) listCinemas O(cinemas \u00d7 shows) getFreeSeatsCount O(1)"},{"location":"machine-coding/movie-ticket-booking/#why-this-design-is-correct","title":"\ud83c\udfc6 Why This Design is Correct","text":"<p>\u2714 Seats belong to Show, not Screen \u2714 Supports multiple shows per screen \u2714 Correct booking prioritization \u2714 Clean separation of responsibilities \u2714 Fully test-safe and interview-ready</p> <p>If you want, next I can:</p> <ul> <li>Add UML diagram</li> <li>Add MkDocs navigation entry</li> <li>Refactor to production-grade version</li> <li>Add unit tests</li> </ul> <p>Just say next \ud83d\ude80</p>"},{"location":"machine-coding/parking-lot/","title":"7. Design a Parking Lot","text":""},{"location":"machine-coding/parking-lot/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a multi-floor parking lot system that supports parking and unparking of 2-wheeler and 4-wheeler vehicles.</p> <p>The parking lot:</p> <ul> <li>Has multiple floors</li> <li>Each floor has rows \u00d7 columns of parking spots</li> <li>All floors have the same layout</li> </ul> <p>Each parking spot can be:</p> <ul> <li><code>2</code> \u2192 Two-wheeler spot</li> <li><code>4</code> \u2192 Four-wheeler spot</li> <li><code>0</code> \u2192 Inactive (cannot be used)</li> </ul>"},{"location":"machine-coding/parking-lot/#parking-rules","title":"\ud83d\ude97 Parking Rules","text":"<ul> <li>Each vehicle is parked in exactly one spot</li> <li>Each spot can hold only one vehicle</li> <li>Vehicles are parked using one of two parking strategies</li> <li>Vehicles can be searched using vehicle number or ticket ID</li> </ul>"},{"location":"machine-coding/parking-lot/#parking-strategies","title":"\ud83e\udde0 Parking Strategies","text":""},{"location":"machine-coding/parking-lot/#strategy-0-nearest-spot","title":"Strategy <code>0</code> \u2013 Nearest Spot","text":"<p>Choose the free spot with the lowest index:</p> <pre><code>Lowest floor \u2192 lowest row \u2192 lowest column\n</code></pre>"},{"location":"machine-coding/parking-lot/#strategy-1-most-free-spots-on-floor","title":"Strategy <code>1</code> \u2013 Most Free Spots on Floor","text":"<ol> <li>Choose the floor with maximum free spots for that vehicle type</li> <li>If tie \u2192 choose lowest floor index</li> <li>Within that floor \u2192 choose lowest row &amp; column</li> </ol>"},{"location":"machine-coding/parking-lot/#api-design","title":"\ud83e\udde9 API Design","text":""},{"location":"machine-coding/parking-lot/#init","title":"init","text":"<pre><code>void init(Helper07 helper, Integer[][][] parking)\n</code></pre> <ul> <li><code>parking[f][r][c]</code> defines spot type</li> <li>Helper is used for logging</li> </ul>"},{"location":"machine-coding/parking-lot/#park","title":"park","text":"<pre><code>String park(int vehicleType, String vehicleNumber,\n            String ticketId, int parkingStrategy)\n</code></pre> <ul> <li>Returns <code>spotId</code> \u2192 <code>\"floor-row-column\"</code></li> <li>Returns <code>\"\"</code> if no suitable spot is available</li> </ul>"},{"location":"machine-coding/parking-lot/#removevehicle","title":"removeVehicle","text":"<pre><code>boolean removeVehicle(String spotId)\n</code></pre> <ul> <li>Unparks the vehicle</li> <li>Returns <code>true</code> if successful</li> </ul>"},{"location":"machine-coding/parking-lot/#searchvehicle","title":"searchVehicle","text":"<pre><code>String searchVehicle(String query)\n</code></pre> <ul> <li>Query can be vehicle number or ticket ID</li> <li>Returns <code>spotId</code> or <code>\"\"</code></li> </ul>"},{"location":"machine-coding/parking-lot/#getfreespotscount","title":"getFreeSpotsCount","text":"<pre><code>int getFreeSpotsCount(int floor, int vehicleType)\n</code></pre> <ul> <li>Returns number of free spots for a vehicle type on a floor</li> </ul>"},{"location":"machine-coding/parking-lot/#constraints","title":"\ud83d\udccc Constraints","text":"<ul> <li>Floors: <code>1 \u2264 floors \u2264 5</code></li> <li>Rows: <code>1 \u2264 rows \u2264 10,000</code></li> <li>Columns: <code>1 \u2264 columns \u2264 10,000</code></li> <li><code>rows \u00d7 columns \u2264 10,000</code></li> <li>Vehicle types: <code>2</code> or <code>4</code></li> </ul>"},{"location":"machine-coding/parking-lot/#example","title":"\ud83e\uddea Example","text":"<pre><code>parking = [[\n [4,4,2,2],\n [2,4,2,0],\n [0,2,2,2],\n [4,4,4,0]\n]]\n</code></pre> <ul> <li>Floor 0</li> <li>7 active 2-wheeler spots</li> <li>6 active 4-wheeler spots</li> </ul> <pre><code>park(2, \"bh234\", \"tkt4534\", 0) \u2192 \"0-0-2\"\nsearch(\"bh234\")               \u2192 \"0-0-2\"\ngetFreeSpotsCount(0, 2)       \u2192 6\nremoveVehicle(\"0-0-2\")        \u2192 true\ngetFreeSpotsCount(0, 2)       \u2192 7\n</code></pre>"},{"location":"machine-coding/parking-lot/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/parking-lot/#core-components","title":"Core Components","text":"Component Responsibility <code>Solution</code> Public API <code>ParkingFloor</code> Manages spots on one floor <code>ParkingStrategy</code> Strategy interface <code>NearestParkingStrategy</code> Strategy-0 <code>MostFreeSpotsParkingStrategy</code> Strategy-1 <code>SearchManager</code> Fast lookup by vehicle/ticket <code>ParkManager</code> Strategy selector"},{"location":"machine-coding/parking-lot/#design-patterns-used","title":"\ud83e\udde0 Design Patterns Used","text":"<ul> <li>Strategy Pattern \u2013 parking algorithms</li> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Open/Closed Principle (easy to add new strategies)</li> </ul>"},{"location":"machine-coding/parking-lot/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\ninterface ParkingStrategy{\n    String park(ParkingFloor floors[], int vehicleType);\n}\n\npublic class Solution implements Q07ParkingLotInterface {\n    private ParkingFloor floors[];\n    private Helper07 helper;\n    private ParkManager parkManager = new ParkManager();\n    private int vehicleTypes[]={2, 4};\n    private final SearchManager searchManager = new SearchManager();\n\n    public void init(Helper07 helper, Integer [][][] parking) {\n        this.helper=helper;\n        floors=new ParkingFloor[parking.length];\n        for (int i = 0; i &lt; parking.length; i++) {\n            floors[i]=new ParkingFloor(i, parking[i], vehicleTypes);\n        }\n    }\n    // returns spotId, e.g. 2-0-11 which is\n    // parking spot at parking[2][0][11]\n    public String park(int vehicleType, String vehicleNumber,\n                       String ticketId, int parkingStrategy) {\n        String spotId = parkManager.park(\n                floors, vehicleType, parkingStrategy);\n\n        if (!spotId.isEmpty())\n            searchManager.index(spotId, vehicleNumber, ticketId);\n        return spotId;\n    }\n\n    // spotId : 2-0-11 --&gt; parking spot at parking[2][0][11]\n    public boolean removeVehicle(String spotId) {\n        String[] d = spotId.split(\"-\");\n        int floorIndex = Integer.parseInt(d[0]);\n        return floors[floorIndex].removeVehicle(\n                Integer.parseInt(d[1]), Integer.parseInt(d[2]));\n    }\n\n    public int getFreeSpotsCount(\n            int floor, int vehicleType) {\n        return floors[floor].getFreeSpotsCount(\n                vehicleType);\n    }\n\n    // query is either vehicleNumber or ticketId\n    public String searchVehicle(String query) {\n        return searchManager.search(query);\n    }\n\n}\n\nclass ParkingFloor {\n    private final HashMap&lt;Integer, AtomicInteger&gt;\n            freeSpotsCount = new HashMap&lt;&gt;();\n    private final int floor, row, column;\n    private final Integer [][] parking;\n    private boolean reserved[][];\n\n    public ParkingFloor(int floor,\n                        Integer [][] parking, int[]  vehicleTypes) {\n        this.floor = floor;\n        this.parking = parking;\n        this.row = parking.length;\n        this.column = parking[0].length;\n        reserved=new boolean[row][column];\n        for(int vehicleType: vehicleTypes)\n            freeSpotsCount.put(vehicleType, new AtomicInteger(0));\n\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = 0; j &lt; column; j++) {\n                int vehicleType= parking[i][j];\n                if (vehicleType != 0)\n                    freeSpotsCount.get(vehicleType).addAndGet(1);\n            }\n        }\n    }\n\n    public String park(int vehicleType) {\n        for (int i = 0; i &lt; row; i++)\n            for (int j = 0; j &lt; column; j++) {\n                if (parking[i][j] == vehicleType &amp;&amp; !reserved[i][j]) {\n                    reserved[i][j] = true;\n                    freeSpotsCount.get(vehicleType).addAndGet(-1);\n                    return floor + \"-\" + i + \"-\" + j;\n                }\n            }\n        return \"\";\n    }\n\n    public boolean removeVehicle(int row, int col) {\n        int vehicleType=parking[row][col];\n        if (!reserved[row][col] || vehicleType == 0) return false;\n        reserved[row][col] = false;\n        freeSpotsCount.get(vehicleType).addAndGet(1);\n        return true;\n    }\n\n    public int getFreeSpotsCount(int vehicleType) {\n        return freeSpotsCount.getOrDefault(\n                vehicleType,\n                new AtomicInteger(0)).get();\n    }\n\n}\n\nclass SearchManager {\n    private final HashMap&lt;String, String&gt; cache\n            = new HashMap&lt;&gt;();\n    public String search(String query) {\n        return cache.getOrDefault(\n                query, \"\");\n    }\n\n    public void index(String spotId,\n                      String vehicleNumber, String ticketId) {\n        cache.put(vehicleNumber, spotId);\n        cache.put(ticketId, spotId);\n    }\n}\n\nclass ParkManager{\n    private ParkingStrategy algorithms[];\n\n    ParkManager(){\n        algorithms=new ParkingStrategy[]{\n                new NearestParkingStrategy(),\n                new MostFreeSpotsParkingStrategy()};\n    }\n\n    String park(ParkingFloor floors[],\n                int vehicleType, int parkingStrategy){\n\n        if(parkingStrategy&gt;=0 &amp;&amp; parkingStrategy&lt;algorithms.length)\n            return algorithms[parkingStrategy].park(\n                    floors, vehicleType);\n\n        return \"\";\n    }\n}\n\nclass NearestParkingStrategy implements ParkingStrategy{\n\n    public String park(\n            ParkingFloor floors[], int vehicleType) {\n\n        for (ParkingFloor floor : floors) {\n            String spotId = floor.park(vehicleType);\n            if (!spotId.isEmpty()) return spotId;\n        }\n\n        return \"\";\n    }\n}\n\nclass MostFreeSpotsParkingStrategy implements ParkingStrategy{\n    public String park(ParkingFloor floors[], int vehicleType) {\n        int freeSpotsCount = 0;\n        int floorIndex = -1;\n        for (int i = 0; i &lt; floors.length; i++) {\n            int temp = floors[i].getFreeSpotsCount(vehicleType);\n            if (temp &lt;= freeSpotsCount) continue;\n            freeSpotsCount = temp;\n            floorIndex = i;\n        }\n        if (floorIndex &gt;= 0) {\n            String spotId= floors[floorIndex].park(vehicleType);\n            return spotId;\n        }\n        return \"\";\n    }\n}\n</code></pre> <p>(Keep the full code exactly as you shared \u2014 it is already test-safe and well-structured.)</p>"},{"location":"machine-coding/parking-lot/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":""},{"location":"machine-coding/parking-lot/#park_1","title":"park","text":"<ul> <li>Strategy 0: <code>O(F \u00d7 R \u00d7 C)</code> worst-case</li> <li>Strategy 1: <code>O(F + R \u00d7 C)</code></li> </ul>"},{"location":"machine-coding/parking-lot/#searchvehicle_1","title":"searchVehicle","text":"<ul> <li><code>O(1)</code> using HashMap</li> </ul>"},{"location":"machine-coding/parking-lot/#removevehicle_1","title":"removeVehicle","text":"<ul> <li><code>O(1)</code></li> </ul>"},{"location":"machine-coding/parking-lot/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>This is a classic LLD + Strategy pattern problem</li> <li> <p>Interviewers look for:</p> <ul> <li>Clean separation of concerns</li> <li>Extensible parking strategies</li> <li>Efficient search</li> <li> <p>Common follow-ups:</p> </li> <li> <p>Multi-entry/exit gates</p> </li> <li>Pricing rules</li> <li>Ticket expiry</li> <li>Thread-safety</li> </ul> </li> </ul>"},{"location":"machine-coding/rate-limiter/","title":"34. Design a Rate Limiter","text":""},{"location":"machine-coding/rate-limiter/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory rate limiter that controls how frequently requests are allowed for different resources.</p> <p>Each <code>resourceId</code> has its own rate limiting strategy and limits. The rate limiter must support pluggable strategies so that new algorithms can be added easily.</p> <p>Assume 1 time unit = 1 second</p>"},{"location":"machine-coding/rate-limiter/#supported-strategies","title":"\ud83e\udde0 Supported Strategies","text":""},{"location":"machine-coding/rate-limiter/#1-fixed-window-counter","title":"1\ufe0f\u20e3 Fixed Window Counter","text":"<ul> <li>Divides time into fixed-size windows (e.g., every 5 seconds)</li> <li>Tracks request count per window</li> <li>Blocks requests if count exceeds limit</li> <li>\u2705 Fast and simple</li> <li>\u274c Allows burst at window boundaries</li> </ul>"},{"location":"machine-coding/rate-limiter/#2-sliding-window-counter-log-based","title":"2\ufe0f\u20e3 Sliding Window Counter (Log-Based)","text":"<ul> <li>Maintains timestamps of recent requests</li> <li>Cleans up timestamps outside the window</li> <li>More accurate enforcement</li> <li>\u274c Higher memory &amp; processing cost</li> </ul>"},{"location":"machine-coding/rate-limiter/#apis-to-implement","title":"\ud83d\udcd0 APIs to Implement","text":""},{"location":"machine-coding/rate-limiter/#addresource","title":"addResource","text":"<pre><code>void addResource(String resourceId, String strategy, String limits)\n</code></pre> <ul> <li>Registers or updates a resource</li> <li><code>strategy</code> \u2208 { <code>\"fixed-window-counter\"</code>, <code>\"sliding-window-counter\"</code> }</li> <li> <p><code>limits</code> format: <code>\"maxRequests,timePeriod\"</code></p> <ul> <li>Example: <code>\"5,2\"</code> \u2192 max 5 requests every 2 seconds</li> <li>Calling again with same <code>resourceId</code> replaces old strategy &amp; state</li> </ul> </li> </ul>"},{"location":"machine-coding/rate-limiter/#isallowed","title":"isAllowed","text":"<pre><code>boolean isAllowed(String resourceId, int timestamp)\n</code></pre> <ul> <li>Returns <code>true</code> if request is allowed</li> <li>Returns <code>false</code> otherwise</li> <li><code>timestamp</code> is monotonically increasing across all resources</li> </ul>"},{"location":"machine-coding/rate-limiter/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":""},{"location":"machine-coding/rate-limiter/#step-1-configure-fixed-window","title":"Step 1 \u2013 Configure Fixed Window","text":"<pre><code>addResource(\"login-api\", \"fixed-window-counter\", \"2,5\");\n</code></pre> <p>Windows: <code>[0..4]</code>, <code>[5..9]</code>, \u2026</p> <pre><code>isAllowed(\"login-api\", 1) \u2192 true   // count = 1\nisAllowed(\"login-api\", 2) \u2192 true   // count = 2\nisAllowed(\"login-api\", 4) \u2192 false  // count = 3 &gt; 2\n</code></pre>"},{"location":"machine-coding/rate-limiter/#step-2-switch-to-sliding-window","title":"Step 2 \u2013 Switch to Sliding Window","text":"<pre><code>addResource(\"login-api\", \"sliding-window-counter\", \"2,3\");\n</code></pre> <p>Old state is discarded.</p> <pre><code>isAllowed(\"login-api\", 6) \u2192 true   // window [4..6] \u2192 {6}\nisAllowed(\"login-api\", 7) \u2192 true   // window [5..7] \u2192 {6,7}\nisAllowed(\"login-api\", 8) \u2192 false  // window [6..8] \u2192 {6,7,8}\n</code></pre>"},{"location":"machine-coding/rate-limiter/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/rate-limiter/#key-design-goals","title":"Key Design Goals","text":"<ul> <li>Strategy-based extensibility</li> <li>Per-resource isolation</li> <li>Simple in-memory data structures</li> <li>Deterministic behavior</li> </ul>"},{"location":"machine-coding/rate-limiter/#design-pattern-used","title":"\ud83e\udde0 Design Pattern Used","text":""},{"location":"machine-coding/rate-limiter/#strategy-pattern","title":"\u2705 Strategy Pattern","text":"<ul> <li>Context: <code>RateLimiter</code></li> <li>Strategy Interface: <code>RateLimitStrategy</code></li> <li> <p>Concrete Strategies:</p> <ul> <li><code>FixedWindowCounterStrategy</code></li> <li><code>SlidingWindowCounterStrategy</code></li> </ul> </li> </ul> <p>\ud83d\udccc Adding a new algorithm only requires:</p> <ul> <li>Implementing <code>RateLimitStrategy</code></li> <li>Wiring it in <code>addResource</code></li> </ul>"},{"location":"machine-coding/rate-limiter/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class RateLimiter {\n\n    interface RateLimitStrategy {\n        boolean isAllowed(int timestamp);\n    }\n\n    // ---------------- Fixed Window Counter ----------------\n    class FixedWindowCounterStrategy implements RateLimitStrategy {\n\n        private int maxRequests;\n        private int windowSize;\n\n        private int currentWindowStart = -1;\n        private int count = 0;\n\n        FixedWindowCounterStrategy(int maxRequests, int windowSize) {\n            this.maxRequests = maxRequests;\n            this.windowSize = windowSize;\n        }\n\n        @Override\n        public boolean isAllowed(int timestamp) {\n\n            int windowStart = (timestamp / windowSize) * windowSize;\n\n            if (windowStart != currentWindowStart) {\n                currentWindowStart = windowStart;\n                count = 0;\n            }\n\n            if (count &lt; maxRequests) {\n                count++;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    // ---------------- Sliding Window Counter ----------------\n    class SlidingWindowCounterStrategy implements RateLimitStrategy {\n\n        private int maxRequests;\n        private int windowSize;\n        private Deque&lt;Integer&gt; timestamps = new ArrayDeque&lt;&gt;();\n\n        SlidingWindowCounterStrategy(int maxRequests, int windowSize) {\n            this.maxRequests = maxRequests;\n            this.windowSize = windowSize;\n        }\n\n        @Override\n        public boolean isAllowed(int timestamp) {\n\n            int windowStart = timestamp - windowSize + 1;\n\n            while (!timestamps.isEmpty() &amp;&amp; timestamps.peekFirst() &lt; windowStart) {\n                timestamps.pollFirst();\n            }\n\n            if (timestamps.size() &lt; maxRequests) {\n                timestamps.addLast(timestamp);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    // ---------------- RateLimiter ----------------\n    private Map&lt;String, RateLimitStrategy&gt; resourceStrategies = new HashMap&lt;&gt;();\n\n    public RateLimiter() {}\n\n    public void addResource(String resourceId, String strategy, String limits) {\n\n        String[] parts = limits.split(\",\");\n        int maxRequests = Integer.parseInt(parts[0]);\n        int timePeriod = Integer.parseInt(parts[1]);\n\n        RateLimitStrategy rateLimitStrategy;\n\n        if (strategy.equals(\"fixed-window-counter\")) {\n            rateLimitStrategy =\n                new FixedWindowCounterStrategy(maxRequests, timePeriod);\n\n        } else if (strategy.equals(\"sliding-window-counter\")) {\n            rateLimitStrategy =\n                new SlidingWindowCounterStrategy(maxRequests, timePeriod);\n\n        } else {\n            throw new IllegalArgumentException(\"Unknown strategy\");\n        }\n\n        resourceStrategies.put(resourceId, rateLimitStrategy);\n    }\n\n    public boolean isAllowed(String resourceId, int timestamp) {\n        return resourceStrategies.get(resourceId).isAllowed(timestamp);\n    }\n}\n</code></pre>"},{"location":"machine-coding/rate-limiter/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Strategy replacement resets state</li> <li>Per-resource isolation</li> <li>Accurate sliding window cleanup</li> <li>Burst control differences clearly defined</li> </ul>"},{"location":"machine-coding/rate-limiter/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Strategy Time Space Fixed Window O(1) O(1) Sliding Window O(k) O(k) <p>Where <code>k = maxRequests</code> per resource</p>"},{"location":"machine-coding/rate-limiter/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>Very common system design + LLD hybrid</li> <li> <p>Demonstrates:</p> <ul> <li>Strategy Pattern</li> <li>Trade-offs (accuracy vs performance)</li> <li>Extensibility</li> <li> <p>Easily extendable to:</p> </li> <li> <p>Token Bucket</p> </li> <li>Leaky Bucket</li> <li>Distributed Redis-based limiter</li> </ul> </li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/","title":"33. Design a Single-Queue Publish Subscribe System","text":""},{"location":"machine-coding/single-queue-pub-sub/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory publish/subscribe system with exactly one global FIFO queue.</p> <ul> <li>Multiple publishers can publish messages</li> <li>Multiple subscribers can subscribe to the same queue</li> <li>Every message is appended to a single global FIFO queue</li> <li>All active subscribers are notified on publish</li> <li> <p>Each subscriber:</p> <ul> <li>Consumes messages independently</li> <li>Processes only selected event types</li> <li>Sees only messages published while it was subscribed</li> </ul> </li> </ul> <p>\ud83d\udccc Important</p> <ul> <li>No persistence</li> <li>No retroactive delivery</li> <li>Single queue only</li> <li>Use Observer Pattern</li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#core-rules","title":"\ud83e\udde0 Core Rules","text":"<ul> <li>Subscribers filter messages by <code>eventType</code></li> <li>Ignored event types do not count as processed</li> <li> <p>A subscriber may:</p> <ul> <li>Subscribe</li> <li>Unsubscribe</li> <li>Re-subscribe with a new filter</li> <li>Processed message counts must be cumulative across sessions</li> </ul> </li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#apis-to-implement","title":"\ud83e\udde9 APIs to Implement","text":""},{"location":"machine-coding/single-queue-pub-sub/#1-addsubscriber","title":"1\ufe0f\u20e3 addSubscriber","text":"<pre><code>void addSubscriber(String subscriberId, List&lt;String&gt; eventTypesToProcess)\n</code></pre> <ul> <li>Registers a subscriber</li> <li>Re-adding replaces old filters</li> <li>No retroactive message delivery</li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#2-removesubscriber","title":"2\ufe0f\u20e3 removeSubscriber","text":"<pre><code>void removeSubscriber(String subscriberId)\n</code></pre> <ul> <li>Stops further message delivery</li> <li>Preserves processed count so far</li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#3-sendmessage","title":"3\ufe0f\u20e3 sendMessage","text":"<pre><code>void sendMessage(String eventType, String message)\n</code></pre> <ul> <li>Appends message to the global FIFO queue</li> <li>Notifies all active subscribers</li> <li>Each subscriber decides whether to process or ignore</li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#4-countprocessedmessages","title":"4\ufe0f\u20e3 countProcessedMessages","text":"<pre><code>int countProcessedMessages(String subscriberId)\n</code></pre> <ul> <li>Returns total messages actually processed</li> <li> <p>Includes counts from:</p> <ul> <li>Previous subscriptions</li> <li>Current active session (if any)</li> </ul> </li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#example-walkthrough","title":"\ud83d\udcd8 Example Walkthrough","text":"<pre><code>sendMessage(\"ORDER\", \"pre-1\");   // no subscribers \u2192 nobody processes\n\naddSubscriber(\"S1\", [\"ORDER\",\"PAYMENT\"]);\naddSubscriber(\"S2\", [\"PAYMENT\"]);\n\nsendMessage(\"ORDER\", \"o-1\");     // S1 processes, S2 ignores\n\naddSubscriber(\"S3\", [\"SHIPMENT\"]);\n\nsendMessage(\"PAYMENT\", \"p-1\");   // S1 &amp; S2 process\n\nsendMessage(\"SHIPMENT\", \"s-1\");  // S3 processes\n\nremoveSubscriber(\"S2\");\n\nsendMessage(\"PAYMENT\", \"p-2\");   // only S1 processes\n\nremoveSubscriber(\"S1\");\n\nsendMessage(\"ORDER\", \"o-2\");     // nobody processes\n\naddSubscriber(\"S1\", [\"ORDER\",\"REFUND\"]);\n\nsendMessage(\"REFUND\", \"r-1\");    // S1 processes\n</code></pre>"},{"location":"machine-coding/single-queue-pub-sub/#processed-counts","title":"Processed Counts","text":"<pre><code>countProcessedMessages(\"S1\") \u2192 4\ncountProcessedMessages(\"S2\") \u2192 1\ncountProcessedMessages(\"S3\") \u2192 1\n</code></pre>"},{"location":"machine-coding/single-queue-pub-sub/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/single-queue-pub-sub/#key-components","title":"Key Components","text":"Component Responsibility <code>Message</code> Event payload with type <code>Subscriber</code> Observer interface <code>ConcreteSubscriber</code> Applies filtering + counts <code>SingleQueuePubSubSystem</code> Subject / Queue Manager"},{"location":"machine-coding/single-queue-pub-sub/#design-pattern-used","title":"\ud83e\udde0 Design Pattern Used","text":""},{"location":"machine-coding/single-queue-pub-sub/#observer-pattern","title":"\u2705 Observer Pattern","text":"<ul> <li>Subject: Queue Manager</li> <li>Observers: Subscribers</li> <li> <p>Enables:</p> <ul> <li>Loose coupling</li> <li>Dynamic subscription</li> <li>Independent consumption pace</li> </ul> </li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SingleQueuePubSubSystem {\n\n    class Message {\n        String eventType;\n        String payload;\n\n        Message(String eventType, String payload) {\n            this.eventType = eventType;\n            this.payload = payload;\n        }\n    }\n\n    interface Subscriber {\n        void onMessage(Message message);\n    }\n\n    class ConcreteSubscriber implements Subscriber {\n\n        String subscriberId;\n        Set&lt;String&gt; eventTypes;\n        int processedCount = 0;\n\n        ConcreteSubscriber(String subscriberId, List&lt;String&gt; eventTypes) {\n            this.subscriberId = subscriberId;\n            this.eventTypes = new HashSet&lt;&gt;(eventTypes);\n        }\n\n        @Override\n        public void onMessage(Message message) {\n            if (eventTypes.contains(message.eventType)) {\n                processedCount++;\n            }\n        }\n    }\n\n    private List&lt;Message&gt; queue = new ArrayList&lt;&gt;();\n    private Map&lt;String, ConcreteSubscriber&gt; activeSubscribers = new HashMap&lt;&gt;();\n    private Map&lt;String, Integer&gt; totalProcessedCounts = new HashMap&lt;&gt;();\n\n    public void addSubscriber(String subscriberId, List&lt;String&gt; eventTypesToProcess) {\n\n        if (activeSubscribers.containsKey(subscriberId)) {\n            removeSubscriber(subscriberId);\n        }\n\n        ConcreteSubscriber sub =\n                new ConcreteSubscriber(subscriberId, eventTypesToProcess);\n\n        activeSubscribers.put(subscriberId, sub);\n    }\n\n    public void removeSubscriber(String subscriberId) {\n\n        ConcreteSubscriber sub = activeSubscribers.remove(subscriberId);\n        if (sub == null) return;\n\n        int prev = totalProcessedCounts.getOrDefault(subscriberId, 0);\n        totalProcessedCounts.put(subscriberId, prev + sub.processedCount);\n    }\n\n    public void sendMessage(String eventType, String message) {\n\n        Message msg = new Message(eventType, message);\n        queue.add(msg);\n\n        for (ConcreteSubscriber sub : activeSubscribers.values()) {\n            sub.onMessage(msg);\n        }\n    }\n\n    public int countProcessedMessages(String subscriberId) {\n\n        int total = totalProcessedCounts.getOrDefault(subscriberId, 0);\n\n        ConcreteSubscriber active = activeSubscribers.get(subscriberId);\n        if (active != null) {\n            total += active.processedCount;\n        }\n\n        return total;\n    }\n}\n</code></pre>"},{"location":"machine-coding/single-queue-pub-sub/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Late subscribers (no retroactive delivery)</li> <li>Event type filtering</li> <li>Unsubscribe immediately stops processing</li> <li>Re-subscribe with new filters</li> <li>Messages with no eligible subscribers</li> <li>Cumulative processed counts</li> </ul>"},{"location":"machine-coding/single-queue-pub-sub/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time sendMessage O(S) addSubscriber O(1) removeSubscriber O(1) countProcessedMessages O(1) <p>Where <code>S</code> = active subscribers</p>"},{"location":"machine-coding/single-queue-pub-sub/#interview-readiness-notes","title":"\u2705 Interview Readiness Notes","text":"<ul> <li>Clean Observer usage</li> <li>Deterministic behavior</li> <li> <p>Easy to extend:</p> <ul> <li>Async consumers</li> <li>Thread safety</li> <li>Dead-letter queues</li> <li> <p>Frequently asked in:</p> </li> <li> <p>LLD rounds</p> </li> <li>System fundamentals</li> <li>Event-driven design</li> </ul> </li> </ul>"},{"location":"machine-coding/snake-game/","title":"Design Snake Game","text":""},{"location":"machine-coding/snake-game/#problem-statement","title":"Problem Statement","text":"<p>Design a Snake game simulator played on a 2D grid.</p> <ul> <li>The grid has fixed dimensions <code>rows \u00d7 cols</code></li> <li>The snake starts at position <code>(0,0)</code> with length <code>1</code></li> <li> <p>The snake moves one step at a time in one of the directions:</p> <ul> <li><code>\"U\"</code> (up), <code>\"D\"</code> (down), <code>\"L\"</code> (left), <code>\"R\"</code> (right)</li> <li>Food positions are provided in advance and appear sequentially</li> <li> <p>When the snake eats food:</p> </li> <li> <p>Snake length increases by 1</p> </li> <li>Score increases by 1</li> <li> <p>The game ends if:</p> </li> <li> <p>The snake hits the wall</p> </li> <li>The snake hits itself</li> <li>After the game ends, all further moves must return <code>-1</code></li> </ul> </li> </ul>"},{"location":"machine-coding/snake-game/#design-overview","title":"Design Overview","text":"<p>The snake is represented as an ordered sequence of cells. Each move adds a new head and conditionally removes the tail.</p>"},{"location":"machine-coding/snake-game/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li>Use a Deque to represent the snake body</li> <li>Use a HashSet for fast self-collision detection</li> <li>Use a Queue to store food positions</li> <li>Maintain a <code>gameOver</code> flag to handle post-termination behavior</li> </ul>"},{"location":"machine-coding/snake-game/#data-structures","title":"Data Structures","text":"Purpose Structure Snake body <code>Deque&lt;Cell&gt;</code> Collision check <code>HashSet&lt;Cell&gt;</code> Food sequence <code>Queue&lt;Cell&gt;</code> Game state <code>boolean gameOver</code>"},{"location":"machine-coding/snake-game/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/snake-game/#cell","title":"Cell","text":"<p>Represents a position on the grid.</p> <pre><code>class Cell {\n    int row;\n    int col;\n\n    Cell(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Cell)) return false;\n        Cell cell = (Cell) o;\n        return row == cell.row &amp;&amp; col == cell.col;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#design-patterns-used","title":"Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State management via <code>gameOver</code> flag</li> <li>Efficient simulation using Deque</li> <li>HashSet for constant-time collision detection</li> </ul>"},{"location":"machine-coding/snake-game/#java-implementation","title":"Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SnakeGame {\n\n    private int rows;\n    private int cols;\n    private Deque&lt;Cell&gt; snake;\n    private Set&lt;Cell&gt; occupied;\n    private Queue&lt;Cell&gt; foodQueue;\n    private int score;\n    private boolean gameOver;\n\n    public SnakeGame(int rows, int cols, String[] foodPositions) {\n        this.rows = rows;\n        this.cols = cols;\n        this.snake = new LinkedList&lt;&gt;();\n        this.occupied = new HashSet&lt;&gt;();\n        this.foodQueue = new LinkedList&lt;&gt;();\n        this.score = 0;\n        this.gameOver = false;\n\n        Cell start = new Cell(0, 0);\n        snake.addLast(start);\n        occupied.add(start);\n\n        for (String food : foodPositions) {\n            String[] parts = food.split(\",\");\n            foodQueue.offer(\n                new Cell(\n                    Integer.parseInt(parts[0]),\n                    Integer.parseInt(parts[1])\n                )\n            );\n        }\n    }\n\n    public int move(String direction) {\n        if (gameOver) {\n            return -1;\n        }\n\n        Cell head = snake.peekLast();\n        int r = head.row;\n        int c = head.col;\n\n        switch (direction) {\n            case \"U\": r--; break;\n            case \"D\": r++; break;\n            case \"L\": c--; break;\n            case \"R\": c++; break;\n        }\n\n        Cell newHead = new Cell(r, c);\n\n        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) {\n            gameOver = true;\n            return -1;\n        }\n\n        boolean eatsFood =\n            !foodQueue.isEmpty() &amp;&amp; foodQueue.peek().equals(newHead);\n\n        if (!eatsFood) {\n            Cell tail = snake.pollFirst();\n            occupied.remove(tail);\n        }\n\n        if (occupied.contains(newHead)) {\n            gameOver = true;\n            return -1;\n        }\n\n        snake.addLast(newHead);\n        occupied.add(newHead);\n\n        if (eatsFood) {\n            foodQueue.poll();\n            score++;\n        }\n\n        return score;\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#edge-cases-handled","title":"Edge Cases Handled","text":"<ul> <li>Wall collision</li> <li>Self collision</li> <li>Moves after game over</li> <li>No food scenario</li> <li>Snake moving into previous tail position</li> <li>Empty food list</li> </ul>"},{"location":"machine-coding/snake-game/#time-and-space-complexity","title":"Time and Space Complexity","text":""},{"location":"machine-coding/snake-game/#movedirection","title":"move(direction)","text":"<ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(rows \u00d7 cols)</li> </ul>"},{"location":"machine-coding/snake-game/#example","title":"Example","text":"<pre><code>SnakeGame game = new SnakeGame(2, 2, new String[]{});\n\ngame.move(\"R\"); // 0\ngame.move(\"D\"); // 0\ngame.move(\"R\"); // -1\ngame.move(\"U\"); // -1\n</code></pre>"},{"location":"machine-coding/snake-game/#interview-notes","title":"Interview Notes","text":"<ul> <li>Always remove the tail before checking self-collision</li> <li>Persist game-over state</li> <li>Deque + HashSet is the optimal combination</li> <li>Follow inclusive boundary rules strictly</li> </ul> <p>If you want, next I can:</p> <ul> <li>Add this to <code>mkdocs.yml</code> navigation</li> <li>Convert Text Editor (Undo/Redo) to the same format</li> <li>Create a reusable LLD markdown template</li> <li>Refactor code for interview-grade clarity</li> </ul> <p>Just tell me what\u2019s next.</p>"},{"location":"machine-coding/spreadsheet-flyweight/","title":"25. Design a Spreadsheet (Excel-like) \u2014 Flyweight Optimized","text":""},{"location":"machine-coding/spreadsheet-flyweight/#problem-statement-recap","title":"\ud83d\udcdc Problem Statement (Recap)","text":"<p>We are building an in-memory spreadsheet where:</p> <ul> <li>Each cell stores text + style</li> <li> <p>Styles include:</p> <ul> <li>font name</li> <li>font size</li> <li>bold</li> <li>italic</li> <li> <p>Spreadsheet supports:</p> </li> <li> <p>Inserting rows</p> </li> <li>Inserting columns</li> <li>Setting &amp; getting cell values</li> <li>Single-threaded environment</li> </ul> </li> </ul>"},{"location":"machine-coding/spreadsheet-flyweight/#problem-with-naive-design","title":"\u2757 Problem With Naive Design","text":"<p>In a large spreadsheet:</p> <ul> <li>Millions of cells</li> <li>Thousands of cells share the same style</li> </ul> <p>\u274c Naive approach creates duplicate style objects \u27a1\ufe0f Massive memory waste</p>"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-pattern-solution","title":"\u2705 Flyweight Pattern Solution","text":""},{"location":"machine-coding/spreadsheet-flyweight/#core-idea","title":"Core Idea","text":"<p>Separate intrinsic (shared) state from extrinsic (per-cell) state</p> State Type Stored Where Style (font, size, bold, italic) Shared Flyweight Text + position Individual Cell"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-architecture","title":"\ud83e\udde0 Flyweight Architecture","text":"<pre><code>Cell \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba StyleFlyweight\n                 \u25b2\n                 \u2502\n          StyleFlyweightFactory\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#data-model","title":"\ud83e\uddf1 Data Model","text":""},{"location":"machine-coding/spreadsheet-flyweight/#style-flyweight-shared","title":"\ud83c\udfa8 Style Flyweight (Shared)","text":"<pre><code>class StyleFlyweight {\n    final String fontName;\n    final int fontSize;\n    final boolean isBold;\n    final boolean isItalic;\n\n    StyleFlyweight(String fontName, int fontSize,\n                   boolean isBold, boolean isItalic) {\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-factory","title":"\ud83c\udfed Flyweight Factory","text":"<pre><code>class StyleFactory {\n\n    private static final Map&lt;String, StyleFlyweight&gt; cache = new HashMap&lt;&gt;();\n\n    public static StyleFlyweight getStyle(String fontName, int fontSize,\n                                          boolean isBold, boolean isItalic) {\n\n        String key = fontName + \"|\" + fontSize + \"|\" + isBold + \"|\" + isItalic;\n\n        if (!cache.containsKey(key)) {\n            cache.put(key, new StyleFlyweight(\n                    fontName, fontSize, isBold, isItalic\n            ));\n        }\n        return cache.get(key);\n    }\n}\n</code></pre> <p>\u2714 Ensures only one instance per unique style</p>"},{"location":"machine-coding/spreadsheet-flyweight/#cell-extrinsic-state-only","title":"\ud83e\udde9 Cell (Extrinsic State Only)","text":"<pre><code>class Cell {\n    String text;\n    StyleFlyweight style;\n\n    Cell(String text, StyleFlyweight style) {\n        this.text = text;\n        this.style = style;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#spreadsheet-implementation-flyweight","title":"\ud83c\udfd7\ufe0f Spreadsheet Implementation (Flyweight)","text":"<pre><code>import java.util.*;\n\npublic class Spreadsheet {\n\n    private List&lt;List&lt;Cell&gt;&gt; sheet;\n    private int rows;\n    private int cols;\n\n    // ---------- Initialization ----------\n    public Spreadsheet() {\n        rows = 5;\n        cols = 5;\n        sheet = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; rows; i++) {\n            sheet.add(new ArrayList&lt;&gt;(Collections.nCopies(cols, null)));\n        }\n    }\n\n    // ---------- Add Row ----------\n    public void addRow(int index) {\n        if (index &lt; 0 || index &gt; rows) return;\n\n        sheet.add(index, new ArrayList&lt;&gt;(Collections.nCopies(cols, null)));\n        rows++;\n    }\n\n    // ---------- Add Column ----------\n    public void addColumn(int index) {\n        if (index &lt; 0 || index &gt; cols) return;\n\n        for (List&lt;Cell&gt; row : sheet) {\n            row.add(index, null);\n        }\n        cols++;\n    }\n\n    // ---------- Add / Replace Entry ----------\n    public void addEntry(int row, int col, String text,\n                         String fontName, int fontSize,\n                         boolean isBold, boolean isItalic) {\n\n        if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols) return;\n\n        StyleFlyweight style =\n                StyleFactory.getStyle(fontName, fontSize, isBold, isItalic);\n\n        sheet.get(row).set(col, new Cell(text, style));\n    }\n\n    // ---------- Get Entry ----------\n    public String getEntry(int row, int col) {\n        if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols) return \"\";\n\n        Cell cell = sheet.get(row).get(col);\n        if (cell == null) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(cell.text)\n          .append(\"-\")\n          .append(cell.style.fontName)\n          .append(\"-\")\n          .append(cell.style.fontSize);\n\n        if (cell.style.isBold) sb.append(\"-b\");\n        if (cell.style.isItalic) sb.append(\"-i\");\n\n        return sb.toString();\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#example","title":"\ud83e\uddea Example","text":"<pre><code>addEntry(0, 0, \"hello\", \"tahoma\", 24, true, false);\naddEntry(1, 1, \"world\", \"tahoma\", 24, true, false);\n</code></pre> <p>\u2714 Both cells share the same StyleFlyweight instance</p>"},{"location":"machine-coding/spreadsheet-flyweight/#memory-impact","title":"\ud83d\udca1 Memory Impact","text":"Design Style Objects Naive rows \u00d7 cols Flyweight unique styles only <p>\ud83d\udcc9 Huge memory reduction</p>"},{"location":"machine-coding/spreadsheet-flyweight/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Flyweight Pattern \u2192 style sharing</li> <li>Factory Pattern \u2192 controlled creation</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> </ul>"},{"location":"machine-coding/spreadsheet-flyweight/#interview-explanation-perfect-answer","title":"\ud83c\udfaf Interview Explanation (Perfect Answer)","text":"<p>\u201cEach cell stores only text and a reference to a shared immutable style object created via a Flyweight factory, drastically reducing memory usage.\u201d</p>"},{"location":"machine-coding/spreadsheet-flyweight/#repo-structure-recommendation","title":"\ud83d\udcc2 Repo Structure Recommendation","text":""},{"location":"machine-coding/spreadsheet/","title":"25. Design a Spreadsheet (Excel-like)","text":""},{"location":"machine-coding/spreadsheet/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory spreadsheet system similar to Microsoft Excel.</p> <p>The spreadsheet supports:</p> <ul> <li>Dynamic insertion of rows and columns</li> <li>Each cell storing text + style</li> <li>Deterministic access to any cell</li> <li>Single-threaded execution</li> </ul>"},{"location":"machine-coding/spreadsheet/#initialization-rules","title":"\ud83d\udd22 Initialization Rules","text":"<ul> <li>Initial size: 5 rows \u00d7 5 columns</li> <li>Rows and columns are 0-indexed</li> <li>All cells start empty</li> <li>Empty cell returns an empty string</li> </ul>"},{"location":"machine-coding/spreadsheet/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/spreadsheet/#core-ideas","title":"Core Ideas","text":"<ul> <li>Spreadsheet modeled as a 2D dynamic structure</li> <li> <p>Each cell encapsulates:</p> <ul> <li>text</li> <li>font name</li> <li>font size</li> <li>bold / italic flags</li> <li>Insertions shift existing rows/columns automatically</li> </ul> </li> </ul>"},{"location":"machine-coding/spreadsheet/#data-model","title":"\ud83e\uddf1 Data Model","text":""},{"location":"machine-coding/spreadsheet/#cell-structure","title":"Cell Structure","text":"<pre><code>class Cell {\n    String text;\n    String fontName;\n    int fontSize;\n    boolean isBold;\n    boolean isItalic;\n\n    Cell(String text, String fontName, int fontSize,\n         boolean isBold, boolean isItalic) {\n        this.text = text;\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet/#complete-java-implementation","title":"\ud83c\udfd7\ufe0f Complete Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Spreadsheet {\n\n    private List&lt;List&lt;Cell&gt;&gt; sheet;\n    private int rows;\n    private int cols;\n\n    // ---------- Initialization ----------\n    public Spreadsheet() {\n        rows = 5;\n        cols = 5;\n        sheet = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; rows; i++) {\n            List&lt;Cell&gt; row = new ArrayList&lt;&gt;(Collections.nCopies(cols, null));\n            sheet.add(row);\n        }\n    }\n\n    // ---------- Add Row ----------\n    public void addRow(int index) {\n        if (index &lt; 0 || index &gt; rows) return;\n\n        List&lt;Cell&gt; newRow = new ArrayList&lt;&gt;(Collections.nCopies(cols, null));\n        sheet.add(index, newRow);\n        rows++;\n    }\n\n    // ---------- Add Column ----------\n    public void addColumn(int index) {\n        if (index &lt; 0 || index &gt; cols) return;\n\n        for (List&lt;Cell&gt; row : sheet) {\n            row.add(index, null);\n        }\n        cols++;\n    }\n\n    // ---------- Add / Replace Entry ----------\n    public void addEntry(int row, int column, String text,\n                         String fontName, int fontSize,\n                         boolean isBold, boolean isItalic) {\n\n        if (row &lt; 0 || row &gt;= rows || column &lt; 0 || column &gt;= cols) return;\n\n        sheet.get(row).set(\n                column,\n                new Cell(text, fontName, fontSize, isBold, isItalic)\n        );\n    }\n\n    // ---------- Get Entry ----------\n    public String getEntry(int row, int column) {\n        if (row &lt; 0 || row &gt;= rows || column &lt; 0 || column &gt;= cols) {\n            return \"\";\n        }\n\n        Cell cell = sheet.get(row).get(column);\n        if (cell == null) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(cell.text)\n          .append(\"-\")\n          .append(cell.fontName)\n          .append(\"-\")\n          .append(cell.fontSize);\n\n        if (cell.isBold) sb.append(\"-b\");\n        if (cell.isItalic) sb.append(\"-i\");\n\n        return sb.toString();\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet/#method-behavior-summary","title":"\ud83d\udccc Method Behavior Summary","text":""},{"location":"machine-coding/spreadsheet/#addrowindex","title":"addRow(index)","text":"<ul> <li>Inserts a new empty row at the given index</li> <li>Existing rows shift downward</li> </ul>"},{"location":"machine-coding/spreadsheet/#addcolumnindex","title":"addColumn(index)","text":"<ul> <li>Inserts a new empty column at the given index</li> <li>Existing columns shift right</li> </ul>"},{"location":"machine-coding/spreadsheet/#addentryrow-column","title":"addEntry(row, column, ...)","text":"<ul> <li>Creates or replaces a cell</li> <li>Overwrites any existing cell at the location</li> </ul>"},{"location":"machine-coding/spreadsheet/#getentryrow-column","title":"getEntry(row, column)","text":"<ul> <li>Returns formatted string:</li> </ul> <p><pre><code>text-fontName-fontSize[-b][-i]\n</code></pre> * Returns empty string if cell is empty</p>"},{"location":"machine-coding/spreadsheet/#example-walkthrough","title":"\u2705 Example Walkthrough","text":"<pre><code>addRow(5);\naddEntry(5, 0, \"hello\", \"tahoma\", 24, true, false);\ngetEntry(5, 0); \n// \"hello-tahoma-24-b\"\n\naddColumn(2);\naddEntry(0, 1, \"x\", \"calibri\", 10, false, true);\ngetEntry(0, 1);\n// \"x-calibri-10-i\"\n</code></pre>"},{"location":"machine-coding/spreadsheet/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addRow O(columns) addColumn O(rows) addEntry O(1) getEntry O(1) Space O(rows \u00d7 columns)"},{"location":"machine-coding/spreadsheet/#design-patterns-interview-bonus","title":"\ud83e\udde0 Design Patterns (Interview Bonus)","text":"<ul> <li>Flyweight Pattern   Share identical style objects to reduce memory usage</li> <li>Command Pattern   Enables undo/redo functionality</li> <li>MVC Architecture   Separate data model from UI rendering</li> </ul>"},{"location":"machine-coding/spreadsheet/#interview-one-liner","title":"\ud83c\udfaf Interview One-Liner","text":"<p>\u201cI modeled the spreadsheet as a dynamic 2D structure with deterministic row/column shifting and constant-time cell access.\u201d</p>"},{"location":"machine-coding/text-editor-word-processor/","title":"\ud83d\udcdd Design a Text Editor / Word Processor (Microsoft Word)","text":""},{"location":"machine-coding/text-editor-word-processor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor / word processor similar to Microsoft Word or WordPad.</p> <p>The document:</p> <ul> <li>Has any number of rows</li> <li>Each row has any number of columns</li> <li>Each character has its own style</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#character-style-attributes","title":"Character Style Attributes","text":"<ul> <li>Font Name</li> <li>Font Size</li> <li>Bold</li> <li>Italic</li> </ul> <p>The system must support:</p> <ul> <li>Adding characters</li> <li>Deleting characters</li> <li>Reading rows</li> <li>Fetching style of a specific character</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#key-design-decisions","title":"\ud83e\udde0 Key Design Decisions","text":""},{"location":"machine-coding/text-editor-word-processor/#1-row-based-storage","title":"1\ufe0f\u20e3 Row-based storage","text":"<ul> <li>Each row is stored independently</li> <li>Rows are dynamically created</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#2-character-level-styling","title":"2\ufe0f\u20e3 Character-level styling","text":"<ul> <li>Each character is wrapped in a <code>StyledChar</code> object</li> <li>Style stays bound to the character even after shifts</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#3-insert-delete-via-shifting","title":"3\ufe0f\u20e3 Insert &amp; Delete via shifting","text":"<ul> <li>Insert \u2192 shift characters to the right</li> <li>Delete \u2192 shift characters to the left</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":"<pre><code>Document\n \u2514\u2500\u2500 List&lt;Row&gt;\n      \u2514\u2500\u2500 List&lt;StyledChar&gt;\n\nStyledChar\n \u251c\u2500\u2500 char value\n \u251c\u2500\u2500 fontName\n \u251c\u2500\u2500 fontSize\n \u251c\u2500\u2500 isBold\n \u2514\u2500\u2500 isItalic\n</code></pre>"},{"location":"machine-coding/text-editor-word-processor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Solution {\n\n    // Helper is provided by the platform\n    private Helper09 helper;\n\n    // Each row is a list of styled characters\n    private List&lt;List&lt;StyledChar&gt;&gt; document = new ArrayList&lt;&gt;();\n\n    // ---------------- init ----------------\n    public void init(Helper09 helper) {\n        this.helper = helper;\n    }\n\n    // ---------------- Styled Character ----------------\n    static class StyledChar {\n        char ch;\n        String fontName;\n        int fontSize;\n        boolean bold;\n        boolean italic;\n\n        StyledChar(char ch, String fontName, int fontSize, boolean bold, boolean italic) {\n            this.ch = ch;\n            this.fontName = fontName;\n            this.fontSize = fontSize;\n            this.bold = bold;\n            this.italic = italic;\n        }\n\n        String styleString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(ch)\n              .append(\"-\")\n              .append(fontName)\n              .append(\"-\")\n              .append(fontSize);\n\n            if (bold) sb.append(\"-b\");\n            if (italic) sb.append(\"-i\");\n\n            return sb.toString();\n        }\n    }\n\n    // ---------------- addCharacter ----------------\n    public void addCharacter(\n            int row, int column, char ch,\n            String fontName, int fontSize,\n            boolean isBold, boolean isItalic) {\n\n        // Ensure enough rows exist\n        while (document.size() &lt;= row) {\n            document.add(new ArrayList&lt;&gt;());\n        }\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        StyledChar newChar = new StyledChar(ch, fontName, fontSize, isBold, isItalic);\n\n        // Insert or append\n        if (column &gt;= currentRow.size()) {\n            currentRow.add(newChar);\n        } else {\n            currentRow.add(column, newChar);\n        }\n    }\n\n    // ---------------- getStyle ----------------\n    public String getStyle(int row, int col) {\n        if (row &gt;= document.size()) return \"\";\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        if (col &gt;= currentRow.size()) return \"\";\n\n        return currentRow.get(col).styleString();\n    }\n\n    // ---------------- readLine ----------------\n    public String readLine(int row) {\n        if (row &gt;= document.size()) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        for (StyledChar sc : document.get(row)) {\n            sb.append(sc.ch);\n        }\n        return sb.toString();\n    }\n\n    // ---------------- deleteCharacter ----------------\n    public boolean deleteCharacter(int row, int col) {\n        if (row &gt;= document.size()) return false;\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        if (col &gt;= currentRow.size()) return false;\n\n        currentRow.remove(col);\n        return true;\n    }\n}\n</code></pre>"},{"location":"machine-coding/text-editor-word-processor/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Adding characters beyond current rows</li> <li>Adding characters beyond current column length</li> <li>Reading empty rows</li> <li>Deleting non-existing characters</li> <li>Style preserved correctly after insert/delete shifts</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Complexity addCharacter O(n) (row shift) deleteCharacter O(n) (row shift) getStyle O(1) readLine O(n) <p>Space Complexity: O(total characters)</p>"},{"location":"machine-coding/text-editor-word-processor/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>This is a Flyweight-friendly design (styles can be shared later)</li> <li>Clean separation of data + behavior</li> <li> <p>Easily extensible for:</p> <ul> <li>Undo / Redo</li> <li>Copy / Paste</li> <li>Rich formatting blocks</li> <li>Paragraph styles</li> </ul> </li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#next-enhancements-optional","title":"\ud83d\udccc Next Enhancements (Optional)","text":"<ul> <li>Undo / Redo using Command pattern</li> <li>Cursor abstraction</li> <li>Range styling (apply style to multiple characters)</li> <li>Paragraph &amp; alignment support</li> </ul>"},{"location":"machine-coding/text-editor/","title":"Design a Text Editor with Undo &amp; Redo","text":""},{"location":"machine-coding/text-editor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor that:</p> <ul> <li>Stores text row-wise (line by line)</li> <li>Supports insert and delete operations on a single row</li> <li>Supports Undo and Redo</li> <li>Maintains edit history correctly</li> <li>Does NOT remove empty rows</li> </ul> <p>Each operation modifies exactly one row.</p>"},{"location":"machine-coding/text-editor/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/text-editor/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Insert text at a given row and column</li> <li>Delete text from a given row and column range</li> <li>Undo the most recent change</li> <li>Redo the most recently undone change</li> <li>Read the content of a row at any time</li> </ul>"},{"location":"machine-coding/text-editor/#key-observations","title":"Key Observations","text":"<ul> <li>Undo/Redo works best with Command Pattern</li> <li>Each edit operation should know how to execute and undo</li> <li>Redo history must be cleared after any new edit</li> </ul>"},{"location":"machine-coding/text-editor/#design-patterns-principles-used","title":"\ud83c\udfd7\ufe0f Design Patterns &amp; Principles Used","text":"<ul> <li>Command Pattern \u2192 Encapsulates edit operations</li> <li>Stack-based Undo/Redo</li> <li>Single Responsibility Principle</li> <li>Encapsulation</li> </ul>"},{"location":"machine-coding/text-editor/#data-model","title":"\ud83d\uddc2\ufe0f Data Model","text":"<pre><code>TextEditor\n\u251c\u2500\u2500 List&lt;StringBuilder&gt; rows\n\u251c\u2500\u2500 Stack&lt;Command&gt; undoStack\n\u251c\u2500\u2500 Stack&lt;Command&gt; redoStack\n\nCommand (interface)\n\u251c\u2500\u2500 execute()\n\u251c\u2500\u2500 undo()\n\nAddTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 column\n\u251c\u2500\u2500 text\n\nDeleteTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 startColumn\n\u251c\u2500\u2500 deletedText\n</code></pre>"},{"location":"machine-coding/text-editor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class TextEditor {\n\n    private final List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();\n    private final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();\n    private final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();\n\n    /* ==================== PUBLIC APIs ==================== */\n\n    public void addText(int row, int column, String text) {\n        ensureRowExists(row);\n\n        Command cmd = new AddTextCommand(row, column, text);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void deleteText(int row, int startColumn, int length) {\n        Command cmd = new DeleteTextCommand(row, startColumn, length);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void undo() {\n        if (undoStack.isEmpty()) return;\n\n        Command cmd = undoStack.pop();\n        cmd.undo();\n        redoStack.push(cmd);\n    }\n\n    public void redo() {\n        if (redoStack.isEmpty()) return;\n\n        Command cmd = redoStack.pop();\n        cmd.execute();\n        undoStack.push(cmd);\n    }\n\n    public String readLine(int row) {\n        return rows.get(row).toString();\n    }\n\n    /* ==================== INTERNAL HELPERS ==================== */\n\n    private void ensureRowExists(int row) {\n        while (rows.size() &lt;= row) {\n            rows.add(new StringBuilder());\n        }\n    }\n\n    /* ==================== COMMAND INTERFACE ==================== */\n\n    private interface Command {\n        void execute();\n        void undo();\n    }\n\n    /* ==================== ADD TEXT COMMAND ==================== */\n\n    private class AddTextCommand implements Command {\n        private final int row;\n        private final int column;\n        private final String text;\n\n        AddTextCommand(int row, int column, String text) {\n            this.row = row;\n            this.column = column;\n            this.text = text;\n        }\n\n        @Override\n        public void execute() {\n            rows.get(row).insert(column, text);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).delete(column, column + text.length());\n        }\n    }\n\n    /* ==================== DELETE TEXT COMMAND ==================== */\n\n    private class DeleteTextCommand implements Command {\n        private final int row;\n        private final int startColumn;\n        private final int length;\n        private String deletedText;\n\n        DeleteTextCommand(int row, int startColumn, int length) {\n            this.row = row;\n            this.startColumn = startColumn;\n            this.length = length;\n        }\n\n        @Override\n        public void execute() {\n            StringBuilder sb = rows.get(row);\n            deletedText = sb.substring(startColumn, startColumn + length);\n            sb.delete(startColumn, startColumn + length);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).insert(startColumn, deletedText);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/","title":"Design a Tic-Tac-Toe Game (NxN)","text":""},{"location":"machine-coding/tic-tac-toe/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a class <code>TicTacGame</code> that simulates a Tic-Tac-Toe game played on an m \u00d7 m board between two players.</p>"},{"location":"machine-coding/tic-tac-toe/#rules","title":"Rules","text":"<ul> <li>Players take turns placing marks on empty cells.</li> <li>Player 1 uses A, Player 2 uses B.</li> <li>The first player to place m consecutive symbols in:</li> <li>a row</li> <li>a column</li> <li>a diagonal   wins the game.</li> <li>Once a player wins, no further moves are allowed.</li> <li>Every subsequent move must return the same winner.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/tic-tac-toe/#key-observations","title":"Key Observations","text":"<ul> <li>Full board storage is not required.</li> <li>Each move affects:</li> <li>one row</li> <li>one column</li> <li>possibly two diagonals</li> <li>Winning can be checked in O(1) time.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#data-structures-used","title":"\ud83c\udfd7\ufe0f Data Structures Used","text":"Structure Purpose <code>int[] rows</code> Row-wise score tracking <code>int[] cols</code> Column-wise score tracking <code>int diag</code> Main diagonal score <code>int antiDiag</code> Anti-diagonal score <code>boolean gameOver</code> Locks the game after win <code>int winner</code> Stores the winning player"},{"location":"machine-coding/tic-tac-toe/#scoring-technique","title":"Scoring Technique","text":"<ul> <li>Player 1 \u2192 <code>+1</code></li> <li>Player 2 \u2192 <code>-1</code></li> <li>If absolute value reaches <code>m</code>, that player wins.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State Management</li> <li>Optimized Win Detection</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class TicTacGame {\n\n    private int m;\n    private int[] rows;\n    private int[] cols;\n    private int diag;\n    private int antiDiag;\n    private boolean gameOver;\n    private int winner;\n\n    public TicTacGame(int m) {\n        this.m = m;\n        this.rows = new int[m];\n        this.cols = new int[m];\n        this.diag = 0;\n        this.antiDiag = 0;\n        this.gameOver = false;\n        this.winner = 0;\n    }\n\n    /**\n     * @param row    row index\n     * @param col    column index\n     * @param player 1 or 2\n     * @return 0 = no winner, 1 = player 1 wins, 2 = player 2 wins\n     */\n    public int doMove(int row, int col, int player) {\n\n        // If game already ended, always return winner\n        if (gameOver) {\n            return winner;\n        }\n\n        int val = (player == 1) ? 1 : -1;\n\n        rows[row] += val;\n        cols[col] += val;\n\n        if (row == col) {\n            diag += val;\n        }\n\n        if (row + col == m - 1) {\n            antiDiag += val;\n        }\n\n        if (Math.abs(rows[row]) == m ||\n            Math.abs(cols[col]) == m ||\n            Math.abs(diag) == m ||\n            Math.abs(antiDiag) == m) {\n\n            gameOver = true;\n            winner = player;\n            return player;\n        }\n\n        return 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Winning by row, column, or diagonal</li> <li>Game lock after win</li> <li>Repeated moves return same winner</li> <li>Works for large boards (<code>m \u2264 200</code>)</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Space <code>doMove()</code> O(1) O(m)"},{"location":"machine-coding/tic-tac-toe/#example","title":"\ud83e\uddea Example","text":"<pre><code>TicTacGame game = new TicTacGame(2);\n\ngame.doMove(0, 1, 1); // 0\ngame.doMove(0, 0, 2); // 0\ngame.doMove(1, 1, 1); // 1 (Player 1 wins)\ngame.doMove(1, 0, 2); // 1 (Winner persists)\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#interview-notes","title":"\u2705 Interview Notes","text":"<ul> <li>Classic LLD + algorithm optimization problem</li> <li>Demonstrates clean state handling</li> <li>Shows ability to avoid brute-force board scanning</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Undo / Redo support</li> <li>Move history tracking</li> <li>UI rendering</li> <li>Multiplayer support</li> </ul>"},{"location":"machine-coding/train-platform-management/","title":"32. Design a Train Platform Management System","text":""},{"location":"machine-coding/train-platform-management/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a system to assign trains to platforms in a railway station while supporting time-based queries.</p>"},{"location":"machine-coding/train-platform-management/#core-requirements","title":"Core Requirements","text":"<ul> <li>At any time, only one train can occupy a platform</li> <li>Platforms are numbered 0 to (platformCount \u2212 1)</li> <li>Trains may need to wait (delay) if no platform is immediately available</li> <li>Assignment must be deterministic and optimal</li> </ul>"},{"location":"machine-coding/train-platform-management/#rules-constraints","title":"\ud83e\udde0 Rules &amp; Constraints","text":""},{"location":"machine-coding/train-platform-management/#platform-rules","title":"Platform Rules","text":"<ul> <li><code>1 \u2264 platformCount \u2264 20</code></li> <li>Arrival and departure times are inclusive</li> <li>If a train departs at time <code>t</code>, the platform becomes free at <code>t + 1</code></li> </ul>"},{"location":"machine-coding/train-platform-management/#delay-rules","title":"Delay Rules","text":"<ul> <li> <p>If no platform is free at arrival time:</p> <ul> <li>Train must wait</li> <li>Delay = earliest free time \u2212 arrivalTime</li> <li> <p>Choose the platform with:</p> </li> <li> <p>Minimum delay</p> </li> <li>Lowest platform index in case of tie</li> </ul> </li> </ul>"},{"location":"machine-coding/train-platform-management/#apis-to-implement","title":"\ud83e\udde9 APIs to Implement","text":""},{"location":"machine-coding/train-platform-management/#1-constructor","title":"1\ufe0f\u20e3 Constructor","text":"<pre><code>TrainPlatformManager(int platformCount)\n</code></pre>"},{"location":"machine-coding/train-platform-management/#2-assignplatform","title":"2\ufe0f\u20e3 assignPlatform","text":"<pre><code>String assignPlatform(String trainId, int arrivalTime, int waitTime)\n</code></pre> <ul> <li>Returns <code>\"platformIndex,delayTime\"</code></li> <li>Delay is <code>0</code> if train can park immediately</li> <li><code>departureTime = arrivalTime + waitTime - 1 + delay</code></li> </ul>"},{"location":"machine-coding/train-platform-management/#3-gettrainatplatform","title":"3\ufe0f\u20e3 getTrainAtPlatform","text":"<pre><code>String getTrainAtPlatform(int platformNumber, int timestamp)\n</code></pre> <ul> <li>Returns occupying <code>trainId</code></li> <li>Returns <code>\"\"</code> if platform is empty at that time</li> </ul>"},{"location":"machine-coding/train-platform-management/#4-getplatformoftrain","title":"4\ufe0f\u20e3 getPlatformOfTrain","text":"<pre><code>int getPlatformOfTrain(String trainId, int timestamp)\n</code></pre> <ul> <li>Returns platform index</li> <li>Returns <code>-1</code> if train is not on any platform at that time</li> </ul>"},{"location":"machine-coding/train-platform-management/#example-walkthrough","title":"\ud83d\udcd8 Example Walkthrough","text":"<pre><code>TrainPlatformManager mgr = new TrainPlatformManager(3);\n\n// Platforms: 0, 1, 2\n\nmgr.assignPlatform(\"T1\", 0, 5);  // \"0,0\"  occupies [0..4]\nmgr.assignPlatform(\"T2\", 2, 3);  // \"1,0\"  occupies [2..4]\nmgr.assignPlatform(\"T3\", 4, 4);  // \"2,0\"  occupies [4..7]\n\nmgr.assignPlatform(\"T4\", 5, 5);  // \"0,0\"  occupies [5..9]\n\nmgr.assignPlatform(\"T5\", 9, 1);  // \"1,0\"  occupies [9..9]\nmgr.assignPlatform(\"T6\", 9, 2);  // \"2,0\"  occupies [9..10]\n\nmgr.assignPlatform(\"T7\", 9, 3);  // \"0,1\"  delayed, occupies [10..12]\n</code></pre>"},{"location":"machine-coding/train-platform-management/#query-examples","title":"\ud83d\udd0d Query Examples","text":"<pre><code>mgr.getTrainAtPlatform(0, 4);   // \"T1\"\nmgr.getTrainAtPlatform(0, 5);   // \"T4\"\nmgr.getTrainAtPlatform(1, 9);   // \"T5\"\nmgr.getTrainAtPlatform(2, 10);  // \"T6\"\n\nmgr.getPlatformOfTrain(\"T7\", 9);   // -1\nmgr.getPlatformOfTrain(\"T7\", 10);  // 0\nmgr.getPlatformOfTrain(\"T6\", 11);  // -1\n</code></pre>"},{"location":"machine-coding/train-platform-management/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/train-platform-management/#core-entities","title":"Core Entities","text":"Entity Responsibility <code>Platform</code> Holds scheduled intervals <code>Interval</code> Represents train occupancy <code>TrainRecord</code> Fast train-centric lookup <code>TrainPlatformManager</code> Orchestrates assignment &amp; queries"},{"location":"machine-coding/train-platform-management/#design-principles-used","title":"\ud83e\udde0 Design Principles Used","text":"<ul> <li>Greedy scheduling</li> <li>Interval scanning</li> <li>Deterministic tie-breaking</li> <li>Separation of concerns</li> <li> <p>Easily extensible for:</p> <ul> <li>Priority trains</li> <li>Multiple stations</li> <li>Platform maintenance windows</li> </ul> </li> </ul>"},{"location":"machine-coding/train-platform-management/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class TrainPlatformManager {\n\n    static class Interval {\n        String trainId;\n        int start;\n        int end;\n\n        Interval(String trainId, int start, int end) {\n            this.trainId = trainId;\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    static class Platform {\n        int index;\n        List&lt;Interval&gt; schedule = new ArrayList&lt;&gt;();\n\n        Platform(int index) {\n            this.index = index;\n        }\n    }\n\n    static class TrainRecord {\n        String trainId;\n        int platform;\n        int start;\n        int end;\n\n        TrainRecord(String trainId, int platform, int start, int end) {\n            this.trainId = trainId;\n            this.platform = platform;\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    private Platform[] platforms;\n    private Map&lt;String, TrainRecord&gt; trainMap = new HashMap&lt;&gt;();\n\n    public TrainPlatformManager(int platformCount) {\n        platforms = new Platform[platformCount];\n        for (int i = 0; i &lt; platformCount; i++) {\n            platforms[i] = new Platform(i);\n        }\n    }\n\n    public String assignPlatform(String trainId, int arrivalTime, int waitTime) {\n\n        int bestPlatform = -1;\n        int bestDelay = Integer.MAX_VALUE;\n        int bestStart = -1;\n\n        for (Platform p : platforms) {\n\n            int start = earliestStart(p, arrivalTime, waitTime);\n            int delay = start - arrivalTime;\n\n            if (delay &lt; bestDelay ||\n               (delay == bestDelay &amp;&amp; p.index &lt; bestPlatform)) {\n\n                bestDelay = delay;\n                bestPlatform = p.index;\n                bestStart = start;\n            }\n        }\n\n        int end = bestStart + waitTime - 1;\n\n        Interval interval = new Interval(trainId, bestStart, end);\n        platforms[bestPlatform].schedule.add(interval);\n\n        platforms[bestPlatform].schedule.sort(\n            (a, b) -&gt; Integer.compare(a.start, b.start)\n        );\n\n        trainMap.put(trainId,\n            new TrainRecord(trainId, bestPlatform, bestStart, end));\n\n        return bestPlatform + \",\" + bestDelay;\n    }\n\n    public String getTrainAtPlatform(int platformNumber, int timestamp) {\n        Platform p = platforms[platformNumber];\n\n        for (Interval in : p.schedule) {\n            if (in.start &lt;= timestamp &amp;&amp; timestamp &lt;= in.end) {\n                return in.trainId;\n            }\n        }\n        return \"\";\n    }\n\n    public int getPlatformOfTrain(String trainId, int timestamp) {\n        TrainRecord tr = trainMap.get(trainId);\n        if (tr == null) return -1;\n\n        if (tr.start &lt;= timestamp &amp;&amp; timestamp &lt;= tr.end) {\n            return tr.platform;\n        }\n        return -1;\n    }\n\n    private int earliestStart(Platform p, int arrivalTime, int waitTime) {\n\n        int start = arrivalTime;\n\n        for (Interval in : p.schedule) {\n            int end = start + waitTime - 1;\n\n            if (end &lt; in.start) {\n                return start;\n            }\n\n            if (start &lt;= in.end) {\n                start = in.end + 1;\n            }\n        }\n\n        return start;\n    }\n}\n</code></pre>"},{"location":"machine-coding/train-platform-management/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Immediate reuse after departure</li> <li>Multiple platforms freeing at same time</li> <li>Delayed scheduling</li> <li>Exact boundary overlaps</li> <li>Train not yet started / already departed</li> </ul>"},{"location":"machine-coding/train-platform-management/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity assignPlatform O(P \u00d7 I) getTrainAtPlatform O(I) getPlatformOfTrain O(1) <p>Where:</p> <ul> <li><code>P</code> = platforms (\u2264 20)</li> <li><code>I</code> = intervals per platform</li> </ul>"},{"location":"machine-coding/train-platform-management/#interview-readiness","title":"\u2705 Interview Readiness","text":"<ul> <li>Deterministic behavior</li> <li>Clear time semantics</li> <li>Easily explainable greedy logic</li> <li>Frequently asked in Microsoft / Amazon LLD</li> </ul>"}]}
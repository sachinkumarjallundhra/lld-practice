{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Low Level Design (LLD) \u2013 Machine Coding Practice","text":"<p>This repository contains production-style LLD solutions written in Java.</p>"},{"location":"#what-youll-find","title":"\ud83d\udccc What you\u2019ll find","text":"<ul> <li>Clear problem statements</li> <li>Design patterns used (Strategy, Observer, Command, etc.)</li> <li>Clean, interview-ready Java implementations</li> <li>Edge cases &amp; complexity discussion</li> </ul>"},{"location":"#topics-covered","title":"\ud83e\udde0 Topics Covered","text":"<ul> <li>Car Rental System</li> <li>Rate Limiter</li> <li>Text Editor (Undo/Redo)</li> <li>Meeting Room Scheduler</li> <li>Publish Subscribe System</li> <li>Custom HashMap</li> <li>And more\u2026</li> </ul> <p>\ud83d\udc49 Use the left navigation to explore problems.</p>"},{"location":"machine-coding/banking-system/","title":"Design a Complete Banking System","text":""},{"location":"machine-coding/banking-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory banking system that supports:</p>"},{"location":"machine-coding/banking-system/#level-1-basic-operations","title":"Level 1 \u2013 Basic Operations","text":"<ul> <li>Create accounts</li> <li>Deposit money</li> <li>Transfer money between accounts</li> </ul>"},{"location":"machine-coding/banking-system/#level-2-ranking","title":"Level 2 \u2013 Ranking","text":"<ul> <li>Return top spenders based on outgoing transactions</li> </ul>"},{"location":"machine-coding/banking-system/#level-3-scheduled-payments","title":"Level 3 \u2013 Scheduled Payments","text":"<ul> <li>Schedule payments with cashback</li> <li>Track payment status</li> <li>Process scheduled payments</li> </ul>"},{"location":"machine-coding/banking-system/#level-4-account-merging","title":"Level 4 \u2013 Account Merging","text":"<ul> <li>Merge two accounts into one</li> <li>Preserve balances, transaction history, and scheduled payments</li> </ul> <p>All operations are timestamp-based and executed in memory.</p>"},{"location":"machine-coding/banking-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":"<p>The system models real-world banking behavior: - Each Account owns its balance, outgoing total, and scheduled payments - Payments transition through lifecycle states - Rankings are computed using outgoing totals - Merging accounts preserves financial correctness</p>"},{"location":"machine-coding/banking-system/#core-entities","title":"\ud83c\udfd7\ufe0f Core Entities","text":""},{"location":"machine-coding/banking-system/#account","title":"Account","text":"<pre><code>class Account {\n    String accountId;\n    int balance;\n    int totalOutgoing;\n    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();\n\n    Account(String accountId) {\n        this.accountId = accountId;\n        this.balance = 0;\n        this.totalOutgoing = 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#payment","title":"Payment","text":"<pre><code>class Payment {\n    String paymentId;\n    String fromAccount;\n    String toAccount;\n    int amount;\n    double cashbackPercentage;\n    int scheduledTime;\n    PaymentStatus status;\n\n    Payment(String paymentId, String from, String to, int amount,\n            double cashback, int time) {\n        this.paymentId = paymentId;\n        this.fromAccount = from;\n        this.toAccount = to;\n        this.amount = amount;\n        this.cashbackPercentage = cashback;\n        this.scheduledTime = time;\n        this.status = PaymentStatus.SCHEDULED;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#paymentstatus","title":"PaymentStatus","text":"<pre><code>enum PaymentStatus {\n    SCHEDULED,\n    PROCESSED,\n    FAILED\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#full-java-implementation","title":"\ud83d\udcbb Full Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class BankingSystem {\n\n    private Map&lt;String, Account&gt; accounts = new HashMap&lt;&gt;();\n    private int paymentCounter = 1;\n\n    // ---------------- LEVEL 1 ----------------\n\n    public boolean createAccount(String accountId, int timestamp) {\n        if (accounts.containsKey(accountId)) return false;\n        accounts.put(accountId, new Account(accountId));\n        return true;\n    }\n\n    public Optional&lt;Integer&gt; deposit(String accountId, int timestamp, int amount) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return Optional.empty();\n        acc.balance += amount;\n        return Optional.of(acc.balance);\n    }\n\n    public Optional&lt;Integer&gt; transfer(String fromId, String toId, int timestamp, int amount) {\n        Account from = accounts.get(fromId);\n        Account to = accounts.get(toId);\n\n        if (from == null || to == null || from.balance &lt; amount) {\n            return Optional.empty();\n        }\n\n        from.balance -= amount;\n        to.balance += amount;\n        from.totalOutgoing += amount;\n\n        return Optional.of(from.balance);\n    }\n\n    // ---------------- LEVEL 2 ----------------\n\n    public List&lt;String&gt; topSpenders(int timestamp, int n) {\n        List&lt;Account&gt; list = new ArrayList&lt;&gt;(accounts.values());\n\n        list.sort((a, b) -&gt; {\n            if (b.totalOutgoing != a.totalOutgoing) {\n                return b.totalOutgoing - a.totalOutgoing;\n            }\n            return a.accountId.compareTo(b.accountId);\n        });\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; Math.min(n, list.size()); i++) {\n            result.add(list.get(i).accountId);\n        }\n        return result;\n    }\n\n    // ---------------- LEVEL 3 ----------------\n\n    public void schedulePayment(String accountId, String targetAccId,\n                                int timestamp, int amount, double cashbackPercentage) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return;\n\n        String paymentId = \"PAY-\" + paymentCounter++;\n        Payment payment = new Payment(\n                paymentId, accountId, targetAccId,\n                amount, cashbackPercentage, timestamp\n        );\n\n        acc.payments.add(payment);\n    }\n\n    public void processScheduledPayments(int currentTimestamp) {\n        for (Account acc : accounts.values()) {\n            for (Payment p : acc.payments) {\n                if (p.status != PaymentStatus.SCHEDULED) continue;\n                if (p.scheduledTime &gt; currentTimestamp) continue;\n\n                Account from = accounts.get(p.fromAccount);\n                Account to = accounts.get(p.toAccount);\n\n                if (from == null || to == null || from.balance &lt; p.amount) {\n                    p.status = PaymentStatus.FAILED;\n                    continue;\n                }\n\n                from.balance -= p.amount;\n                to.balance += p.amount;\n                from.totalOutgoing += p.amount;\n\n                int cashback = (int) (p.amount * p.cashbackPercentage / 100.0);\n                from.balance += cashback;\n\n                p.status = PaymentStatus.PROCESSED;\n            }\n        }\n    }\n\n    public String getPaymentStatus(String accountId, int timestamp, String paymentId) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return \"NOT_FOUND\";\n\n        for (Payment p : acc.payments) {\n            if (p.paymentId.equals(paymentId)) {\n                return p.status.name();\n            }\n        }\n        return \"NOT_FOUND\";\n    }\n\n    // ---------------- LEVEL 4 ----------------\n\n    public void mergeAccounts(String accountId1, String accountId2) {\n        if (!accounts.containsKey(accountId1) || !accounts.containsKey(accountId2)) {\n            return;\n        }\n\n        Account a1 = accounts.get(accountId1);\n        Account a2 = accounts.get(accountId2);\n\n        a1.balance += a2.balance;\n        a1.totalOutgoing += a2.totalOutgoing;\n        a1.payments.addAll(a2.payments);\n\n        accounts.remove(accountId2);\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Aggregation (Account owns Payments)</li> <li>Domain Driven Design</li> <li>Command-style processing (timestamp-based)</li> </ul>"},{"location":"machine-coding/banking-system/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Duplicate account creation</li> <li>Insufficient balance transfers</li> <li>Payment failures</li> <li>Cashback calculation</li> <li>Ranking ties</li> <li>Merging accounts with active payments</li> </ul>"},{"location":"machine-coding/banking-system/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Create Account O(1) Deposit O(1) Transfer O(1) Top Spenders O(N log N) Schedule Payment O(1) Process Payments O(P) Merge Accounts O(P)"},{"location":"machine-coding/banking-system/#interview-notes","title":"\u2705 Interview Notes","text":"<p>Why store <code>List&lt;Payment&gt;</code> inside Account?</p> <p>Payments are owned by the account that initiates them. This simplifies lookup, merging, validation, and lifecycle management.</p>"},{"location":"machine-coding/banking-system/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Transaction history</li> <li>Interest calculation</li> <li>Account limits</li> <li>Fraud detection</li> <li>Persistent storage</li> </ul>"},{"location":"machine-coding/car-rental-system/","title":"Design a Car Rental System","text":""},{"location":"machine-coding/car-rental-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a car rental service that supports: - Full-day bookings - Kilometer-based pricing - Booking overlap checks - Early return &amp; delayed return handling</p>"},{"location":"machine-coding/car-rental-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/car-rental-system/#entities","title":"Entities","text":"<ul> <li>Car</li> <li>Order</li> <li>Trip</li> </ul>"},{"location":"machine-coding/car-rental-system/#key-rules","title":"Key Rules","text":"<ul> <li>Inclusive date ranges</li> <li>Effective end date = max(bookedTill, actualReturnDate)</li> <li>Extra kms charged beyond daily free allowance</li> </ul>"},{"location":"machine-coding/car-rental-system/#design-patterns-used","title":"\ud83c\udfd7\ufe0f Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>(Optional) Strategy for pricing</li> </ul>"},{"location":"machine-coding/car-rental-system/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class CarRentalService {\n\n    class Car {\n        String licensePlate;\n        int costPerDay;\n        int freeKmsPerDay;\n        int costPerKm;\n        List&lt;Order&gt; listOfOrder = new ArrayList&lt;&gt;();\n\n        Car(String licensePlate, int costPerDay, int freeKmsPerDay, int costPerKm) {\n            this.licensePlate = licensePlate;\n            this.costPerDay = costPerDay;\n            this.freeKmsPerDay = freeKmsPerDay;\n            this.costPerKm = costPerKm;\n        }\n    }\n\n    class Order {\n        String orderId;\n        String carLicensePlate;\n        int fromDate;\n        int tillDate;\n        Trip trip;\n\n        Order(String orderId, String carLicensePlate, int fromDate, int tillDate) {\n            this.orderId = orderId;\n            this.carLicensePlate = carLicensePlate;\n            this.fromDate = fromDate;\n            this.tillDate = tillDate;\n        }\n    }\n\n    class Trip {\n        int startOdometer;\n        Integer endOdometer;\n        Integer endDay;\n\n        Trip(int startOdometer) {\n            this.startOdometer = startOdometer;\n        }\n    }\n\n    Map&lt;String, Car&gt; cars = new HashMap&lt;&gt;();\n    Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();\n\n    public void addCar(String licensePlate, int costPerDay, int freeKmsPerDay, int costPerKm) {\n        if (cars.containsKey(licensePlate)) return;\n        cars.put(licensePlate, new Car(licensePlate, costPerDay, freeKmsPerDay, costPerKm));\n    }\n\n    public boolean bookCar(String orderId, String carLicensePlate, String fromDate, String tillDate) {\n        if (orders.containsKey(orderId)) return false;\n\n        Car car = cars.get(carLicensePlate);\n        if (car == null) return false;\n\n        int from = parseDay(fromDate);\n        int till = parseDay(tillDate);\n        if (from &gt; till) return false;\n\n        for (Order order : car.listOfOrder) {\n            int effectiveTill = order.trip != null &amp;&amp; order.trip.endDay != null\n                    ? order.trip.endDay\n                    : order.tillDate;\n            if (from &lt;= effectiveTill &amp;&amp; order.fromDate &lt;= till) {\n                return false;\n            }\n        }\n\n        Order newOrder = new Order(orderId, carLicensePlate, from, till);\n        orders.put(orderId, newOrder);\n        car.listOfOrder.add(newOrder);\n        return true;\n    }\n\n    public void startTrip(String orderId, int odometerReading) {\n        Order order = orders.get(orderId);\n        if (order == null || order.trip != null) return;\n        order.trip = new Trip(odometerReading);\n    }\n\n    public int endTrip(String orderId, int finalOdometerReading, String endDate) {\n        Order order = orders.get(orderId);\n        if (order == null || order.trip == null) return 0;\n\n        Trip trip = order.trip;\n        if (trip.endDay != null) return 0;\n\n        int endDay = parseDay(endDate);\n        trip.endDay = endDay;\n        trip.endOdometer = finalOdometerReading;\n\n        int effectiveEndDay = Math.max(order.tillDate, endDay);\n        int days = 1 + (effectiveEndDay - order.fromDate);\n\n        int tripKms = finalOdometerReading - trip.startOdometer;\n        Car car = cars.get(order.carLicensePlate);\n\n        int freeKms = days * car.freeKmsPerDay;\n        int extraKms = Math.max(0, tripKms - freeKms);\n\n        return days * car.costPerDay + extraKms * car.costPerKm;\n    }\n\n    private int parseDay(String date) {\n        return Integer.parseInt(date.substring(8));\n    }\n}\n</code></pre>"},{"location":"machine-coding/car-rental-system/#edge-cases","title":"\u26a0\ufe0f Edge Cases","text":"<ul> <li> <p>Overlapping bookings</p> </li> <li> <p>Early return</p> </li> <li> <p>Late return</p> </li> <li> <p>Same-day booking</p> </li> </ul>"},{"location":"machine-coding/car-rental-system/#complexity","title":"\u23f1\ufe0f Complexity","text":"<ul> <li> <p>Booking: O(n) per car</p> </li> <li> <p>End Trip: O(1)</p> </li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/","title":"\ud83c\udfc6 Design a Leaderboard for Fantasy Teams","text":""},{"location":"machine-coding/fantasy-leaderboard/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory leaderboard for a fantasy sports application.</p> <ul> <li>Each user creates exactly one team</li> <li>A team consists of one or more players</li> <li>Players gain or lose points during a live match</li> <li>A user\u2019s score is the sum of scores of all players in their team</li> <li>The system must support Top-K leaderboard queries</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#rules-constraints","title":"\ud83d\udccc Rules &amp; Constraints","text":"<ul> <li>Each user has exactly one team</li> <li>A player can belong to multiple users\u2019 teams</li> <li>Initial user score is 0</li> <li>Player score updates are deltas (positive or negative)</li> <li> <p>Leaderboard sorting:</p> <ol> <li>Total score (descending)</li> <li>UserId (lexicographically ascending)</li> </ol> </li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#key-design-insight","title":"\ud83e\udde0 Key Design Insight","text":"<p>This is a many-to-many relationship:</p> <ul> <li>One player \u2192 many users</li> <li>One user \u2192 many players</li> </ul> <p>Whenever a player\u2019s score changes, all dependent users must be updated immediately.</p> <p>This naturally fits the Observer Design Pattern.</p>"},{"location":"machine-coding/fantasy-leaderboard/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/fantasy-leaderboard/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/fantasy-leaderboard/#1-player","title":"1\ufe0f\u20e3 Player","text":"<ul> <li>Maintains current score</li> <li>Knows which users depend on it</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#2-user","title":"2\ufe0f\u20e3 User","text":"<ul> <li>Represents a fantasy team</li> <li>Observes players</li> <li>Maintains total team score</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#3-leaderboard","title":"3\ufe0f\u20e3 Leaderboard","text":"<ul> <li>Maintains sorted users</li> <li>Supports Top-K queries efficiently</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":""},{"location":"machine-coding/fantasy-leaderboard/#observer-pattern","title":"\u2705 Observer Pattern","text":"<ul> <li><code>Player</code> = Subject</li> <li><code>User</code> = Observer</li> <li>Player score updates notify all users automatically</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#sorted-set-treeset","title":"\u2705 Sorted Set (TreeSet)","text":"<ul> <li>Keeps leaderboard always sorted</li> <li>Ensures fast Top-K retrieval</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#data-structures-used","title":"\ud83e\uddf1 Data Structures Used","text":"Structure Purpose <code>Map&lt;String, Player&gt;</code> Player registry <code>Map&lt;String, User&gt;</code> User registry <code>TreeSet&lt;User&gt;</code> Sorted leaderboard <code>List&lt;PlayerObserver&gt;</code> Observers per player"},{"location":"machine-coding/fantasy-leaderboard/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":""},{"location":"machine-coding/fantasy-leaderboard/#player","title":"Player","text":"<pre><code>class Player {\n    String playerId;\n    int score = 0;\n    List&lt;PlayerObserver&gt; observers = new ArrayList&lt;&gt;();\n\n    Player(String playerId) {\n        this.playerId = playerId;\n    }\n\n    void addObserver(PlayerObserver observer) {\n        observers.add(observer);\n    }\n\n    void addScore(int delta) {\n        score += delta;\n        notifyObservers(delta);\n    }\n\n    private void notifyObservers(int delta) {\n        for (PlayerObserver obs : observers) {\n            obs.onPlayerScoreChanged(delta);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#playerobserver-interface","title":"PlayerObserver Interface","text":"<pre><code>interface PlayerObserver {\n    void onPlayerScoreChanged(int delta);\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#user","title":"User","text":"<pre><code>class User implements PlayerObserver {\n    String userId;\n    int totalScore = 0;\n\n    User(String userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public void onPlayerScoreChanged(int delta) {\n        totalScore += delta;\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#leaderboard","title":"Leaderboard","text":"<pre><code>import java.util.*;\n\npublic class Leaderboard {\n\n    private Map&lt;String, Player&gt; players = new HashMap&lt;&gt;();\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    private TreeSet&lt;User&gt; leaderboard;\n\n    public Leaderboard() {\n        leaderboard = new TreeSet&lt;&gt;((a, b) -&gt; {\n            if (a.totalScore != b.totalScore) {\n                return b.totalScore - a.totalScore; // score DESC\n            }\n            return a.userId.compareTo(b.userId); // tie-break\n        });\n    }\n\n    // ---------------- addUser ----------------\n    public void addUser(String userId, List&lt;String&gt; playerIds) {\n\n        User user = new User(userId);\n        users.put(userId, user);\n\n        for (String pid : playerIds) {\n            Player p = players.computeIfAbsent(pid, k -&gt; new Player(pid));\n            p.addObserver(user);\n            user.totalScore += p.score; // reflect existing score\n        }\n\n        leaderboard.add(user);\n    }\n\n    // ---------------- addScore ----------------\n    public void addScore(String playerId, int delta) {\n\n        Player p = players.computeIfAbsent(playerId, k -&gt; new Player(playerId));\n\n        // Remove affected users before update\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.remove((User) obs);\n        }\n\n        p.addScore(delta); // notify observers\n\n        // Reinsert updated users\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.add((User) obs);\n        }\n    }\n\n    // ---------------- getTopK ----------------\n    public List&lt;String&gt; getTopK(int k) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        int count = 0;\n\n        for (User u : leaderboard) {\n            result.add(u.userId);\n            count++;\n            if (count == k) break;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>addUser(\"uA\", [\"p1\", \"p2\"])\naddUser(\"uB\", [\"p2\"])\n\ngetTopK(2)\n\u2192 [\"uA\", \"uB\"]\n\naddScore(\"p2\", 10)\n\u2192 uA = 10, uB = 10\n\naddScore(\"p1\", 3)\n\u2192 uA = 13, uB = 10\n\ngetTopK(1)\n\u2192 [\"uA\"]\n\naddScore(\"p2\", -5)\n\u2192 uA = 8, uB = 5\n</code></pre>"},{"location":"machine-coding/fantasy-leaderboard/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Player score updates before user registration</li> <li>Negative score deltas</li> <li>Tie-breaking using lexicographical order</li> <li><code>k</code> greater than number of users</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addUser O(p log n) addScore O(u log n) getTopK O(k) Memory O(users + players + edges) <p>Where:</p> <ul> <li><code>p</code> = players per team</li> <li><code>u</code> = users observing a player</li> <li><code>n</code> = total users</li> </ul>"},{"location":"machine-coding/fantasy-leaderboard/#why-this-solution-is-strong","title":"\u2705 Why This Solution Is Strong","text":"<p>\u2714 Clean separation of concerns \u2714 Real-time leaderboard consistency \u2714 Efficient Top-K queries \u2714 Observer pattern fits domain perfectly \u2714 Interview-grade design clarity</p>"},{"location":"machine-coding/file-system-cd-wildcard/","title":"\ud83d\uddc2\ufe0f Design a File System (cd with <code>*</code> Wildcard)","text":""},{"location":"machine-coding/file-system-cd-wildcard/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design and implement an in-memory Unix filesystem shell that supports the following commands:</p> <ul> <li><code>mkdir &lt;path&gt;</code></li> <li><code>pwd</code></li> <li><code>cd &lt;path&gt;</code> (supports wildcard <code>*</code>)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#environment-rules","title":"Environment &amp; Rules","text":"<ul> <li>System starts at root directory <code>/</code></li> <li> <p>Paths can be:</p> <ul> <li>Absolute (start with <code>/</code>)</li> <li>Relative (start from current directory)</li> <li>Path separator is <code>/</code></li> <li>Multiple consecutive <code>/</code> are treated as one</li> <li>Filesystem exists only in memory</li> </ul> </li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#supported-path-segments","title":"\ud83d\udcc2 Supported Path Segments","text":"Segment Meaning <code>.</code> Current directory <code>..</code> Parent directory (root\u2019s parent is root itself) <code>*</code> Wildcard matching exactly one segment"},{"location":"machine-coding/file-system-cd-wildcard/#wildcard-resolution-rules","title":"\ud83e\udde0 Wildcard (<code>*</code>) Resolution Rules","text":"<p>When <code>*</code> is encountered during <code>cd</code> traversal:</p> <ol> <li>Prefer child directories</li> <li>If multiple children exist \u2192 pick lexicographically smallest</li> <li>If no child directories exist \u2192 fallback to <code>.</code></li> <li>If still applicable \u2192 fallback to <code>..</code></li> </ol> <p>This ensures:</p> <ul> <li>Deterministic behavior</li> <li>No ambiguity</li> <li>No branching paths</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/file-system-cd-wildcard/#core-abstractions","title":"Core Abstractions","text":""},{"location":"machine-coding/file-system-cd-wildcard/#1-filesystemnode-abstract","title":"1. FileSystemNode (Abstract)","text":"<ul> <li>Common base for files and directories</li> <li>Stores name and parent reference</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#2-directorynode","title":"2. DirectoryNode","text":"<ul> <li>Contains child nodes</li> <li>Uses <code>TreeMap</code> to maintain lexicographic order</li> <li>Supports wildcard resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#3-filenode","title":"3. FileNode","text":"<ul> <li>Placeholder (not used heavily but keeps design extensible)</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>DirectoryNode\n \u251c\u2500\u2500 name\n \u251c\u2500\u2500 parent\n \u2514\u2500\u2500 TreeMap&lt;String, FileSystemNode&gt; children\n</code></pre> <ul> <li><code>TreeMap</code> ensures sorted traversal</li> <li>Parent pointers allow fast <code>pwd</code> and <code>..</code> resolution</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class FileSystemShell {\n\n    abstract class FileSystemNode {\n        String name;\n        DirectoryNode parent;\n\n        FileSystemNode(String name, DirectoryNode parent) {\n            this.name = name;\n            this.parent = parent;\n        }\n\n        abstract boolean isDirectory();\n    }\n\n    class FileNode extends FileSystemNode {\n        FileNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return false;\n        }\n    }\n\n    class DirectoryNode extends FileSystemNode {\n        TreeMap&lt;String, FileSystemNode&gt; children = new TreeMap&lt;&gt;();\n\n        DirectoryNode(String name, DirectoryNode parent) {\n            super(name, parent);\n        }\n\n        @Override\n        boolean isDirectory() {\n            return true;\n        }\n\n        FileSystemNode getChild(String name) {\n            return children.get(name);\n        }\n\n        void addChild(FileSystemNode node) {\n            children.putIfAbsent(node.name, node);\n        }\n\n        DirectoryNode smallestChildDir() {\n            for (FileSystemNode node : children.values()) {\n                if (node.isDirectory()) {\n                    return (DirectoryNode) node;\n                }\n            }\n            return null;\n        }\n    }\n\n    private final DirectoryNode root = new DirectoryNode(\"/\", null);\n    private DirectoryNode cwd = root;\n\n    public FileSystemShell() {}\n\n    // ================= pwd =================\n    public String pwd() {\n        if (cwd == root) return \"/\";\n        LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();\n        FileSystemNode cur = cwd;\n\n        while (cur != root) {\n            path.addFirst(cur.name);\n            cur = cur.parent;\n        }\n        return \"/\" + String.join(\"/\", path);\n    }\n\n    // ================= mkdir =================\n    public void mkdir(String path) {\n        DirectoryNode cur = path.startsWith(\"/\") ? root : cwd;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n                continue;\n            }\n\n            FileSystemNode child = cur.getChild(seg);\n            if (child == null) {\n                DirectoryNode newDir = new DirectoryNode(seg, cur);\n                cur.addChild(newDir);\n                cur = newDir;\n            } else if (child.isDirectory()) {\n                cur = (DirectoryNode) child;\n            } else {\n                return; // cannot mkdir inside file\n            }\n        }\n    }\n\n    // ================= cd =================\n    public void cd(String path) {\n        DirectoryNode start = path.startsWith(\"/\") ? root : cwd;\n        DirectoryNode cur = start;\n\n        for (String seg : path.split(\"/\")) {\n            if (seg.isEmpty() || seg.equals(\".\")) continue;\n\n            if (seg.equals(\"..\")) {\n                if (cur.parent != null) cur = cur.parent;\n            }\n            else if (seg.equals(\"*\")) {\n                DirectoryNode next = cur.smallestChildDir();\n                if (next != null) cur = next;\n            }\n            else {\n                FileSystemNode node = cur.getChild(seg);\n                if (node == null || !node.isDirectory()) return;\n                cur = (DirectoryNode) node;\n            }\n        }\n        cwd = cur;\n    }\n}\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>CWD: /\npwd \u2192 /\n\nmkdir /a/b/c\npwd \u2192 /\n\ncd a/b\npwd \u2192 /a/b\n\ncd *\n\u2192 moves to /a/b/c\n\ncd ../*\n\u2192 resolves back to /a/b/c\n\ncd /*\n\u2192 resolves to /a (lexicographically smallest child of /)\n</code></pre>"},{"location":"machine-coding/file-system-cd-wildcard/#failure-case-handling","title":"\u26a0\ufe0f Failure Case Handling","text":"<ul> <li><code>cd /nope/*/x</code> \u2192 fails</li> <li>Current directory remains unchanged</li> <li>No partial traversal applied</li> </ul>"},{"location":"machine-coding/file-system-cd-wildcard/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity pwd O(depth) mkdir O(depth) cd O(depth \u00d7 log(children)) Memory O(total directories)"},{"location":"machine-coding/file-system-cd-wildcard/#why-this-design-works","title":"\ud83c\udfc6 Why This Design Works","text":"<p>\u2714 Deterministic wildcard resolution \u2714 Proper Unix semantics \u2714 Safe failure handling \u2714 Clean object-oriented design \u2714 Interview-grade clarity</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/","title":"\u2728 Refactoring Text Editor to Flyweight Pattern","text":""},{"location":"machine-coding/flyweight-pattren-text-edit/#goal","title":"\ud83c\udfaf Goal","text":"<p>Reduce memory usage by sharing character style objects instead of duplicating them for every character.</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#before-problem-in-existing-design","title":"\ud83d\udd34 BEFORE (Problem in Existing Design)","text":"<pre><code>class StyledChar {\n    char ch;\n    String fontName;\n    int fontSize;\n    boolean isBold;\n    boolean isItalic;\n}\n</code></pre> <p>\u274c Issue:</p> <ul> <li>Every character stores full style info</li> <li>Large document \u21d2 huge memory waste</li> <li>Same styles repeated thousands of times</li> </ul>"},{"location":"machine-coding/flyweight-pattren-text-edit/#after-flyweight-design","title":"\u2705 AFTER (Flyweight Design)","text":"<p>We split style (intrinsic, shared) from character data (extrinsic).</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-1-create-flyweight-textstyle","title":"\ud83e\uddf1 Step 1: Create Flyweight (<code>TextStyle</code>)","text":"<pre><code>class TextStyle {\n    final String fontName;\n    final int fontSize;\n    final boolean isBold;\n    final boolean isItalic;\n\n    TextStyle(String fontName, int fontSize, boolean isBold, boolean isItalic) {\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof TextStyle)) return false;\n        TextStyle that = (TextStyle) o;\n        return fontSize == that.fontSize &amp;&amp;\n               isBold == that.isBold &amp;&amp;\n               isItalic == that.isItalic &amp;&amp;\n               fontName.equals(that.fontName);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(fontName, fontSize, isBold, isItalic);\n    }\n}\n</code></pre> <p>\u2705 This is the Flyweight object \u2705 Must override <code>equals()</code> &amp; <code>hashCode()</code> \u2705 Immutable \u2192 safe to share</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-2-flyweight-factory","title":"\ud83c\udfed Step 2: Flyweight Factory","text":"<pre><code>class TextStyleFactory {\n\n    private static final Map&lt;TextStyle, TextStyle&gt; cache = new HashMap&lt;&gt;();\n\n    public static TextStyle getStyle(\n            String fontName,\n            int fontSize,\n            boolean isBold,\n            boolean isItalic) {\n\n        TextStyle key = new TextStyle(fontName, fontSize, isBold, isItalic);\n        cache.putIfAbsent(key, key);\n        return cache.get(key);\n    }\n}\n</code></pre> <p>\u2714 Ensures only one object per unique style \u2714 Centralized style reuse</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-3-character-holds-only-whats-unique","title":"\u270d\ufe0f Step 3: Character Holds Only What\u2019s Unique","text":"<pre><code>class StyledChar {\n    char ch;              // extrinsic\n    TextStyle style;      // intrinsic (shared)\n\n    StyledChar(char ch, TextStyle style) {\n        this.ch = ch;\n        this.style = style;\n    }\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#step-4-document-storage-rows","title":"\ud83d\udcc4 Step 4: Document Storage (Rows)","text":"<pre><code>List&lt;List&lt;StyledChar&gt;&gt; rows = new ArrayList&lt;&gt;();\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#refactored-addcharacter-flyweight-enabled","title":"\u270f\ufe0f Refactored <code>addCharacter()</code> (Flyweight Enabled)","text":"<pre><code>public void addCharacter(\n        int row, int column, char ch,\n        String fontName, int fontSize,\n        boolean isBold, boolean isItalic) {\n\n    while (rows.size() &lt;= row) {\n        rows.add(new ArrayList&lt;&gt;());\n    }\n\n    List&lt;StyledChar&gt; line = rows.get(row);\n\n    TextStyle style = TextStyleFactory.getStyle(\n            fontName, fontSize, isBold, isItalic);\n\n    StyledChar newChar = new StyledChar(ch, style);\n\n    if (column &gt;= line.size()) {\n        line.add(newChar);\n    } else {\n        line.add(column, newChar);\n    }\n}\n</code></pre> <p>\ud83d\udca1 Key improvement: Style objects are shared automatically.</p>"},{"location":"machine-coding/flyweight-pattren-text-edit/#refactored-getstyle","title":"\ud83c\udfa8 Refactored <code>getStyle()</code>","text":"<pre><code>public String getStyle(int row, int col) {\n    if (row &gt;= rows.size() || col &gt;= rows.get(row).size()) {\n        return \"\";\n    }\n\n    StyledChar sc = rows.get(row).get(col);\n    TextStyle s = sc.style;\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(sc.ch).append(\"-\")\n      .append(s.fontName).append(\"-\")\n      .append(s.fontSize);\n\n    if (s.isBold) sb.append(\"-b\");\n    if (s.isItalic) sb.append(\"-i\");\n\n    return sb.toString();\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#readline-unchanged","title":"\ud83d\udcd6 <code>readLine()</code> (Unchanged)","text":"<pre><code>public String readLine(int row) {\n    if (row &gt;= rows.size()) return \"\";\n\n    StringBuilder sb = new StringBuilder();\n    for (StyledChar sc : rows.get(row)) {\n        sb.append(sc.ch);\n    }\n    return sb.toString();\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#deletecharacter-unchanged","title":"\ud83d\uddd1\ufe0f <code>deleteCharacter()</code> (Unchanged)","text":"<pre><code>public boolean deleteCharacter(int row, int col) {\n    if (row &gt;= rows.size() || col &gt;= rows.get(row).size()) {\n        return false;\n    }\n    rows.get(row).remove(col);\n    return true;\n}\n</code></pre>"},{"location":"machine-coding/flyweight-pattren-text-edit/#memory-impact-why-this-matters","title":"\ud83d\udcca Memory Impact (Why This Matters)","text":"Scenario Without Flyweight With Flyweight 1M chars, same style 1M style objects 1 style object Real editor \u274c Heavy \u2705 Efficient Interview quality \u274c Average \ud83d\udd25 Strong"},{"location":"machine-coding/flyweight-pattren-text-edit/#interview-explanation-say-this","title":"\ud83e\udde0 Interview Explanation (Say This)","text":"<p>\u201cI used the Flyweight pattern to deduplicate text formatting objects. Each character stores only a reference to a shared <code>TextStyle</code>, drastically reducing memory usage for large documents.\u201d</p> <p>This line alone wins brownie points.</p>"},{"location":"machine-coding/in-memory-database/","title":"Design a Complete In-Memory Database","text":""},{"location":"machine-coding/in-memory-database/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory database that stores records identified by a <code>key</code>. Each record contains multiple fields, and each field stores a value.</p> <p>The system evolves across 4 levels:</p>"},{"location":"machine-coding/in-memory-database/#levels-breakdown","title":"\ud83e\udde9 Levels Breakdown","text":""},{"location":"machine-coding/in-memory-database/#level-1-basic-operations","title":"\u2705 Level 1 \u2013 Basic Operations","text":"<ul> <li>Set values</li> <li>Conditional updates</li> <li>Conditional deletes</li> <li>Get values</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-2-scanning-filtering","title":"\u2705 Level 2 \u2013 Scanning &amp; Filtering","text":"<ul> <li>Scan all fields for a key</li> <li>Scan fields by prefix</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-3-ttl-time-to-live","title":"\u2705 Level 3 \u2013 TTL (Time-To-Live)","text":"<ul> <li>Fields can expire after a given TTL</li> <li>Expired fields are invisible</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-4-look-back-queries","title":"\u2705 Level 4 \u2013 Look-Back Queries","text":"<ul> <li>Retrieve field values as of a given timestamp</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/in-memory-database/#key-ideas","title":"Key Ideas","text":"<ul> <li>Multi-version storage per field</li> <li>Timestamp-aware writes</li> <li>Lazy expiration using TTL</li> <li>Sorted history for look-back</li> </ul>"},{"location":"machine-coding/in-memory-database/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":""},{"location":"machine-coding/in-memory-database/#versionedvalue","title":"VersionedValue","text":"<p>Stores historical versions of a field.</p> <pre><code>class VersionedValue {\n    int timestamp;\n    String value;\n    Integer expiryTime; // null means no TTL\n\n    VersionedValue(int timestamp, String value, Integer expiryTime) {\n        this.timestamp = timestamp;\n        this.value = value;\n        this.expiryTime = expiryTime;\n    }\n\n    boolean isExpired(int currentTime) {\n        return expiryTime != null &amp;&amp; currentTime &gt;= expiryTime;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#database-structure","title":"Database Structure","text":"<pre><code>Map&lt;key,\n  Map&lt;\n    field,\n    List&lt;VersionedValue&gt;\n  &gt;\n&gt;\n</code></pre>"},{"location":"machine-coding/in-memory-database/#full-java-implementation-all-levels","title":"\ud83d\udcbb Full Java Implementation (All Levels)","text":"<pre><code>import java.util.*;\n\npublic class InMemoryDatabase {\n\n    private Map&lt;String, Map&lt;String, List&lt;VersionedValue&gt;&gt;&gt; db = new HashMap&lt;&gt;();\n\n    // ---------- LEVEL 1 ----------\n\n    public void set(int timestamp, String key, String field, String value) {\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, null));\n    }\n\n    public boolean compareAndSet(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        set(timestamp, key, field, curr);\n        return true;\n    }\n\n    public boolean compareAndDelete(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        db.get(key).get(field)\n          .add(new VersionedValue(timestamp, null, null));\n        return true;\n    }\n\n    public String get(int timestamp, String key, String field) {\n        if (!db.containsKey(key) || !db.get(key).containsKey(field)) {\n            return null;\n        }\n        return getLatestValue(db.get(key).get(field), timestamp);\n    }\n\n    // ---------- LEVEL 2 ----------\n\n    public List&lt;String&gt; scan(int timestamp, String key) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    public List&lt;String&gt; scanByPrefix(int timestamp, String key, String prefix) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            if (!field.startsWith(prefix)) continue;\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    // ---------- LEVEL 3 ----------\n\n    public void setWithTTL(int timestamp, String key, String field, String value, int ttl) {\n        int expiry = timestamp + ttl;\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, expiry));\n    }\n\n    public boolean compareAndSetWithTTL(int timestamp, String key, String field,\n                                        int expectedValue, int newValue, int ttl) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        setWithTTL(timestamp, key, field, String.valueOf(newValue), ttl);\n        return true;\n    }\n\n    // ---------- HELPERS ----------\n\n    private String getLatestValue(List&lt;VersionedValue&gt; history, int timestamp) {\n        String result = null;\n        for (VersionedValue vv : history) {\n            if (vv.timestamp &gt; timestamp) break;\n            if (vv.isExpired(timestamp)) continue;\n            result = vv.value;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Field deletion using tombstones</li> <li>Expired values hidden automatically</li> <li>Prefix scans skip expired fields</li> <li>Look-back reads ignore future writes</li> <li>Multiple updates to same field</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Multi-Version Concurrency Control (MVCC)</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> <li>Lazy Expiration</li> <li>Time-based Snapshot Reads</li> </ul>"},{"location":"machine-coding/in-memory-database/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity set / get O(V) scan O(F \u00d7 V) scanByPrefix O(F \u00d7 V) TTL operations O(1) Look-back O(V) <p>F = fields per key, V = versions per field</p>"},{"location":"machine-coding/in-memory-database/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<p>Why versioned values instead of overwriting?</p> <p>Enables:</p> <ul> <li>Look-back queries</li> <li>Safe TTL handling</li> <li>Historical correctness</li> </ul> <p>Why lazy TTL cleanup?</p> <p>Avoids background threads and keeps implementation deterministic.</p>"},{"location":"machine-coding/in-memory-database/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Background compaction</li> <li>Range queries</li> <li>Indexing for prefix scans</li> <li>Persistent WAL</li> <li>Concurrent access handling</li> </ul> <p>```</p>"},{"location":"machine-coding/job-scheduler/","title":"\u2699\ufe0f Design a Job Scheduler","text":""},{"location":"machine-coding/job-scheduler/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a Job Scheduler for a massively parallel distributed system.</p> <ul> <li>The scheduler manages multiple machines</li> <li>Each machine has a set of capabilities</li> <li>Each job requires a set of capabilities</li> <li>A job can only be assigned to a machine that has all required capabilities</li> </ul>"},{"location":"machine-coding/job-scheduler/#core-requirements","title":"\ud83e\udde0 Core Requirements","text":""},{"location":"machine-coding/job-scheduler/#machine","title":"Machine","text":"<ul> <li>Has a unique <code>machineId</code></li> <li>Has a set of capabilities (case-insensitive)</li> <li> <p>Tracks:</p> <ul> <li><code>unfinishedJobs</code></li> <li><code>finishedJobs</code></li> </ul> </li> </ul>"},{"location":"machine-coding/job-scheduler/#job","title":"Job","text":"<ul> <li>Has a unique <code>jobId</code></li> <li>Assigned to exactly one machine</li> <li>Can be marked completed</li> </ul>"},{"location":"machine-coding/job-scheduler/#assignment-criteria-extensible","title":"\ud83d\udd00 Assignment Criteria (Extensible)","text":"<p>When multiple machines qualify, select based on criteria:</p> Criteria Description <code>0</code> Machine with least unfinished jobs <code>1</code> Machine with most finished jobs Tie Lexicographically smallest <code>machineId</code> <p>\u26a0\ufe0f Extensibility requirement: Adding a new scheduling algorithm should not change existing logic.</p>"},{"location":"machine-coding/job-scheduler/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/job-scheduler/#key-design-patterns-used","title":"Key Design Patterns Used","text":"Pattern Why Strategy Pattern Plug-and-play job selection algorithms Encapsulation Machine manages its own counters Open/Closed Principle Add new criteria without touching scheduler logic"},{"location":"machine-coding/job-scheduler/#high-level-architecture","title":"\ud83e\udde9 High-Level Architecture","text":"<pre><code>JobScheduler\n \u251c\u2500\u2500 machines: Map&lt;String, Machine&gt;\n \u251c\u2500\u2500 jobs: Map&lt;String, Job&gt;\n \u251c\u2500\u2500 strategies: Map&lt;Integer, AssignmentStrategy&gt;\n\nMachine\n \u251c\u2500\u2500 machineId\n \u251c\u2500\u2500 capabilities (Set&lt;String&gt;)\n \u251c\u2500\u2500 unfinishedJobs\n \u251c\u2500\u2500 finishedJobs\n\nAssignmentStrategy (interface)\n \u251c\u2500\u2500 selectMachine(...)\n</code></pre>"},{"location":"machine-coding/job-scheduler/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":""},{"location":"machine-coding/job-scheduler/#assignment-strategy-interface","title":"Assignment Strategy Interface","text":"<pre><code>interface AssignmentStrategy {\n    Machine select(List&lt;Machine&gt; candidates);\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#strategy-0-least-unfinished-jobs","title":"Strategy 0: Least Unfinished Jobs","text":"<pre><code>class LeastUnfinishedStrategy implements AssignmentStrategy {\n\n    @Override\n    public Machine select(List&lt;Machine&gt; machines) {\n        machines.sort((a, b) -&gt; {\n            if (a.unfinishedJobs != b.unfinishedJobs) {\n                return a.unfinishedJobs - b.unfinishedJobs;\n            }\n            return a.machineId.compareTo(b.machineId);\n        });\n        return machines.get(0);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#strategy-1-most-finished-jobs","title":"Strategy 1: Most Finished Jobs","text":"<pre><code>class MostFinishedStrategy implements AssignmentStrategy {\n\n    @Override\n    public Machine select(List&lt;Machine&gt; machines) {\n        machines.sort((a, b) -&gt; {\n            if (a.finishedJobs != b.finishedJobs) {\n                return b.finishedJobs - a.finishedJobs;\n            }\n            return a.machineId.compareTo(b.machineId);\n        });\n        return machines.get(0);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#machine_1","title":"Machine","text":"<pre><code>class Machine {\n    String machineId;\n    Set&lt;String&gt; capabilities;\n    int unfinishedJobs = 0;\n    int finishedJobs = 0;\n\n    Machine(String machineId, Set&lt;String&gt; capabilities) {\n        this.machineId = machineId;\n        this.capabilities = capabilities;\n    }\n\n    boolean supports(Set&lt;String&gt; required) {\n        return capabilities.containsAll(required);\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#job_1","title":"Job","text":"<pre><code>class Job {\n    String jobId;\n    Machine machine;\n\n    Job(String jobId, Machine machine) {\n        this.jobId = jobId;\n        this.machine = machine;\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#job-scheduler-main-class","title":"Job Scheduler (Main Class)","text":"<pre><code>import java.util.*;\n\npublic class JobScheduler {\n\n    private Map&lt;String, Machine&gt; machines = new HashMap&lt;&gt;();\n    private Map&lt;String, Job&gt; jobs = new HashMap&lt;&gt;();\n    private Map&lt;Integer, AssignmentStrategy&gt; strategies = new HashMap&lt;&gt;();\n\n    public JobScheduler() {\n        strategies.put(0, new LeastUnfinishedStrategy());\n        strategies.put(1, new MostFinishedStrategy());\n    }\n\n    // ---------------- addMachine ----------------\n    public void addMachine(String machineId, String[] capabilities) {\n        Set&lt;String&gt; caps = new HashSet&lt;&gt;();\n        for (String cap : capabilities) {\n            caps.add(cap.toLowerCase());\n        }\n        machines.put(machineId, new Machine(machineId, caps));\n    }\n\n    // ---------------- assignMachineToJob ----------------\n    public String assignMachineToJob(String jobId, String[] requiredCaps, int criteria) {\n\n        Set&lt;String&gt; required = new HashSet&lt;&gt;();\n        for (String r : requiredCaps) {\n            required.add(r.toLowerCase());\n        }\n\n        List&lt;Machine&gt; candidates = new ArrayList&lt;&gt;();\n        for (Machine m : machines.values()) {\n            if (m.supports(required)) {\n                candidates.add(m);\n            }\n        }\n\n        if (candidates.isEmpty()) return \"\";\n\n        AssignmentStrategy strategy = strategies.get(criteria);\n        Machine selected = strategy.select(candidates);\n\n        selected.unfinishedJobs++;\n        jobs.put(jobId, new Job(jobId, selected));\n\n        return selected.machineId;\n    }\n\n    // ---------------- jobCompleted ----------------\n    public void jobCompleted(String jobId) {\n        Job job = jobs.get(jobId);\n        Machine m = job.machine;\n\n        m.unfinishedJobs--;\n        m.finishedJobs++;\n    }\n}\n</code></pre>"},{"location":"machine-coding/job-scheduler/#example-walkthrough","title":"\ud83e\uddea Example Walkthrough","text":"<pre><code>addMachine(\"m-10\", [\"image compression\", \"audio extraction\"])\naddMachine(\"m-2\", [\"image compression\"])\n\nassignMachineToJob(\"job-A\", [\"image compression\"], 0)\n\u2192 \"m-10\" (tie \u2192 lexicographically smaller)\n\njobCompleted(\"job-A\")\n\nassignMachineToJob(\"job-B\", [\"image compression\"], 1)\n\u2192 \"m-10\" (most finished jobs)\n</code></pre>"},{"location":"machine-coding/job-scheduler/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Case-insensitive capabilities</li> <li>No compatible machines \u2192 return <code>\"\"</code></li> <li>Deterministic tie-breaking</li> <li>Multiple jobs per machine</li> <li>Strategy extensibility without refactoring</li> </ul>"},{"location":"machine-coding/job-scheduler/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Complexity addMachine O(c) assignMachineToJob O(m log m) jobCompleted O(1) Space O(m + j + c) <p>Where:</p> <ul> <li><code>m</code> = machines</li> <li><code>j</code> = jobs</li> <li><code>c</code> = capabilities</li> </ul>"},{"location":"machine-coding/job-scheduler/#why-this-design-is-interview-strong","title":"\u2705 Why This Design Is Interview-Strong","text":"<p>\u2714 Clean separation of concerns \u2714 Strategy Pattern clearly justified \u2714 Easy to extend with new criteria \u2714 Deterministic and test-safe \u2714 Scales within given constraints</p> <ul> <li>Thread-safe version</li> <li>Weighted capabilities</li> <li>Load-aware scheduling</li> <li>Job preemption</li> <li>UML diagram</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/","title":"31. Design a Leaderboard for Fantasy Teams","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Build an in-memory leaderboard for a fantasy-sports application.</p> <ul> <li>Each user creates exactly one team</li> <li>Each team contains one or more players</li> <li>Players earn positive or negative points over time</li> <li>A user\u2019s score is the sum of scores of all players in their team</li> <li>The system must support Top-K leaderboard queries</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#rules-constraints","title":"\ud83e\udde0 Rules &amp; Constraints","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#team-player-rules","title":"Team &amp; Player Rules","text":"<ul> <li>Every user has exactly one team</li> <li>A player can belong to multiple users\u2019 teams</li> <li>Each user starts with score = 0</li> <li>Player score updates are deltas (positive or negative)</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#leaderboard-ordering","title":"Leaderboard Ordering","text":"<ol> <li>User score (descending)</li> <li>User ID (lexicographically ascending) as tie-breaker</li> </ol>"},{"location":"machine-coding/leaderboard-fantasy-teams/#apis-to-implement","title":"\ud83e\udde9 APIs to Implement","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#1-adduser","title":"1\ufe0f\u20e3 addUser","text":"<pre><code>void addUser(String userId, List&lt;String&gt; playerIds)\n</code></pre> <ul> <li>Registers a new user with their team</li> <li><code>userId</code> is unique and non-blank</li> <li><code>playerIds</code> contains at least one valid player</li> <li>If players already have scores, user score should reflect them immediately</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#2-addscore","title":"2\ufe0f\u20e3 addScore","text":"<pre><code>void addScore(String playerId, int score)\n</code></pre> <ul> <li>Updates a player\u2019s cumulative score by a delta</li> <li>All users containing that player must have their scores updated</li> <li>Leaderboard ordering must stay consistent</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#3-gettopk","title":"3\ufe0f\u20e3 getTopK","text":"<pre><code>List&lt;String&gt; getTopK(int k)\n</code></pre> <ul> <li> <p>Returns top <code>k</code> users sorted by:</p> <ul> <li>Score (descending)</li> <li>User ID (ascending)</li> <li>If <code>k</code> &gt; total users \u2192 return all users</li> </ul> </li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#example-walkthrough","title":"\ud83d\udcd8 Example Walkthrough","text":"<pre><code>addUser(\"uA\", [\"p1\", \"p2\"])\naddUser(\"uB\", [\"p2\"])\n\ngetTopK(2)\n// [\"uA\", \"uB\"]  (both scores = 0)\n\naddScore(\"p2\", 10)\n// uA = 10, uB = 10\n\ngetTopK(2)\n// [\"uA\", \"uB\"]  (tie \u2192 lex order)\n\naddScore(\"p1\", 3)\n// uA = 13, uB = 10\n\ngetTopK(1)\n// [\"uA\"]\n\naddScore(\"p2\", -5)\n// uA = 8, uB = 5\n\ngetTopK(5)\n// [\"uA\", \"uB\"]\n</code></pre>"},{"location":"machine-coding/leaderboard-fantasy-teams/#design-overview","title":"\ud83c\udfd7\ufe0f Design Overview","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#core-entities","title":"Core Entities","text":"Entity Responsibility <code>Player</code> Holds player score &amp; notifies users <code>User</code> Maintains total team score <code>Leaderboard</code> Maintains sorted ranking"},{"location":"machine-coding/leaderboard-fantasy-teams/#design-pattern-used","title":"\ud83e\udde0 Design Pattern Used","text":""},{"location":"machine-coding/leaderboard-fantasy-teams/#observer-pattern","title":"\u2705 Observer Pattern","text":"<ul> <li><code>User</code> observes <code>Player</code></li> <li> <p>When a player\u2019s score changes:</p> <ul> <li>All users owning that player are notified</li> <li>User scores update automatically</li> <li>Ensures efficient many-to-many updates</li> </ul> </li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Leaderboard {\n\n    private Map&lt;String, Player&gt; players = new HashMap&lt;&gt;();\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    private TreeSet&lt;User&gt; leaderboard;\n\n    public Leaderboard() {\n        leaderboard = new TreeSet&lt;&gt;((a, b) -&gt; {\n            if (a.totalScore != b.totalScore) {\n                return b.totalScore - a.totalScore; // score DESC\n            }\n            return a.userId.compareTo(b.userId); // lex ASC\n        });\n    }\n\n    // ---------------- addUser ----------------\n    public void addUser(String userId, List&lt;String&gt; playerIds) {\n\n        User user = new User(userId);\n        users.put(userId, user);\n\n        for (String pid : playerIds) {\n            Player p = players.computeIfAbsent(pid, k -&gt; new Player(pid));\n            p.addObserver(user);\n            user.totalScore += p.score; // reflect existing score\n        }\n\n        leaderboard.add(user);\n    }\n\n    // ---------------- addScore ----------------\n    public void addScore(String playerId, int delta) {\n\n        Player p = players.computeIfAbsent(playerId, k -&gt; new Player(playerId));\n\n        // Remove affected users before score change\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.remove((User) obs);\n        }\n\n        p.addScore(delta); // notify users\n\n        // Reinsert updated users\n        for (PlayerObserver obs : p.observers) {\n            leaderboard.add((User) obs);\n        }\n    }\n\n    // ---------------- getTopK ----------------\n    public List&lt;String&gt; getTopK(int k) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        int count = 0;\n\n        for (User u : leaderboard) {\n            result.add(u.userId);\n            count++;\n            if (count == k) break;\n        }\n        return result;\n    }\n}\n\n// ---------- SUPPORTING CLASSES ----------\n\nclass Player {\n    String playerId;\n    int score = 0;\n    List&lt;PlayerObserver&gt; observers = new ArrayList&lt;&gt;();\n\n    Player(String playerId) {\n        this.playerId = playerId;\n    }\n\n    void addObserver(PlayerObserver observer) {\n        observers.add(observer);\n    }\n\n    void addScore(int delta) {\n        score += delta;\n        notifyObservers(delta);\n    }\n\n    private void notifyObservers(int delta) {\n        for (PlayerObserver obs : observers) {\n            obs.onPlayerScoreChanged(delta);\n        }\n    }\n}\n\ninterface PlayerObserver {\n    void onPlayerScoreChanged(int delta);\n}\n\nclass User implements PlayerObserver {\n    String userId;\n    int totalScore = 0;\n\n    User(String userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public void onPlayerScoreChanged(int delta) {\n        totalScore += delta;\n    }\n}\n</code></pre>"},{"location":"machine-coding/leaderboard-fantasy-teams/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Player added after scoring</li> <li>Negative score updates</li> <li>Tie-breaking by user ID</li> <li><code>k</code> larger than user count</li> <li>Many-to-many player-user mapping</li> </ul>"},{"location":"machine-coding/leaderboard-fantasy-teams/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity addUser O(p log u) addScore O(u log u) getTopK O(k) <p>p = players per user, u = users affected</p>"},{"location":"machine-coding/leaderboard-fantasy-teams/#why-this-is-interview-ready","title":"\u2705 Why This Is Interview-Ready","text":"<ul> <li>Clean Observer pattern usage</li> <li>Deterministic ranking with <code>TreeSet</code></li> <li>Efficient updates without full recomputation</li> <li>Easily extensible (Top-N per league, snapshots, persistence)</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/","title":"Design a Meeting Room Reservation System","text":""},{"location":"machine-coding/meeting-room-reservation/#problem-statement","title":"Problem Statement","text":"<p>Design a Meeting Room Reservation System for a fixed set of conference rooms.</p> <p>The system must: - Book meetings without overlap - Cancel existing meetings - Always choose the lexicographically smallest room ID when multiple rooms are available - Treat time intervals as inclusive (<code>[startTime, endTime]</code>)</p>"},{"location":"machine-coding/meeting-room-reservation/#key-requirements","title":"Key Requirements","text":"<ul> <li>Each room can host only one meeting at a time</li> <li>Meetings overlap if times intersect inclusively</li> <li>Cancel only active meetings</li> <li>Meeting IDs are unique for active bookings</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#class-design","title":"\ud83c\udfd7\ufe0f Class Design","text":""},{"location":"machine-coding/meeting-room-reservation/#class-name","title":"Class Name","text":"<p><code>RoomBooking</code></p>"},{"location":"machine-coding/meeting-room-reservation/#constructor","title":"Constructor","text":"<pre><code>RoomBooking(List&lt;String&gt; roomIds);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#methods","title":"Methods","text":"<pre><code>String bookMeeting(String meetingId, int startTime, int endTime);\nboolean cancelMeeting(String meetingId);\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#design-overview","title":"\ud83e\udde9 Design Overview","text":""},{"location":"machine-coding/meeting-room-reservation/#core-data-structures","title":"Core Data Structures","text":"Structure Purpose <code>TreeMap&lt;Integer, Integer&gt;</code> Stores intervals per room <code>Map&lt;String, Room&gt;</code> Room registry <code>Map&lt;String, Meeting&gt;</code> Active meetings lookup <code>List&lt;String&gt;</code> Sorted room IDs"},{"location":"machine-coding/meeting-room-reservation/#entity-models","title":"\ud83c\udfdb\ufe0f Entity Models","text":""},{"location":"machine-coding/meeting-room-reservation/#meeting","title":"Meeting","text":"<ul> <li>meetingId</li> <li>roomId</li> <li>startTime</li> <li>endTime</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#room","title":"Room","text":"<ul> <li>roomId</li> <li>TreeMap of booked intervals (<code>start \u2192 end</code>)</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#booking-logic","title":"\ud83d\udd0d Booking Logic","text":"<p>To check if a room is free:</p> <ol> <li>Find the closest previous interval using <code>floorEntry</code></li> <li>Find the closest next interval using <code>ceilingEntry</code></li> <li>Reject booking if either overlaps (inclusive rules)</li> </ol>"},{"location":"machine-coding/meeting-room-reservation/#design-patterns-used","title":"\ud83e\udde0 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Ordered Resource Selection</li> <li>Interval Scheduling using TreeMap</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class RoomBooking {\n\n    class Meeting {\n        String meetingId;\n        String roomId;\n        int startTime;\n        int endTime;\n\n        Meeting(String meetingId, String roomId, int startTime, int endTime) {\n            this.meetingId = meetingId;\n            this.roomId = roomId;\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    class Room {\n        String roomId;\n        TreeMap&lt;Integer, Integer&gt; intervals = new TreeMap&lt;&gt;();\n\n        Room(String roomId) {\n            this.roomId = roomId;\n        }\n    }\n\n    private Map&lt;String, Room&gt; rooms = new HashMap&lt;&gt;();\n    private Map&lt;String, Meeting&gt; meetingMap = new HashMap&lt;&gt;();\n    private List&lt;String&gt; sortedRoomIds;\n\n    public RoomBooking(List&lt;String&gt; roomIds) {\n        sortedRoomIds = new ArrayList&lt;&gt;(roomIds);\n        Collections.sort(sortedRoomIds);\n\n        for (String id : roomIds) {\n            rooms.put(id, new Room(id));\n        }\n    }\n\n    public String bookMeeting(String meetingId, int startTime, int endTime) {\n\n        if (meetingMap.containsKey(meetingId)) {\n            return \"\";\n        }\n\n        for (String roomId : sortedRoomIds) {\n            Room room = rooms.get(roomId);\n            if (isAvailable(room, startTime, endTime)) {\n                room.intervals.put(startTime, endTime);\n                Meeting meeting = new Meeting(meetingId, roomId, startTime, endTime);\n                meetingMap.put(meetingId, meeting);\n                return roomId;\n            }\n        }\n        return \"\";\n    }\n\n    private boolean isAvailable(Room room, int startTime, int endTime) {\n\n        Map.Entry&lt;Integer, Integer&gt; floor = room.intervals.floorEntry(startTime);\n        if (floor != null &amp;&amp; floor.getValue() &gt;= startTime) {\n            return false;\n        }\n\n        Map.Entry&lt;Integer, Integer&gt; ceil = room.intervals.ceilingEntry(startTime);\n        if (ceil != null &amp;&amp; ceil.getKey() &lt;= endTime) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public boolean cancelMeeting(String meetingId) {\n        Meeting meeting = meetingMap.get(meetingId);\n        if (meeting == null) {\n            return false;\n        }\n\n        Room room = rooms.get(meeting.roomId);\n        room.intervals.remove(meeting.startTime);\n        meetingMap.remove(meetingId);\n        return true;\n    }\n}\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Inclusive overlap (<code>end == start</code> is conflict)</li> <li>Duplicate meeting IDs rejected</li> <li>Cancelling non-existent meetings</li> <li>Correct reuse of rooms after cancellation</li> <li>Lexicographically smallest room chosen</li> </ul>"},{"location":"machine-coding/meeting-room-reservation/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Book Meeting <code>O(R \u00d7 log M)</code> Cancel Meeting <code>O(log M)</code> Overlap Check <code>O(log M)</code> <p>R = number of rooms M = number of meetings per room</p>"},{"location":"machine-coding/meeting-room-reservation/#example","title":"\ud83e\uddea Example","text":"<pre><code>RoomBooking rb = new RoomBooking(Arrays.asList(\"roomA\", \"roomB\"));\n\nrb.bookMeeting(\"m1\", 10, 20); // roomA\nrb.bookMeeting(\"m2\", 15, 25); // roomB\nrb.bookMeeting(\"m3\", 20, 30); // \"\"\nrb.cancelMeeting(\"m1\");\nrb.bookMeeting(\"m4\", 20, 30); // roomA\n</code></pre>"},{"location":"machine-coding/meeting-room-reservation/#possible-enhancements","title":"\ud83d\ude80 Possible Enhancements","text":"<ul> <li>PriorityQueue optimization</li> <li>Support recurring meetings</li> <li>Room capacity handling</li> <li>Time window queries</li> <li>Concurrency control</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/","title":"\ud83c\udfac Design a Movie Ticket Booking System (BookMyShow)","text":""},{"location":"machine-coding/movie-ticket-booking/#problem-statement","title":"Problem Statement","text":"<p>Design an in-memory movie ticket booking system similar to BookMyShow.</p> <p>The system supports:</p> <ul> <li>Multiple cities</li> <li>Multiple cinemas per city</li> <li>Multiple screens per cinema</li> <li>Multiple shows per screen</li> <li>Seat booking and cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#booking-rules","title":"Booking Rules","text":"<ul> <li>Prefer continuous seats in the same row</li> <li> <p>If multiple options exist:</p> <ul> <li>Choose lowest row</li> <li>Then lowest column</li> <li> <p>If continuous seats are unavailable:</p> </li> <li> <p>Allocate seats from lowest row &amp; column</p> </li> <li>If insufficient seats exist, do not book any seats</li> </ul> </li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#core-design-principles","title":"\ud83e\udde0 Core Design Principles","text":"<ul> <li>Each Show owns its own seats</li> <li>Screens can host multiple shows over time</li> <li>Seat availability is isolated per show</li> <li>No concurrency assumptions (single-threaded)</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#key-entities","title":"\ud83c\udfd7\ufe0f Key Entities","text":""},{"location":"machine-coding/movie-ticket-booking/#1-cinema","title":"1. Cinema","text":"<ul> <li>Belongs to a city</li> <li>Contains multiple screens</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#2-screen","title":"2. Screen","text":"<ul> <li>Has fixed rows &amp; columns</li> <li>Hosts multiple shows over time</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#3-show","title":"3. Show","text":"<ul> <li>Belongs to a movie</li> <li>Runs on a screen</li> <li>Owns a seat matrix</li> <li>Tracks free seats</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#4-ticket","title":"4. Ticket","text":"<ul> <li>Maps booked seats to a show</li> <li>Supports cancellation</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#data-structures-used","title":"\ud83e\udde9 Data Structures Used","text":"<pre><code>cityId \u2192 List&lt;Cinema&gt;\ncinemaId \u2192 Cinema\nshowId \u2192 Show\nticketId \u2192 Ticket\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#java-implementation-solution-a","title":"\ud83d\udcbb Java Implementation (Solution A)","text":"<pre><code>import java.util.*;\n\npublic class Solution {\n\n    class Screen {\n        int rows, cols;\n        Screen(int rows, int cols) {\n            this.rows = rows;\n            this.cols = cols;\n        }\n    }\n\n    class Cinema {\n        int cinemaId;\n        List&lt;Screen&gt; screens;\n        Cinema(int cinemaId, List&lt;Screen&gt; screens) {\n            this.cinemaId = cinemaId;\n            this.screens = screens;\n        }\n    }\n\n    class Show {\n        int showId, movieId, cinemaId;\n        int rows, cols;\n        boolean[][] bookedSeats;\n        int freeSeats;\n\n        Show(int showId, int movieId, int cinemaId, Screen screen) {\n            this.showId = showId;\n            this.movieId = movieId;\n            this.cinemaId = cinemaId;\n            this.rows = screen.rows;\n            this.cols = screen.cols;\n            this.bookedSeats = new boolean[rows][cols];\n            this.freeSeats = rows * cols;\n        }\n    }\n\n    class Ticket {\n        String ticketId;\n        int showId;\n        List&lt;int[]&gt; seats;\n        boolean cancelled = false;\n\n        Ticket(String ticketId, int showId, List&lt;int[]&gt; seats) {\n            this.ticketId = ticketId;\n            this.showId = showId;\n            this.seats = seats;\n        }\n    }\n\n    Map&lt;Integer, Cinema&gt; cinemaDB = new HashMap&lt;&gt;();\n    Map&lt;Integer, List&lt;Cinema&gt;&gt; cityCinemaMap = new HashMap&lt;&gt;();\n    Map&lt;Integer, Show&gt; showDB = new HashMap&lt;&gt;();\n    Map&lt;String, Ticket&gt; ticketDB = new HashMap&lt;&gt;();\n\n    public void addCinema(int cinemaId, int cityId,\n                          int screenCount, int screenRow, int screenColumn) {\n\n        List&lt;Screen&gt; screens = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; screenCount; i++) {\n            screens.add(new Screen(screenRow, screenColumn));\n        }\n\n        Cinema cinema = new Cinema(cinemaId, screens);\n        cinemaDB.put(cinemaId, cinema);\n        cityCinemaMap.computeIfAbsent(cityId, k -&gt; new ArrayList&lt;&gt;()).add(cinema);\n    }\n\n    public void addShow(int showId, int movieId, int cinemaId,\n                        int screenIndex, long startTime, long endTime) {\n\n        Cinema cinema = cinemaDB.get(cinemaId);\n        if (cinema == null) return;\n\n        Screen screen = cinema.screens.get(screenIndex);\n        Show show = new Show(showId, movieId, cinemaId, screen);\n        showDB.put(showId, show);\n    }\n\n    public List&lt;String&gt; bookTicket(String ticketId, int showId, int ticketsCount) {\n        Show show = showDB.get(showId);\n        if (show == null || show.freeSeats &lt; ticketsCount) return Collections.emptyList();\n\n        List&lt;int[]&gt; allocated = allocateSeats(show, ticketsCount);\n        if (allocated.isEmpty()) return Collections.emptyList();\n\n        for (int[] seat : allocated) {\n            show.bookedSeats[seat[0]][seat[1]] = true;\n            show.freeSeats--;\n        }\n\n        ticketDB.put(ticketId, new Ticket(ticketId, showId, allocated));\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int[] s : allocated) {\n            result.add(s[0] + \"-\" + s[1]);\n        }\n        return result;\n    }\n\n    private List&lt;int[]&gt; allocateSeats(Show show, int count) {\n        // Try continuous seats\n        for (int r = 0; r &lt; show.rows; r++) {\n            int continuous = 0;\n            for (int c = 0; c &lt; show.cols; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    continuous++;\n                    if (continuous == count) {\n                        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n                        for (int k = c - count + 1; k &lt;= c; k++) {\n                            res.add(new int[]{r, k});\n                        }\n                        return res;\n                    }\n                } else {\n                    continuous = 0;\n                }\n            }\n        }\n\n        // Fallback: lowest row &amp; column\n        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();\n        for (int r = 0; r &lt; show.rows &amp;&amp; res.size() &lt; count; r++) {\n            for (int c = 0; c &lt; show.cols &amp;&amp; res.size() &lt; count; c++) {\n                if (!show.bookedSeats[r][c]) {\n                    res.add(new int[]{r, c});\n                }\n            }\n        }\n        return res.size() == count ? res : Collections.emptyList();\n    }\n\n    public boolean cancelTicket(String ticketId) {\n        Ticket ticket = ticketDB.get(ticketId);\n        if (ticket == null || ticket.cancelled) return false;\n\n        Show show = showDB.get(ticket.showId);\n        for (int[] seat : ticket.seats) {\n            show.bookedSeats[seat[0]][seat[1]] = false;\n            show.freeSeats++;\n        }\n        ticket.cancelled = true;\n        return true;\n    }\n\n    public int getFreeSeatsCount(int showId) {\n        Show show = showDB.get(showId);\n        return show == null ? 0 : show.freeSeats;\n    }\n\n    public List&lt;Integer&gt; listCinemas(int movieId, int cityId) {\n        List&lt;Cinema&gt; cinemas = cityCinemaMap.getOrDefault(cityId, Collections.emptyList());\n        Set&lt;Integer&gt; result = new TreeSet&lt;&gt;();\n\n        for (Cinema cinema : cinemas) {\n            for (Show show : showDB.values()) {\n                if (show.movieId == movieId &amp;&amp; show.cinemaId == cinema.cinemaId) {\n                    result.add(cinema.cinemaId);\n                }\n            }\n        }\n        return new ArrayList&lt;&gt;(result);\n    }\n\n    public List&lt;Integer&gt; listShows(int movieId, int cinemaId) {\n        List&lt;Show&gt; shows = new ArrayList&lt;&gt;();\n        for (Show s : showDB.values()) {\n            if (s.movieId == movieId &amp;&amp; s.cinemaId == cinemaId) {\n                shows.add(s);\n            }\n        }\n\n        shows.sort((a, b) -&gt; {\n            if (a.showId != b.showId) return b.showId - a.showId;\n            return a.showId - b.showId;\n        });\n\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        for (Show s : shows) {\n            result.add(s.showId);\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/movie-ticket-booking/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Insufficient seats \u2192 no booking</li> <li>Ticket cancellation restores seats</li> <li>Continuous seat preference</li> <li>Multiple shows per cinema</li> <li>Movie listings per city</li> </ul>"},{"location":"machine-coding/movie-ticket-booking/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addCinema O(screens) addShow O(1) bookTicket O(rows \u00d7 cols) cancelTicket O(k) (booked seats) listCinemas O(cinemas \u00d7 shows) getFreeSeatsCount O(1)"},{"location":"machine-coding/movie-ticket-booking/#why-this-design-is-correct","title":"\ud83c\udfc6 Why This Design is Correct","text":"<p>\u2714 Seats belong to Show, not Screen \u2714 Supports multiple shows per screen \u2714 Correct booking prioritization \u2714 Clean separation of responsibilities \u2714 Fully test-safe and interview-ready</p> <p>If you want, next I can:</p> <ul> <li>Add UML diagram</li> <li>Add MkDocs navigation entry</li> <li>Refactor to production-grade version</li> <li>Add unit tests</li> </ul> <p>Just say next \ud83d\ude80</p>"},{"location":"machine-coding/snake-game/","title":"Design Snake Game","text":""},{"location":"machine-coding/snake-game/#problem-statement","title":"Problem Statement","text":"<p>Design a Snake game simulator played on a 2D grid.</p> <ul> <li>The grid has fixed dimensions <code>rows \u00d7 cols</code></li> <li>The snake starts at position <code>(0,0)</code> with length <code>1</code></li> <li> <p>The snake moves one step at a time in one of the directions:</p> <ul> <li><code>\"U\"</code> (up), <code>\"D\"</code> (down), <code>\"L\"</code> (left), <code>\"R\"</code> (right)</li> <li>Food positions are provided in advance and appear sequentially</li> <li> <p>When the snake eats food:</p> </li> <li> <p>Snake length increases by 1</p> </li> <li>Score increases by 1</li> <li> <p>The game ends if:</p> </li> <li> <p>The snake hits the wall</p> </li> <li>The snake hits itself</li> <li>After the game ends, all further moves must return <code>-1</code></li> </ul> </li> </ul>"},{"location":"machine-coding/snake-game/#design-overview","title":"Design Overview","text":"<p>The snake is represented as an ordered sequence of cells. Each move adds a new head and conditionally removes the tail.</p>"},{"location":"machine-coding/snake-game/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li>Use a Deque to represent the snake body</li> <li>Use a HashSet for fast self-collision detection</li> <li>Use a Queue to store food positions</li> <li>Maintain a <code>gameOver</code> flag to handle post-termination behavior</li> </ul>"},{"location":"machine-coding/snake-game/#data-structures","title":"Data Structures","text":"Purpose Structure Snake body <code>Deque&lt;Cell&gt;</code> Collision check <code>HashSet&lt;Cell&gt;</code> Food sequence <code>Queue&lt;Cell&gt;</code> Game state <code>boolean gameOver</code>"},{"location":"machine-coding/snake-game/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/snake-game/#cell","title":"Cell","text":"<p>Represents a position on the grid.</p> <pre><code>class Cell {\n    int row;\n    int col;\n\n    Cell(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Cell)) return false;\n        Cell cell = (Cell) o;\n        return row == cell.row &amp;&amp; col == cell.col;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#design-patterns-used","title":"Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State management via <code>gameOver</code> flag</li> <li>Efficient simulation using Deque</li> <li>HashSet for constant-time collision detection</li> </ul>"},{"location":"machine-coding/snake-game/#java-implementation","title":"Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SnakeGame {\n\n    private int rows;\n    private int cols;\n    private Deque&lt;Cell&gt; snake;\n    private Set&lt;Cell&gt; occupied;\n    private Queue&lt;Cell&gt; foodQueue;\n    private int score;\n    private boolean gameOver;\n\n    public SnakeGame(int rows, int cols, String[] foodPositions) {\n        this.rows = rows;\n        this.cols = cols;\n        this.snake = new LinkedList&lt;&gt;();\n        this.occupied = new HashSet&lt;&gt;();\n        this.foodQueue = new LinkedList&lt;&gt;();\n        this.score = 0;\n        this.gameOver = false;\n\n        Cell start = new Cell(0, 0);\n        snake.addLast(start);\n        occupied.add(start);\n\n        for (String food : foodPositions) {\n            String[] parts = food.split(\",\");\n            foodQueue.offer(\n                new Cell(\n                    Integer.parseInt(parts[0]),\n                    Integer.parseInt(parts[1])\n                )\n            );\n        }\n    }\n\n    public int move(String direction) {\n        if (gameOver) {\n            return -1;\n        }\n\n        Cell head = snake.peekLast();\n        int r = head.row;\n        int c = head.col;\n\n        switch (direction) {\n            case \"U\": r--; break;\n            case \"D\": r++; break;\n            case \"L\": c--; break;\n            case \"R\": c++; break;\n        }\n\n        Cell newHead = new Cell(r, c);\n\n        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) {\n            gameOver = true;\n            return -1;\n        }\n\n        boolean eatsFood =\n            !foodQueue.isEmpty() &amp;&amp; foodQueue.peek().equals(newHead);\n\n        if (!eatsFood) {\n            Cell tail = snake.pollFirst();\n            occupied.remove(tail);\n        }\n\n        if (occupied.contains(newHead)) {\n            gameOver = true;\n            return -1;\n        }\n\n        snake.addLast(newHead);\n        occupied.add(newHead);\n\n        if (eatsFood) {\n            foodQueue.poll();\n            score++;\n        }\n\n        return score;\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#edge-cases-handled","title":"Edge Cases Handled","text":"<ul> <li>Wall collision</li> <li>Self collision</li> <li>Moves after game over</li> <li>No food scenario</li> <li>Snake moving into previous tail position</li> <li>Empty food list</li> </ul>"},{"location":"machine-coding/snake-game/#time-and-space-complexity","title":"Time and Space Complexity","text":""},{"location":"machine-coding/snake-game/#movedirection","title":"move(direction)","text":"<ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(rows \u00d7 cols)</li> </ul>"},{"location":"machine-coding/snake-game/#example","title":"Example","text":"<pre><code>SnakeGame game = new SnakeGame(2, 2, new String[]{});\n\ngame.move(\"R\"); // 0\ngame.move(\"D\"); // 0\ngame.move(\"R\"); // -1\ngame.move(\"U\"); // -1\n</code></pre>"},{"location":"machine-coding/snake-game/#interview-notes","title":"Interview Notes","text":"<ul> <li>Always remove the tail before checking self-collision</li> <li>Persist game-over state</li> <li>Deque + HashSet is the optimal combination</li> <li>Follow inclusive boundary rules strictly</li> </ul> <p>If you want, next I can:</p> <ul> <li>Add this to <code>mkdocs.yml</code> navigation</li> <li>Convert Text Editor (Undo/Redo) to the same format</li> <li>Create a reusable LLD markdown template</li> <li>Refactor code for interview-grade clarity</li> </ul> <p>Just tell me what\u2019s next.</p>"},{"location":"machine-coding/spreadsheet-flyweight/","title":"25. Design a Spreadsheet (Excel-like) \u2014 Flyweight Optimized","text":""},{"location":"machine-coding/spreadsheet-flyweight/#problem-statement-recap","title":"\ud83d\udcdc Problem Statement (Recap)","text":"<p>We are building an in-memory spreadsheet where:</p> <ul> <li>Each cell stores text + style</li> <li> <p>Styles include:</p> <ul> <li>font name</li> <li>font size</li> <li>bold</li> <li>italic</li> <li> <p>Spreadsheet supports:</p> </li> <li> <p>Inserting rows</p> </li> <li>Inserting columns</li> <li>Setting &amp; getting cell values</li> <li>Single-threaded environment</li> </ul> </li> </ul>"},{"location":"machine-coding/spreadsheet-flyweight/#problem-with-naive-design","title":"\u2757 Problem With Naive Design","text":"<p>In a large spreadsheet:</p> <ul> <li>Millions of cells</li> <li>Thousands of cells share the same style</li> </ul> <p>\u274c Naive approach creates duplicate style objects \u27a1\ufe0f Massive memory waste</p>"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-pattern-solution","title":"\u2705 Flyweight Pattern Solution","text":""},{"location":"machine-coding/spreadsheet-flyweight/#core-idea","title":"Core Idea","text":"<p>Separate intrinsic (shared) state from extrinsic (per-cell) state</p> State Type Stored Where Style (font, size, bold, italic) Shared Flyweight Text + position Individual Cell"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-architecture","title":"\ud83e\udde0 Flyweight Architecture","text":"<pre><code>Cell \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba StyleFlyweight\n                 \u25b2\n                 \u2502\n          StyleFlyweightFactory\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#data-model","title":"\ud83e\uddf1 Data Model","text":""},{"location":"machine-coding/spreadsheet-flyweight/#style-flyweight-shared","title":"\ud83c\udfa8 Style Flyweight (Shared)","text":"<pre><code>class StyleFlyweight {\n    final String fontName;\n    final int fontSize;\n    final boolean isBold;\n    final boolean isItalic;\n\n    StyleFlyweight(String fontName, int fontSize,\n                   boolean isBold, boolean isItalic) {\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#flyweight-factory","title":"\ud83c\udfed Flyweight Factory","text":"<pre><code>class StyleFactory {\n\n    private static final Map&lt;String, StyleFlyweight&gt; cache = new HashMap&lt;&gt;();\n\n    public static StyleFlyweight getStyle(String fontName, int fontSize,\n                                          boolean isBold, boolean isItalic) {\n\n        String key = fontName + \"|\" + fontSize + \"|\" + isBold + \"|\" + isItalic;\n\n        if (!cache.containsKey(key)) {\n            cache.put(key, new StyleFlyweight(\n                    fontName, fontSize, isBold, isItalic\n            ));\n        }\n        return cache.get(key);\n    }\n}\n</code></pre> <p>\u2714 Ensures only one instance per unique style</p>"},{"location":"machine-coding/spreadsheet-flyweight/#cell-extrinsic-state-only","title":"\ud83e\udde9 Cell (Extrinsic State Only)","text":"<pre><code>class Cell {\n    String text;\n    StyleFlyweight style;\n\n    Cell(String text, StyleFlyweight style) {\n        this.text = text;\n        this.style = style;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#spreadsheet-implementation-flyweight","title":"\ud83c\udfd7\ufe0f Spreadsheet Implementation (Flyweight)","text":"<pre><code>import java.util.*;\n\npublic class Spreadsheet {\n\n    private List&lt;List&lt;Cell&gt;&gt; sheet;\n    private int rows;\n    private int cols;\n\n    // ---------- Initialization ----------\n    public Spreadsheet() {\n        rows = 5;\n        cols = 5;\n        sheet = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; rows; i++) {\n            sheet.add(new ArrayList&lt;&gt;(Collections.nCopies(cols, null)));\n        }\n    }\n\n    // ---------- Add Row ----------\n    public void addRow(int index) {\n        if (index &lt; 0 || index &gt; rows) return;\n\n        sheet.add(index, new ArrayList&lt;&gt;(Collections.nCopies(cols, null)));\n        rows++;\n    }\n\n    // ---------- Add Column ----------\n    public void addColumn(int index) {\n        if (index &lt; 0 || index &gt; cols) return;\n\n        for (List&lt;Cell&gt; row : sheet) {\n            row.add(index, null);\n        }\n        cols++;\n    }\n\n    // ---------- Add / Replace Entry ----------\n    public void addEntry(int row, int col, String text,\n                         String fontName, int fontSize,\n                         boolean isBold, boolean isItalic) {\n\n        if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols) return;\n\n        StyleFlyweight style =\n                StyleFactory.getStyle(fontName, fontSize, isBold, isItalic);\n\n        sheet.get(row).set(col, new Cell(text, style));\n    }\n\n    // ---------- Get Entry ----------\n    public String getEntry(int row, int col) {\n        if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols) return \"\";\n\n        Cell cell = sheet.get(row).get(col);\n        if (cell == null) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(cell.text)\n          .append(\"-\")\n          .append(cell.style.fontName)\n          .append(\"-\")\n          .append(cell.style.fontSize);\n\n        if (cell.style.isBold) sb.append(\"-b\");\n        if (cell.style.isItalic) sb.append(\"-i\");\n\n        return sb.toString();\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet-flyweight/#example","title":"\ud83e\uddea Example","text":"<pre><code>addEntry(0, 0, \"hello\", \"tahoma\", 24, true, false);\naddEntry(1, 1, \"world\", \"tahoma\", 24, true, false);\n</code></pre> <p>\u2714 Both cells share the same StyleFlyweight instance</p>"},{"location":"machine-coding/spreadsheet-flyweight/#memory-impact","title":"\ud83d\udca1 Memory Impact","text":"Design Style Objects Naive rows \u00d7 cols Flyweight unique styles only <p>\ud83d\udcc9 Huge memory reduction</p>"},{"location":"machine-coding/spreadsheet-flyweight/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Flyweight Pattern \u2192 style sharing</li> <li>Factory Pattern \u2192 controlled creation</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> </ul>"},{"location":"machine-coding/spreadsheet-flyweight/#interview-explanation-perfect-answer","title":"\ud83c\udfaf Interview Explanation (Perfect Answer)","text":"<p>\u201cEach cell stores only text and a reference to a shared immutable style object created via a Flyweight factory, drastically reducing memory usage.\u201d</p>"},{"location":"machine-coding/spreadsheet-flyweight/#repo-structure-recommendation","title":"\ud83d\udcc2 Repo Structure Recommendation","text":""},{"location":"machine-coding/spreadsheet/","title":"25. Design a Spreadsheet (Excel-like)","text":""},{"location":"machine-coding/spreadsheet/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory spreadsheet system similar to Microsoft Excel.</p> <p>The spreadsheet supports:</p> <ul> <li>Dynamic insertion of rows and columns</li> <li>Each cell storing text + style</li> <li>Deterministic access to any cell</li> <li>Single-threaded execution</li> </ul>"},{"location":"machine-coding/spreadsheet/#initialization-rules","title":"\ud83d\udd22 Initialization Rules","text":"<ul> <li>Initial size: 5 rows \u00d7 5 columns</li> <li>Rows and columns are 0-indexed</li> <li>All cells start empty</li> <li>Empty cell returns an empty string</li> </ul>"},{"location":"machine-coding/spreadsheet/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/spreadsheet/#core-ideas","title":"Core Ideas","text":"<ul> <li>Spreadsheet modeled as a 2D dynamic structure</li> <li> <p>Each cell encapsulates:</p> <ul> <li>text</li> <li>font name</li> <li>font size</li> <li>bold / italic flags</li> <li>Insertions shift existing rows/columns automatically</li> </ul> </li> </ul>"},{"location":"machine-coding/spreadsheet/#data-model","title":"\ud83e\uddf1 Data Model","text":""},{"location":"machine-coding/spreadsheet/#cell-structure","title":"Cell Structure","text":"<pre><code>class Cell {\n    String text;\n    String fontName;\n    int fontSize;\n    boolean isBold;\n    boolean isItalic;\n\n    Cell(String text, String fontName, int fontSize,\n         boolean isBold, boolean isItalic) {\n        this.text = text;\n        this.fontName = fontName;\n        this.fontSize = fontSize;\n        this.isBold = isBold;\n        this.isItalic = isItalic;\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet/#complete-java-implementation","title":"\ud83c\udfd7\ufe0f Complete Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Spreadsheet {\n\n    private List&lt;List&lt;Cell&gt;&gt; sheet;\n    private int rows;\n    private int cols;\n\n    // ---------- Initialization ----------\n    public Spreadsheet() {\n        rows = 5;\n        cols = 5;\n        sheet = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; rows; i++) {\n            List&lt;Cell&gt; row = new ArrayList&lt;&gt;(Collections.nCopies(cols, null));\n            sheet.add(row);\n        }\n    }\n\n    // ---------- Add Row ----------\n    public void addRow(int index) {\n        if (index &lt; 0 || index &gt; rows) return;\n\n        List&lt;Cell&gt; newRow = new ArrayList&lt;&gt;(Collections.nCopies(cols, null));\n        sheet.add(index, newRow);\n        rows++;\n    }\n\n    // ---------- Add Column ----------\n    public void addColumn(int index) {\n        if (index &lt; 0 || index &gt; cols) return;\n\n        for (List&lt;Cell&gt; row : sheet) {\n            row.add(index, null);\n        }\n        cols++;\n    }\n\n    // ---------- Add / Replace Entry ----------\n    public void addEntry(int row, int column, String text,\n                         String fontName, int fontSize,\n                         boolean isBold, boolean isItalic) {\n\n        if (row &lt; 0 || row &gt;= rows || column &lt; 0 || column &gt;= cols) return;\n\n        sheet.get(row).set(\n                column,\n                new Cell(text, fontName, fontSize, isBold, isItalic)\n        );\n    }\n\n    // ---------- Get Entry ----------\n    public String getEntry(int row, int column) {\n        if (row &lt; 0 || row &gt;= rows || column &lt; 0 || column &gt;= cols) {\n            return \"\";\n        }\n\n        Cell cell = sheet.get(row).get(column);\n        if (cell == null) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(cell.text)\n          .append(\"-\")\n          .append(cell.fontName)\n          .append(\"-\")\n          .append(cell.fontSize);\n\n        if (cell.isBold) sb.append(\"-b\");\n        if (cell.isItalic) sb.append(\"-i\");\n\n        return sb.toString();\n    }\n}\n</code></pre>"},{"location":"machine-coding/spreadsheet/#method-behavior-summary","title":"\ud83d\udccc Method Behavior Summary","text":""},{"location":"machine-coding/spreadsheet/#addrowindex","title":"addRow(index)","text":"<ul> <li>Inserts a new empty row at the given index</li> <li>Existing rows shift downward</li> </ul>"},{"location":"machine-coding/spreadsheet/#addcolumnindex","title":"addColumn(index)","text":"<ul> <li>Inserts a new empty column at the given index</li> <li>Existing columns shift right</li> </ul>"},{"location":"machine-coding/spreadsheet/#addentryrow-column","title":"addEntry(row, column, ...)","text":"<ul> <li>Creates or replaces a cell</li> <li>Overwrites any existing cell at the location</li> </ul>"},{"location":"machine-coding/spreadsheet/#getentryrow-column","title":"getEntry(row, column)","text":"<ul> <li>Returns formatted string:</li> </ul> <p><pre><code>text-fontName-fontSize[-b][-i]\n</code></pre> * Returns empty string if cell is empty</p>"},{"location":"machine-coding/spreadsheet/#example-walkthrough","title":"\u2705 Example Walkthrough","text":"<pre><code>addRow(5);\naddEntry(5, 0, \"hello\", \"tahoma\", 24, true, false);\ngetEntry(5, 0); \n// \"hello-tahoma-24-b\"\n\naddColumn(2);\naddEntry(0, 1, \"x\", \"calibri\", 10, false, true);\ngetEntry(0, 1);\n// \"x-calibri-10-i\"\n</code></pre>"},{"location":"machine-coding/spreadsheet/#time-space-complexity","title":"\u23f1\ufe0f Time &amp; Space Complexity","text":"Operation Complexity addRow O(columns) addColumn O(rows) addEntry O(1) getEntry O(1) Space O(rows \u00d7 columns)"},{"location":"machine-coding/spreadsheet/#design-patterns-interview-bonus","title":"\ud83e\udde0 Design Patterns (Interview Bonus)","text":"<ul> <li>Flyweight Pattern   Share identical style objects to reduce memory usage</li> <li>Command Pattern   Enables undo/redo functionality</li> <li>MVC Architecture   Separate data model from UI rendering</li> </ul>"},{"location":"machine-coding/spreadsheet/#interview-one-liner","title":"\ud83c\udfaf Interview One-Liner","text":"<p>\u201cI modeled the spreadsheet as a dynamic 2D structure with deterministic row/column shifting and constant-time cell access.\u201d</p>"},{"location":"machine-coding/text-editor-word-processor/","title":"\ud83d\udcdd Design a Text Editor / Word Processor (Microsoft Word)","text":""},{"location":"machine-coding/text-editor-word-processor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor / word processor similar to Microsoft Word or WordPad.</p> <p>The document:</p> <ul> <li>Has any number of rows</li> <li>Each row has any number of columns</li> <li>Each character has its own style</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#character-style-attributes","title":"Character Style Attributes","text":"<ul> <li>Font Name</li> <li>Font Size</li> <li>Bold</li> <li>Italic</li> </ul> <p>The system must support:</p> <ul> <li>Adding characters</li> <li>Deleting characters</li> <li>Reading rows</li> <li>Fetching style of a specific character</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#key-design-decisions","title":"\ud83e\udde0 Key Design Decisions","text":""},{"location":"machine-coding/text-editor-word-processor/#1-row-based-storage","title":"1\ufe0f\u20e3 Row-based storage","text":"<ul> <li>Each row is stored independently</li> <li>Rows are dynamically created</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#2-character-level-styling","title":"2\ufe0f\u20e3 Character-level styling","text":"<ul> <li>Each character is wrapped in a <code>StyledChar</code> object</li> <li>Style stays bound to the character even after shifts</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#3-insert-delete-via-shifting","title":"3\ufe0f\u20e3 Insert &amp; Delete via shifting","text":"<ul> <li>Insert \u2192 shift characters to the right</li> <li>Delete \u2192 shift characters to the left</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":"<pre><code>Document\n \u2514\u2500\u2500 List&lt;Row&gt;\n      \u2514\u2500\u2500 List&lt;StyledChar&gt;\n\nStyledChar\n \u251c\u2500\u2500 char value\n \u251c\u2500\u2500 fontName\n \u251c\u2500\u2500 fontSize\n \u251c\u2500\u2500 isBold\n \u2514\u2500\u2500 isItalic\n</code></pre>"},{"location":"machine-coding/text-editor-word-processor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class Solution {\n\n    // Helper is provided by the platform\n    private Helper09 helper;\n\n    // Each row is a list of styled characters\n    private List&lt;List&lt;StyledChar&gt;&gt; document = new ArrayList&lt;&gt;();\n\n    // ---------------- init ----------------\n    public void init(Helper09 helper) {\n        this.helper = helper;\n    }\n\n    // ---------------- Styled Character ----------------\n    static class StyledChar {\n        char ch;\n        String fontName;\n        int fontSize;\n        boolean bold;\n        boolean italic;\n\n        StyledChar(char ch, String fontName, int fontSize, boolean bold, boolean italic) {\n            this.ch = ch;\n            this.fontName = fontName;\n            this.fontSize = fontSize;\n            this.bold = bold;\n            this.italic = italic;\n        }\n\n        String styleString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(ch)\n              .append(\"-\")\n              .append(fontName)\n              .append(\"-\")\n              .append(fontSize);\n\n            if (bold) sb.append(\"-b\");\n            if (italic) sb.append(\"-i\");\n\n            return sb.toString();\n        }\n    }\n\n    // ---------------- addCharacter ----------------\n    public void addCharacter(\n            int row, int column, char ch,\n            String fontName, int fontSize,\n            boolean isBold, boolean isItalic) {\n\n        // Ensure enough rows exist\n        while (document.size() &lt;= row) {\n            document.add(new ArrayList&lt;&gt;());\n        }\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        StyledChar newChar = new StyledChar(ch, fontName, fontSize, isBold, isItalic);\n\n        // Insert or append\n        if (column &gt;= currentRow.size()) {\n            currentRow.add(newChar);\n        } else {\n            currentRow.add(column, newChar);\n        }\n    }\n\n    // ---------------- getStyle ----------------\n    public String getStyle(int row, int col) {\n        if (row &gt;= document.size()) return \"\";\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        if (col &gt;= currentRow.size()) return \"\";\n\n        return currentRow.get(col).styleString();\n    }\n\n    // ---------------- readLine ----------------\n    public String readLine(int row) {\n        if (row &gt;= document.size()) return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        for (StyledChar sc : document.get(row)) {\n            sb.append(sc.ch);\n        }\n        return sb.toString();\n    }\n\n    // ---------------- deleteCharacter ----------------\n    public boolean deleteCharacter(int row, int col) {\n        if (row &gt;= document.size()) return false;\n\n        List&lt;StyledChar&gt; currentRow = document.get(row);\n        if (col &gt;= currentRow.size()) return false;\n\n        currentRow.remove(col);\n        return true;\n    }\n}\n</code></pre>"},{"location":"machine-coding/text-editor-word-processor/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Adding characters beyond current rows</li> <li>Adding characters beyond current column length</li> <li>Reading empty rows</li> <li>Deleting non-existing characters</li> <li>Style preserved correctly after insert/delete shifts</li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Complexity addCharacter O(n) (row shift) deleteCharacter O(n) (row shift) getStyle O(1) readLine O(n) <p>Space Complexity: O(total characters)</p>"},{"location":"machine-coding/text-editor-word-processor/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<ul> <li>This is a Flyweight-friendly design (styles can be shared later)</li> <li>Clean separation of data + behavior</li> <li> <p>Easily extensible for:</p> <ul> <li>Undo / Redo</li> <li>Copy / Paste</li> <li>Rich formatting blocks</li> <li>Paragraph styles</li> </ul> </li> </ul>"},{"location":"machine-coding/text-editor-word-processor/#next-enhancements-optional","title":"\ud83d\udccc Next Enhancements (Optional)","text":"<ul> <li>Undo / Redo using Command pattern</li> <li>Cursor abstraction</li> <li>Range styling (apply style to multiple characters)</li> <li>Paragraph &amp; alignment support</li> </ul>"},{"location":"machine-coding/text-editor/","title":"Design a Text Editor with Undo &amp; Redo","text":""},{"location":"machine-coding/text-editor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor that:</p> <ul> <li>Stores text row-wise (line by line)</li> <li>Supports insert and delete operations on a single row</li> <li>Supports Undo and Redo</li> <li>Maintains edit history correctly</li> <li>Does NOT remove empty rows</li> </ul> <p>Each operation modifies exactly one row.</p>"},{"location":"machine-coding/text-editor/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/text-editor/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Insert text at a given row and column</li> <li>Delete text from a given row and column range</li> <li>Undo the most recent change</li> <li>Redo the most recently undone change</li> <li>Read the content of a row at any time</li> </ul>"},{"location":"machine-coding/text-editor/#key-observations","title":"Key Observations","text":"<ul> <li>Undo/Redo works best with Command Pattern</li> <li>Each edit operation should know how to execute and undo</li> <li>Redo history must be cleared after any new edit</li> </ul>"},{"location":"machine-coding/text-editor/#design-patterns-principles-used","title":"\ud83c\udfd7\ufe0f Design Patterns &amp; Principles Used","text":"<ul> <li>Command Pattern \u2192 Encapsulates edit operations</li> <li>Stack-based Undo/Redo</li> <li>Single Responsibility Principle</li> <li>Encapsulation</li> </ul>"},{"location":"machine-coding/text-editor/#data-model","title":"\ud83d\uddc2\ufe0f Data Model","text":"<pre><code>TextEditor\n\u251c\u2500\u2500 List&lt;StringBuilder&gt; rows\n\u251c\u2500\u2500 Stack&lt;Command&gt; undoStack\n\u251c\u2500\u2500 Stack&lt;Command&gt; redoStack\n\nCommand (interface)\n\u251c\u2500\u2500 execute()\n\u251c\u2500\u2500 undo()\n\nAddTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 column\n\u251c\u2500\u2500 text\n\nDeleteTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 startColumn\n\u251c\u2500\u2500 deletedText\n</code></pre>"},{"location":"machine-coding/text-editor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class TextEditor {\n\n    private final List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();\n    private final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();\n    private final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();\n\n    /* ==================== PUBLIC APIs ==================== */\n\n    public void addText(int row, int column, String text) {\n        ensureRowExists(row);\n\n        Command cmd = new AddTextCommand(row, column, text);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void deleteText(int row, int startColumn, int length) {\n        Command cmd = new DeleteTextCommand(row, startColumn, length);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void undo() {\n        if (undoStack.isEmpty()) return;\n\n        Command cmd = undoStack.pop();\n        cmd.undo();\n        redoStack.push(cmd);\n    }\n\n    public void redo() {\n        if (redoStack.isEmpty()) return;\n\n        Command cmd = redoStack.pop();\n        cmd.execute();\n        undoStack.push(cmd);\n    }\n\n    public String readLine(int row) {\n        return rows.get(row).toString();\n    }\n\n    /* ==================== INTERNAL HELPERS ==================== */\n\n    private void ensureRowExists(int row) {\n        while (rows.size() &lt;= row) {\n            rows.add(new StringBuilder());\n        }\n    }\n\n    /* ==================== COMMAND INTERFACE ==================== */\n\n    private interface Command {\n        void execute();\n        void undo();\n    }\n\n    /* ==================== ADD TEXT COMMAND ==================== */\n\n    private class AddTextCommand implements Command {\n        private final int row;\n        private final int column;\n        private final String text;\n\n        AddTextCommand(int row, int column, String text) {\n            this.row = row;\n            this.column = column;\n            this.text = text;\n        }\n\n        @Override\n        public void execute() {\n            rows.get(row).insert(column, text);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).delete(column, column + text.length());\n        }\n    }\n\n    /* ==================== DELETE TEXT COMMAND ==================== */\n\n    private class DeleteTextCommand implements Command {\n        private final int row;\n        private final int startColumn;\n        private final int length;\n        private String deletedText;\n\n        DeleteTextCommand(int row, int startColumn, int length) {\n            this.row = row;\n            this.startColumn = startColumn;\n            this.length = length;\n        }\n\n        @Override\n        public void execute() {\n            StringBuilder sb = rows.get(row);\n            deletedText = sb.substring(startColumn, startColumn + length);\n            sb.delete(startColumn, startColumn + length);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).insert(startColumn, deletedText);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/","title":"Design a Tic-Tac-Toe Game (NxN)","text":""},{"location":"machine-coding/tic-tac-toe/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a class <code>TicTacGame</code> that simulates a Tic-Tac-Toe game played on an m \u00d7 m board between two players.</p>"},{"location":"machine-coding/tic-tac-toe/#rules","title":"Rules","text":"<ul> <li>Players take turns placing marks on empty cells.</li> <li>Player 1 uses A, Player 2 uses B.</li> <li>The first player to place m consecutive symbols in:</li> <li>a row</li> <li>a column</li> <li>a diagonal   wins the game.</li> <li>Once a player wins, no further moves are allowed.</li> <li>Every subsequent move must return the same winner.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/tic-tac-toe/#key-observations","title":"Key Observations","text":"<ul> <li>Full board storage is not required.</li> <li>Each move affects:</li> <li>one row</li> <li>one column</li> <li>possibly two diagonals</li> <li>Winning can be checked in O(1) time.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#data-structures-used","title":"\ud83c\udfd7\ufe0f Data Structures Used","text":"Structure Purpose <code>int[] rows</code> Row-wise score tracking <code>int[] cols</code> Column-wise score tracking <code>int diag</code> Main diagonal score <code>int antiDiag</code> Anti-diagonal score <code>boolean gameOver</code> Locks the game after win <code>int winner</code> Stores the winning player"},{"location":"machine-coding/tic-tac-toe/#scoring-technique","title":"Scoring Technique","text":"<ul> <li>Player 1 \u2192 <code>+1</code></li> <li>Player 2 \u2192 <code>-1</code></li> <li>If absolute value reaches <code>m</code>, that player wins.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State Management</li> <li>Optimized Win Detection</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class TicTacGame {\n\n    private int m;\n    private int[] rows;\n    private int[] cols;\n    private int diag;\n    private int antiDiag;\n    private boolean gameOver;\n    private int winner;\n\n    public TicTacGame(int m) {\n        this.m = m;\n        this.rows = new int[m];\n        this.cols = new int[m];\n        this.diag = 0;\n        this.antiDiag = 0;\n        this.gameOver = false;\n        this.winner = 0;\n    }\n\n    /**\n     * @param row    row index\n     * @param col    column index\n     * @param player 1 or 2\n     * @return 0 = no winner, 1 = player 1 wins, 2 = player 2 wins\n     */\n    public int doMove(int row, int col, int player) {\n\n        // If game already ended, always return winner\n        if (gameOver) {\n            return winner;\n        }\n\n        int val = (player == 1) ? 1 : -1;\n\n        rows[row] += val;\n        cols[col] += val;\n\n        if (row == col) {\n            diag += val;\n        }\n\n        if (row + col == m - 1) {\n            antiDiag += val;\n        }\n\n        if (Math.abs(rows[row]) == m ||\n            Math.abs(cols[col]) == m ||\n            Math.abs(diag) == m ||\n            Math.abs(antiDiag) == m) {\n\n            gameOver = true;\n            winner = player;\n            return player;\n        }\n\n        return 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Winning by row, column, or diagonal</li> <li>Game lock after win</li> <li>Repeated moves return same winner</li> <li>Works for large boards (<code>m \u2264 200</code>)</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Space <code>doMove()</code> O(1) O(m)"},{"location":"machine-coding/tic-tac-toe/#example","title":"\ud83e\uddea Example","text":"<pre><code>TicTacGame game = new TicTacGame(2);\n\ngame.doMove(0, 1, 1); // 0\ngame.doMove(0, 0, 2); // 0\ngame.doMove(1, 1, 1); // 1 (Player 1 wins)\ngame.doMove(1, 0, 2); // 1 (Winner persists)\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#interview-notes","title":"\u2705 Interview Notes","text":"<ul> <li>Classic LLD + algorithm optimization problem</li> <li>Demonstrates clean state handling</li> <li>Shows ability to avoid brute-force board scanning</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Undo / Redo support</li> <li>Move history tracking</li> <li>UI rendering</li> <li>Multiplayer support</li> </ul>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Low Level Design (LLD) \u2013 Machine Coding Practice","text":"<p>This repository contains production-style LLD solutions written in Java.</p>"},{"location":"#what-youll-find","title":"\ud83d\udccc What you\u2019ll find","text":"<ul> <li>Clear problem statements</li> <li>Design patterns used (Strategy, Observer, Command, etc.)</li> <li>Clean, interview-ready Java implementations</li> <li>Edge cases &amp; complexity discussion</li> </ul>"},{"location":"#topics-covered","title":"\ud83e\udde0 Topics Covered","text":"<ul> <li>Car Rental System</li> <li>Rate Limiter</li> <li>Text Editor (Undo/Redo)</li> <li>Meeting Room Scheduler</li> <li>Publish Subscribe System</li> <li>Custom HashMap</li> <li>And more\u2026</li> </ul> <p>\ud83d\udc49 Use the left navigation to explore problems.</p>"},{"location":"machine-coding/banking-system/","title":"Design a Complete Banking System","text":""},{"location":"machine-coding/banking-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory banking system that supports:</p>"},{"location":"machine-coding/banking-system/#level-1-basic-operations","title":"Level 1 \u2013 Basic Operations","text":"<ul> <li>Create accounts</li> <li>Deposit money</li> <li>Transfer money between accounts</li> </ul>"},{"location":"machine-coding/banking-system/#level-2-ranking","title":"Level 2 \u2013 Ranking","text":"<ul> <li>Return top spenders based on outgoing transactions</li> </ul>"},{"location":"machine-coding/banking-system/#level-3-scheduled-payments","title":"Level 3 \u2013 Scheduled Payments","text":"<ul> <li>Schedule payments with cashback</li> <li>Track payment status</li> <li>Process scheduled payments</li> </ul>"},{"location":"machine-coding/banking-system/#level-4-account-merging","title":"Level 4 \u2013 Account Merging","text":"<ul> <li>Merge two accounts into one</li> <li>Preserve balances, transaction history, and scheduled payments</li> </ul> <p>All operations are timestamp-based and executed in memory.</p>"},{"location":"machine-coding/banking-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":"<p>The system models real-world banking behavior: - Each Account owns its balance, outgoing total, and scheduled payments - Payments transition through lifecycle states - Rankings are computed using outgoing totals - Merging accounts preserves financial correctness</p>"},{"location":"machine-coding/banking-system/#core-entities","title":"\ud83c\udfd7\ufe0f Core Entities","text":""},{"location":"machine-coding/banking-system/#account","title":"Account","text":"<pre><code>class Account {\n    String accountId;\n    int balance;\n    int totalOutgoing;\n    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();\n\n    Account(String accountId) {\n        this.accountId = accountId;\n        this.balance = 0;\n        this.totalOutgoing = 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#payment","title":"Payment","text":"<pre><code>class Payment {\n    String paymentId;\n    String fromAccount;\n    String toAccount;\n    int amount;\n    double cashbackPercentage;\n    int scheduledTime;\n    PaymentStatus status;\n\n    Payment(String paymentId, String from, String to, int amount,\n            double cashback, int time) {\n        this.paymentId = paymentId;\n        this.fromAccount = from;\n        this.toAccount = to;\n        this.amount = amount;\n        this.cashbackPercentage = cashback;\n        this.scheduledTime = time;\n        this.status = PaymentStatus.SCHEDULED;\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#paymentstatus","title":"PaymentStatus","text":"<pre><code>enum PaymentStatus {\n    SCHEDULED,\n    PROCESSED,\n    FAILED\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#full-java-implementation","title":"\ud83d\udcbb Full Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class BankingSystem {\n\n    private Map&lt;String, Account&gt; accounts = new HashMap&lt;&gt;();\n    private int paymentCounter = 1;\n\n    // ---------------- LEVEL 1 ----------------\n\n    public boolean createAccount(String accountId, int timestamp) {\n        if (accounts.containsKey(accountId)) return false;\n        accounts.put(accountId, new Account(accountId));\n        return true;\n    }\n\n    public Optional&lt;Integer&gt; deposit(String accountId, int timestamp, int amount) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return Optional.empty();\n        acc.balance += amount;\n        return Optional.of(acc.balance);\n    }\n\n    public Optional&lt;Integer&gt; transfer(String fromId, String toId, int timestamp, int amount) {\n        Account from = accounts.get(fromId);\n        Account to = accounts.get(toId);\n\n        if (from == null || to == null || from.balance &lt; amount) {\n            return Optional.empty();\n        }\n\n        from.balance -= amount;\n        to.balance += amount;\n        from.totalOutgoing += amount;\n\n        return Optional.of(from.balance);\n    }\n\n    // ---------------- LEVEL 2 ----------------\n\n    public List&lt;String&gt; topSpenders(int timestamp, int n) {\n        List&lt;Account&gt; list = new ArrayList&lt;&gt;(accounts.values());\n\n        list.sort((a, b) -&gt; {\n            if (b.totalOutgoing != a.totalOutgoing) {\n                return b.totalOutgoing - a.totalOutgoing;\n            }\n            return a.accountId.compareTo(b.accountId);\n        });\n\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; Math.min(n, list.size()); i++) {\n            result.add(list.get(i).accountId);\n        }\n        return result;\n    }\n\n    // ---------------- LEVEL 3 ----------------\n\n    public void schedulePayment(String accountId, String targetAccId,\n                                int timestamp, int amount, double cashbackPercentage) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return;\n\n        String paymentId = \"PAY-\" + paymentCounter++;\n        Payment payment = new Payment(\n                paymentId, accountId, targetAccId,\n                amount, cashbackPercentage, timestamp\n        );\n\n        acc.payments.add(payment);\n    }\n\n    public void processScheduledPayments(int currentTimestamp) {\n        for (Account acc : accounts.values()) {\n            for (Payment p : acc.payments) {\n                if (p.status != PaymentStatus.SCHEDULED) continue;\n                if (p.scheduledTime &gt; currentTimestamp) continue;\n\n                Account from = accounts.get(p.fromAccount);\n                Account to = accounts.get(p.toAccount);\n\n                if (from == null || to == null || from.balance &lt; p.amount) {\n                    p.status = PaymentStatus.FAILED;\n                    continue;\n                }\n\n                from.balance -= p.amount;\n                to.balance += p.amount;\n                from.totalOutgoing += p.amount;\n\n                int cashback = (int) (p.amount * p.cashbackPercentage / 100.0);\n                from.balance += cashback;\n\n                p.status = PaymentStatus.PROCESSED;\n            }\n        }\n    }\n\n    public String getPaymentStatus(String accountId, int timestamp, String paymentId) {\n        Account acc = accounts.get(accountId);\n        if (acc == null) return \"NOT_FOUND\";\n\n        for (Payment p : acc.payments) {\n            if (p.paymentId.equals(paymentId)) {\n                return p.status.name();\n            }\n        }\n        return \"NOT_FOUND\";\n    }\n\n    // ---------------- LEVEL 4 ----------------\n\n    public void mergeAccounts(String accountId1, String accountId2) {\n        if (!accounts.containsKey(accountId1) || !accounts.containsKey(accountId2)) {\n            return;\n        }\n\n        Account a1 = accounts.get(accountId1);\n        Account a2 = accounts.get(accountId2);\n\n        a1.balance += a2.balance;\n        a1.totalOutgoing += a2.totalOutgoing;\n        a1.payments.addAll(a2.payments);\n\n        accounts.remove(accountId2);\n    }\n}\n</code></pre>"},{"location":"machine-coding/banking-system/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>Aggregation (Account owns Payments)</li> <li>Domain Driven Design</li> <li>Command-style processing (timestamp-based)</li> </ul>"},{"location":"machine-coding/banking-system/#edge-cases-covered","title":"\u26a0\ufe0f Edge Cases Covered","text":"<ul> <li>Duplicate account creation</li> <li>Insufficient balance transfers</li> <li>Payment failures</li> <li>Cashback calculation</li> <li>Ranking ties</li> <li>Merging accounts with active payments</li> </ul>"},{"location":"machine-coding/banking-system/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity Create Account O(1) Deposit O(1) Transfer O(1) Top Spenders O(N log N) Schedule Payment O(1) Process Payments O(P) Merge Accounts O(P)"},{"location":"machine-coding/banking-system/#interview-notes","title":"\u2705 Interview Notes","text":"<p>Why store <code>List&lt;Payment&gt;</code> inside Account?</p> <p>Payments are owned by the account that initiates them. This simplifies lookup, merging, validation, and lifecycle management.</p>"},{"location":"machine-coding/banking-system/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Transaction history</li> <li>Interest calculation</li> <li>Account limits</li> <li>Fraud detection</li> <li>Persistent storage</li> </ul>"},{"location":"machine-coding/car-rental-system/","title":"Design a Car Rental System","text":""},{"location":"machine-coding/car-rental-system/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a car rental service that supports: - Full-day bookings - Kilometer-based pricing - Booking overlap checks - Early return &amp; delayed return handling</p>"},{"location":"machine-coding/car-rental-system/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/car-rental-system/#entities","title":"Entities","text":"<ul> <li>Car</li> <li>Order</li> <li>Trip</li> </ul>"},{"location":"machine-coding/car-rental-system/#key-rules","title":"Key Rules","text":"<ul> <li>Inclusive date ranges</li> <li>Effective end date = max(bookedTill, actualReturnDate)</li> <li>Extra kms charged beyond daily free allowance</li> </ul>"},{"location":"machine-coding/car-rental-system/#design-patterns-used","title":"\ud83c\udfd7\ufe0f Design Patterns Used","text":"<ul> <li>Single Responsibility Principle</li> <li>Encapsulation</li> <li>(Optional) Strategy for pricing</li> </ul>"},{"location":"machine-coding/car-rental-system/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>// paste your CarRentalService code here\n</code></pre>"},{"location":"machine-coding/car-rental-system/#edge-cases","title":"\u26a0\ufe0f Edge Cases","text":"<ul> <li> <p>Overlapping bookings</p> </li> <li> <p>Early return</p> </li> <li> <p>Late return</p> </li> <li> <p>Same-day booking</p> </li> </ul>"},{"location":"machine-coding/car-rental-system/#complexity","title":"\u23f1\ufe0f Complexity","text":"<ul> <li> <p>Booking: O(n) per car</p> </li> <li> <p>End Trip: O(1)</p> </li> </ul>"},{"location":"machine-coding/in-memory-database/","title":"Design a Complete In-Memory Database","text":""},{"location":"machine-coding/in-memory-database/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory database that stores records identified by a <code>key</code>. Each record contains multiple fields, and each field stores a value.</p> <p>The system evolves across 4 levels:</p>"},{"location":"machine-coding/in-memory-database/#levels-breakdown","title":"\ud83e\udde9 Levels Breakdown","text":""},{"location":"machine-coding/in-memory-database/#level-1-basic-operations","title":"\u2705 Level 1 \u2013 Basic Operations","text":"<ul> <li>Set values</li> <li>Conditional updates</li> <li>Conditional deletes</li> <li>Get values</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-2-scanning-filtering","title":"\u2705 Level 2 \u2013 Scanning &amp; Filtering","text":"<ul> <li>Scan all fields for a key</li> <li>Scan fields by prefix</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-3-ttl-time-to-live","title":"\u2705 Level 3 \u2013 TTL (Time-To-Live)","text":"<ul> <li>Fields can expire after a given TTL</li> <li>Expired fields are invisible</li> </ul>"},{"location":"machine-coding/in-memory-database/#level-4-look-back-queries","title":"\u2705 Level 4 \u2013 Look-Back Queries","text":"<ul> <li>Retrieve field values as of a given timestamp</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/in-memory-database/#key-ideas","title":"Key Ideas","text":"<ul> <li>Multi-version storage per field</li> <li>Timestamp-aware writes</li> <li>Lazy expiration using TTL</li> <li>Sorted history for look-back</li> </ul>"},{"location":"machine-coding/in-memory-database/#core-data-model","title":"\ud83c\udfd7\ufe0f Core Data Model","text":""},{"location":"machine-coding/in-memory-database/#versionedvalue","title":"VersionedValue","text":"<p>Stores historical versions of a field.</p> <pre><code>class VersionedValue {\n    int timestamp;\n    String value;\n    Integer expiryTime; // null means no TTL\n\n    VersionedValue(int timestamp, String value, Integer expiryTime) {\n        this.timestamp = timestamp;\n        this.value = value;\n        this.expiryTime = expiryTime;\n    }\n\n    boolean isExpired(int currentTime) {\n        return expiryTime != null &amp;&amp; currentTime &gt;= expiryTime;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#database-structure","title":"Database Structure","text":"<pre><code>Map&lt;key,\n  Map&lt;\n    field,\n    List&lt;VersionedValue&gt;\n  &gt;\n&gt;\n</code></pre>"},{"location":"machine-coding/in-memory-database/#full-java-implementation-all-levels","title":"\ud83d\udcbb Full Java Implementation (All Levels)","text":"<pre><code>import java.util.*;\n\npublic class InMemoryDatabase {\n\n    private Map&lt;String, Map&lt;String, List&lt;VersionedValue&gt;&gt;&gt; db = new HashMap&lt;&gt;();\n\n    // ---------- LEVEL 1 ----------\n\n    public void set(int timestamp, String key, String field, String value) {\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, null));\n    }\n\n    public boolean compareAndSet(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        set(timestamp, key, field, curr);\n        return true;\n    }\n\n    public boolean compareAndDelete(int timestamp, String key, String field, int expectedValue) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        db.get(key).get(field)\n          .add(new VersionedValue(timestamp, null, null));\n        return true;\n    }\n\n    public String get(int timestamp, String key, String field) {\n        if (!db.containsKey(key) || !db.get(key).containsKey(field)) {\n            return null;\n        }\n        return getLatestValue(db.get(key).get(field), timestamp);\n    }\n\n    // ---------- LEVEL 2 ----------\n\n    public List&lt;String&gt; scan(int timestamp, String key) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    public List&lt;String&gt; scanByPrefix(int timestamp, String key, String prefix) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (!db.containsKey(key)) return result;\n\n        for (String field : db.get(key).keySet()) {\n            if (!field.startsWith(prefix)) continue;\n            String val = get(timestamp, key, field);\n            if (val != null) {\n                result.add(field + \"=\" + val);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    // ---------- LEVEL 3 ----------\n\n    public void setWithTTL(int timestamp, String key, String field, String value, int ttl) {\n        int expiry = timestamp + ttl;\n        db.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;())\n          .computeIfAbsent(field, f -&gt; new ArrayList&lt;&gt;())\n          .add(new VersionedValue(timestamp, value, expiry));\n    }\n\n    public boolean compareAndSetWithTTL(int timestamp, String key, String field,\n                                        int expectedValue, int newValue, int ttl) {\n        String curr = get(timestamp, key, field);\n        if (curr == null || !curr.equals(String.valueOf(expectedValue))) {\n            return false;\n        }\n        setWithTTL(timestamp, key, field, String.valueOf(newValue), ttl);\n        return true;\n    }\n\n    // ---------- HELPERS ----------\n\n    private String getLatestValue(List&lt;VersionedValue&gt; history, int timestamp) {\n        String result = null;\n        for (VersionedValue vv : history) {\n            if (vv.timestamp &gt; timestamp) break;\n            if (vv.isExpired(timestamp)) continue;\n            result = vv.value;\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"machine-coding/in-memory-database/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Field deletion using tombstones</li> <li>Expired values hidden automatically</li> <li>Prefix scans skip expired fields</li> <li>Look-back reads ignore future writes</li> <li>Multiple updates to same field</li> </ul>"},{"location":"machine-coding/in-memory-database/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Multi-Version Concurrency Control (MVCC)</li> <li>Encapsulation</li> <li>Single Responsibility Principle</li> <li>Lazy Expiration</li> <li>Time-based Snapshot Reads</li> </ul>"},{"location":"machine-coding/in-memory-database/#time-complexity","title":"\u23f1\ufe0f Time Complexity","text":"Operation Complexity set / get O(V) scan O(F \u00d7 V) scanByPrefix O(F \u00d7 V) TTL operations O(1) Look-back O(V) <p>F = fields per key, V = versions per field</p>"},{"location":"machine-coding/in-memory-database/#interview-notes","title":"\ud83c\udfaf Interview Notes","text":"<p>Why versioned values instead of overwriting?</p> <p>Enables:</p> <ul> <li>Look-back queries</li> <li>Safe TTL handling</li> <li>Historical correctness</li> </ul> <p>Why lazy TTL cleanup?</p> <p>Avoids background threads and keeps implementation deterministic.</p>"},{"location":"machine-coding/in-memory-database/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Background compaction</li> <li>Range queries</li> <li>Indexing for prefix scans</li> <li>Persistent WAL</li> <li>Concurrent access handling</li> </ul> <p>```</p>"},{"location":"machine-coding/snake-game/","title":"Design Snake Game","text":""},{"location":"machine-coding/snake-game/#problem-statement","title":"Problem Statement","text":"<p>Design a Snake game simulator played on a 2D grid.</p> <ul> <li>The grid has fixed dimensions <code>rows \u00d7 cols</code></li> <li>The snake starts at position <code>(0,0)</code> with length <code>1</code></li> <li> <p>The snake moves one step at a time in one of the directions:</p> <ul> <li><code>\"U\"</code> (up), <code>\"D\"</code> (down), <code>\"L\"</code> (left), <code>\"R\"</code> (right)</li> <li>Food positions are provided in advance and appear sequentially</li> <li> <p>When the snake eats food:</p> </li> <li> <p>Snake length increases by 1</p> </li> <li>Score increases by 1</li> <li> <p>The game ends if:</p> </li> <li> <p>The snake hits the wall</p> </li> <li>The snake hits itself</li> <li>After the game ends, all further moves must return <code>-1</code></li> </ul> </li> </ul>"},{"location":"machine-coding/snake-game/#design-overview","title":"Design Overview","text":"<p>The snake is represented as an ordered sequence of cells. Each move adds a new head and conditionally removes the tail.</p>"},{"location":"machine-coding/snake-game/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li>Use a Deque to represent the snake body</li> <li>Use a HashSet for fast self-collision detection</li> <li>Use a Queue to store food positions</li> <li>Maintain a <code>gameOver</code> flag to handle post-termination behavior</li> </ul>"},{"location":"machine-coding/snake-game/#data-structures","title":"Data Structures","text":"Purpose Structure Snake body <code>Deque&lt;Cell&gt;</code> Collision check <code>HashSet&lt;Cell&gt;</code> Food sequence <code>Queue&lt;Cell&gt;</code> Game state <code>boolean gameOver</code>"},{"location":"machine-coding/snake-game/#core-entities","title":"Core Entities","text":""},{"location":"machine-coding/snake-game/#cell","title":"Cell","text":"<p>Represents a position on the grid.</p> <pre><code>class Cell {\n    int row;\n    int col;\n\n    Cell(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Cell)) return false;\n        Cell cell = (Cell) o;\n        return row == cell.row &amp;&amp; col == cell.col;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#design-patterns-used","title":"Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State management via <code>gameOver</code> flag</li> <li>Efficient simulation using Deque</li> <li>HashSet for constant-time collision detection</li> </ul>"},{"location":"machine-coding/snake-game/#java-implementation","title":"Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class SnakeGame {\n\n    private int rows;\n    private int cols;\n    private Deque&lt;Cell&gt; snake;\n    private Set&lt;Cell&gt; occupied;\n    private Queue&lt;Cell&gt; foodQueue;\n    private int score;\n    private boolean gameOver;\n\n    public SnakeGame(int rows, int cols, String[] foodPositions) {\n        this.rows = rows;\n        this.cols = cols;\n        this.snake = new LinkedList&lt;&gt;();\n        this.occupied = new HashSet&lt;&gt;();\n        this.foodQueue = new LinkedList&lt;&gt;();\n        this.score = 0;\n        this.gameOver = false;\n\n        Cell start = new Cell(0, 0);\n        snake.addLast(start);\n        occupied.add(start);\n\n        for (String food : foodPositions) {\n            String[] parts = food.split(\",\");\n            foodQueue.offer(\n                new Cell(\n                    Integer.parseInt(parts[0]),\n                    Integer.parseInt(parts[1])\n                )\n            );\n        }\n    }\n\n    public int move(String direction) {\n        if (gameOver) {\n            return -1;\n        }\n\n        Cell head = snake.peekLast();\n        int r = head.row;\n        int c = head.col;\n\n        switch (direction) {\n            case \"U\": r--; break;\n            case \"D\": r++; break;\n            case \"L\": c--; break;\n            case \"R\": c++; break;\n        }\n\n        Cell newHead = new Cell(r, c);\n\n        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) {\n            gameOver = true;\n            return -1;\n        }\n\n        boolean eatsFood =\n            !foodQueue.isEmpty() &amp;&amp; foodQueue.peek().equals(newHead);\n\n        if (!eatsFood) {\n            Cell tail = snake.pollFirst();\n            occupied.remove(tail);\n        }\n\n        if (occupied.contains(newHead)) {\n            gameOver = true;\n            return -1;\n        }\n\n        snake.addLast(newHead);\n        occupied.add(newHead);\n\n        if (eatsFood) {\n            foodQueue.poll();\n            score++;\n        }\n\n        return score;\n    }\n}\n</code></pre>"},{"location":"machine-coding/snake-game/#edge-cases-handled","title":"Edge Cases Handled","text":"<ul> <li>Wall collision</li> <li>Self collision</li> <li>Moves after game over</li> <li>No food scenario</li> <li>Snake moving into previous tail position</li> <li>Empty food list</li> </ul>"},{"location":"machine-coding/snake-game/#time-and-space-complexity","title":"Time and Space Complexity","text":""},{"location":"machine-coding/snake-game/#movedirection","title":"move(direction)","text":"<ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(rows \u00d7 cols)</li> </ul>"},{"location":"machine-coding/snake-game/#example","title":"Example","text":"<pre><code>SnakeGame game = new SnakeGame(2, 2, new String[]{});\n\ngame.move(\"R\"); // 0\ngame.move(\"D\"); // 0\ngame.move(\"R\"); // -1\ngame.move(\"U\"); // -1\n</code></pre>"},{"location":"machine-coding/snake-game/#interview-notes","title":"Interview Notes","text":"<ul> <li>Always remove the tail before checking self-collision</li> <li>Persist game-over state</li> <li>Deque + HashSet is the optimal combination</li> <li>Follow inclusive boundary rules strictly</li> </ul> <p>If you want, next I can:</p> <ul> <li>Add this to <code>mkdocs.yml</code> navigation</li> <li>Convert Text Editor (Undo/Redo) to the same format</li> <li>Create a reusable LLD markdown template</li> <li>Refactor code for interview-grade clarity</li> </ul> <p>Just tell me what\u2019s next.</p>"},{"location":"machine-coding/text-editor/","title":"Design a Text Editor with Undo &amp; Redo","text":""},{"location":"machine-coding/text-editor/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design an in-memory text editor that:</p> <ul> <li>Stores text row-wise (line by line)</li> <li>Supports insert and delete operations on a single row</li> <li>Supports Undo and Redo</li> <li>Maintains edit history correctly</li> <li>Does NOT remove empty rows</li> </ul> <p>Each operation modifies exactly one row.</p>"},{"location":"machine-coding/text-editor/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/text-editor/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Insert text at a given row and column</li> <li>Delete text from a given row and column range</li> <li>Undo the most recent change</li> <li>Redo the most recently undone change</li> <li>Read the content of a row at any time</li> </ul>"},{"location":"machine-coding/text-editor/#key-observations","title":"Key Observations","text":"<ul> <li>Undo/Redo works best with Command Pattern</li> <li>Each edit operation should know how to execute and undo</li> <li>Redo history must be cleared after any new edit</li> </ul>"},{"location":"machine-coding/text-editor/#design-patterns-principles-used","title":"\ud83c\udfd7\ufe0f Design Patterns &amp; Principles Used","text":"<ul> <li>Command Pattern \u2192 Encapsulates edit operations</li> <li>Stack-based Undo/Redo</li> <li>Single Responsibility Principle</li> <li>Encapsulation</li> </ul>"},{"location":"machine-coding/text-editor/#data-model","title":"\ud83d\uddc2\ufe0f Data Model","text":"<pre><code>TextEditor\n\u251c\u2500\u2500 List&lt;StringBuilder&gt; rows\n\u251c\u2500\u2500 Stack&lt;Command&gt; undoStack\n\u251c\u2500\u2500 Stack&lt;Command&gt; redoStack\n\nCommand (interface)\n\u251c\u2500\u2500 execute()\n\u251c\u2500\u2500 undo()\n\nAddTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 column\n\u251c\u2500\u2500 text\n\nDeleteTextCommand implements Command\n\u251c\u2500\u2500 row\n\u251c\u2500\u2500 startColumn\n\u251c\u2500\u2500 deletedText\n</code></pre>"},{"location":"machine-coding/text-editor/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>import java.util.*;\n\npublic class TextEditor {\n\n    private final List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();\n    private final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();\n    private final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();\n\n    /* ==================== PUBLIC APIs ==================== */\n\n    public void addText(int row, int column, String text) {\n        ensureRowExists(row);\n\n        Command cmd = new AddTextCommand(row, column, text);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void deleteText(int row, int startColumn, int length) {\n        Command cmd = new DeleteTextCommand(row, startColumn, length);\n        cmd.execute();\n\n        undoStack.push(cmd);\n        redoStack.clear();\n    }\n\n    public void undo() {\n        if (undoStack.isEmpty()) return;\n\n        Command cmd = undoStack.pop();\n        cmd.undo();\n        redoStack.push(cmd);\n    }\n\n    public void redo() {\n        if (redoStack.isEmpty()) return;\n\n        Command cmd = redoStack.pop();\n        cmd.execute();\n        undoStack.push(cmd);\n    }\n\n    public String readLine(int row) {\n        return rows.get(row).toString();\n    }\n\n    /* ==================== INTERNAL HELPERS ==================== */\n\n    private void ensureRowExists(int row) {\n        while (rows.size() &lt;= row) {\n            rows.add(new StringBuilder());\n        }\n    }\n\n    /* ==================== COMMAND INTERFACE ==================== */\n\n    private interface Command {\n        void execute();\n        void undo();\n    }\n\n    /* ==================== ADD TEXT COMMAND ==================== */\n\n    private class AddTextCommand implements Command {\n        private final int row;\n        private final int column;\n        private final String text;\n\n        AddTextCommand(int row, int column, String text) {\n            this.row = row;\n            this.column = column;\n            this.text = text;\n        }\n\n        @Override\n        public void execute() {\n            rows.get(row).insert(column, text);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).delete(column, column + text.length());\n        }\n    }\n\n    /* ==================== DELETE TEXT COMMAND ==================== */\n\n    private class DeleteTextCommand implements Command {\n        private final int row;\n        private final int startColumn;\n        private final int length;\n        private String deletedText;\n\n        DeleteTextCommand(int row, int startColumn, int length) {\n            this.row = row;\n            this.startColumn = startColumn;\n            this.length = length;\n        }\n\n        @Override\n        public void execute() {\n            StringBuilder sb = rows.get(row);\n            deletedText = sb.substring(startColumn, startColumn + length);\n            sb.delete(startColumn, startColumn + length);\n        }\n\n        @Override\n        public void undo() {\n            rows.get(row).insert(startColumn, deletedText);\n        }\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/","title":"Design a Tic-Tac-Toe Game (NxN)","text":""},{"location":"machine-coding/tic-tac-toe/#problem-statement","title":"\ud83d\udcdc Problem Statement","text":"<p>Design a class <code>TicTacGame</code> that simulates a Tic-Tac-Toe game played on an m \u00d7 m board between two players.</p>"},{"location":"machine-coding/tic-tac-toe/#rules","title":"Rules","text":"<ul> <li>Players take turns placing marks on empty cells.</li> <li>Player 1 uses A, Player 2 uses B.</li> <li>The first player to place m consecutive symbols in:</li> <li>a row</li> <li>a column</li> <li>a diagonal   wins the game.</li> <li>Once a player wins, no further moves are allowed.</li> <li>Every subsequent move must return the same winner.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-overview","title":"\ud83e\udde0 Design Overview","text":""},{"location":"machine-coding/tic-tac-toe/#key-observations","title":"Key Observations","text":"<ul> <li>Full board storage is not required.</li> <li>Each move affects:</li> <li>one row</li> <li>one column</li> <li>possibly two diagonals</li> <li>Winning can be checked in O(1) time.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#data-structures-used","title":"\ud83c\udfd7\ufe0f Data Structures Used","text":"Structure Purpose <code>int[] rows</code> Row-wise score tracking <code>int[] cols</code> Column-wise score tracking <code>int diag</code> Main diagonal score <code>int antiDiag</code> Anti-diagonal score <code>boolean gameOver</code> Locks the game after win <code>int winner</code> Stores the winning player"},{"location":"machine-coding/tic-tac-toe/#scoring-technique","title":"Scoring Technique","text":"<ul> <li>Player 1 \u2192 <code>+1</code></li> <li>Player 2 \u2192 <code>-1</code></li> <li>If absolute value reaches <code>m</code>, that player wins.</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#design-patterns-used","title":"\ud83e\udde9 Design Patterns Used","text":"<ul> <li>Encapsulation</li> <li>State Management</li> <li>Optimized Win Detection</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#java-implementation","title":"\ud83d\udcbb Java Implementation","text":"<pre><code>public class TicTacGame {\n\n    private int m;\n    private int[] rows;\n    private int[] cols;\n    private int diag;\n    private int antiDiag;\n    private boolean gameOver;\n    private int winner;\n\n    public TicTacGame(int m) {\n        this.m = m;\n        this.rows = new int[m];\n        this.cols = new int[m];\n        this.diag = 0;\n        this.antiDiag = 0;\n        this.gameOver = false;\n        this.winner = 0;\n    }\n\n    /**\n     * @param row    row index\n     * @param col    column index\n     * @param player 1 or 2\n     * @return 0 = no winner, 1 = player 1 wins, 2 = player 2 wins\n     */\n    public int doMove(int row, int col, int player) {\n\n        // If game already ended, always return winner\n        if (gameOver) {\n            return winner;\n        }\n\n        int val = (player == 1) ? 1 : -1;\n\n        rows[row] += val;\n        cols[col] += val;\n\n        if (row == col) {\n            diag += val;\n        }\n\n        if (row + col == m - 1) {\n            antiDiag += val;\n        }\n\n        if (Math.abs(rows[row]) == m ||\n            Math.abs(cols[col]) == m ||\n            Math.abs(diag) == m ||\n            Math.abs(antiDiag) == m) {\n\n            gameOver = true;\n            winner = player;\n            return player;\n        }\n\n        return 0;\n    }\n}\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#edge-cases-handled","title":"\u26a0\ufe0f Edge Cases Handled","text":"<ul> <li>Winning by row, column, or diagonal</li> <li>Game lock after win</li> <li>Repeated moves return same winner</li> <li>Works for large boards (<code>m \u2264 200</code>)</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#complexity-analysis","title":"\u23f1\ufe0f Complexity Analysis","text":"Operation Time Space <code>doMove()</code> O(1) O(m)"},{"location":"machine-coding/tic-tac-toe/#example","title":"\ud83e\uddea Example","text":"<pre><code>TicTacGame game = new TicTacGame(2);\n\ngame.doMove(0, 1, 1); // 0\ngame.doMove(0, 0, 2); // 0\ngame.doMove(1, 1, 1); // 1 (Player 1 wins)\ngame.doMove(1, 0, 2); // 1 (Winner persists)\n</code></pre>"},{"location":"machine-coding/tic-tac-toe/#interview-notes","title":"\u2705 Interview Notes","text":"<ul> <li>Classic LLD + algorithm optimization problem</li> <li>Demonstrates clean state handling</li> <li>Shows ability to avoid brute-force board scanning</li> </ul>"},{"location":"machine-coding/tic-tac-toe/#possible-extensions","title":"\ud83d\ude80 Possible Extensions","text":"<ul> <li>Undo / Redo support</li> <li>Move history tracking</li> <li>UI rendering</li> <li>Multiplayer support</li> </ul>"}]}